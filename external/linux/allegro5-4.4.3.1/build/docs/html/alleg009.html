<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><head><title>
Allegro Manual: Bitmap objects
</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="Content-Style-Type" content="text/css">
<link rel="stylesheet" title="Default" type="text/css" href="allegro.css"></head><body bgcolor=white text=black link="#0000ee" alink="#ff0000" vlink="#551a8b">
<h1><a name="Bitmap objects">Bitmap objects</a></h1>

<ul>
<li><a href="#acquire_bitmap">acquire_bitmap</a> &mdash; Locks the bitmap before drawing onto it.
<li><a href="#acquire_screen">acquire_screen</a> &mdash; Shortcut of acquire_bitmap(screen);
<li><a href="#add_clip_rect">add_clip_rect</a> &mdash; Intersects a bitmap's clipping rectangle with the given area.
<li><a href="#bitmap_color_depth">bitmap_color_depth</a> &mdash; Returns the color depth of the specified bitmap.
<li><a href="#bitmap_mask_color">bitmap_mask_color</a> &mdash; Returns the mask color of the specified bitmap.
<li><a href="#create_bitmap">create_bitmap</a> &mdash; Creates a memory bitmap.
<li><a href="#create_bitmap_ex">create_bitmap_ex</a> &mdash; Creates a memory bitmap specifying color depth.
<li><a href="#create_sub_bitmap">create_sub_bitmap</a> &mdash; Creates a memory sub bitmap.
<li><a href="#create_system_bitmap">create_system_bitmap</a> &mdash; Creates a system memory bitmap.
<li><a href="#create_video_bitmap">create_video_bitmap</a> &mdash; Creates a video memory bitmap.
<li><a href="#destroy_bitmap">destroy_bitmap</a> &mdash; Destroys any type of created bitmap.
<li><a href="#get_clip_rect">get_clip_rect</a> &mdash; Returns the clipping rectangle of a bitmap.
<li><a href="#get_clip_state">get_clip_state</a> &mdash; Tells if clipping is on for a bitmap.
<li><a href="#is_inside_bitmap">is_inside_bitmap</a> &mdash; Tells if a point is inside a bitmap.
<li><a href="#is_linear_bitmap">is_linear_bitmap</a> &mdash; Tells if a bitmap is linear.
<li><a href="#is_memory_bitmap">is_memory_bitmap</a> &mdash; Tells if a bitmap is a memory bitmap.
<li><a href="#is_planar_bitmap">is_planar_bitmap</a> &mdash; Tells if a bitmap is a planar screen bitmap.
<li><a href="#is_same_bitmap">is_same_bitmap</a> &mdash; Tells if two bitmaps describe the same drawing surface.
<li><a href="#is_screen_bitmap">is_screen_bitmap</a> &mdash; Tells if a bitmap is the screen bitmap or sub bitmap.
<li><a href="#is_sub_bitmap">is_sub_bitmap</a> &mdash; Tells if a bitmap is a sub bitmap.
<li><a href="#is_system_bitmap">is_system_bitmap</a> &mdash; Tells if a bitmap is a system bitmap or sub bitmap.
<li><a href="#is_video_bitmap">is_video_bitmap</a> &mdash; Tells if a bitmap is a screen bitmap, video memory or sub bitmap.
<li><a href="#lock_bitmap">lock_bitmap</a> &mdash; Locks the memory used by a bitmap.
<li><a href="#release_bitmap">release_bitmap</a> &mdash; Releases a previously locked bitmap.
<li><a href="#release_screen">release_screen</a> &mdash; Shortcut of release_bitmap(screen);
<li><a href="#screen">screen</a> &mdash; Global pointer to the screen hardware video memory.
<li><a href="#SCREEN_H">SCREEN_H</a> &mdash; Global define to obtain the size of the screen.
<li><a href="#SCREEN_W">SCREEN_W</a> &mdash; Global define to obtain the size of the screen.
<li><a href="#set_clip_rect">set_clip_rect</a> &mdash; Sets the clipping rectangle of a bitmap.
<li><a href="#set_clip_state">set_clip_state</a> &mdash; Turns on or off the clipping of a bitmap.
<li><a href="#VIRTUAL_H">VIRTUAL_H</a> &mdash; Global define to obtain the virtual size of the screen.
<li><a href="#VIRTUAL_W">VIRTUAL_W</a> &mdash; Global define to obtain the virtual size of the screen.
</ul>

<p>
Once you have selected a graphics mode, you can draw things onto the display 
via the <tt>`screen'</tt> bitmap. All the Allegro graphics routines draw onto BITMAP
structures, which are areas of memory containing rectangular images, stored 
as packed byte arrays (in 8-bit modes one byte per pixel, in 15- and 16-bit
modes two bytes per pixel, in 24-bit modes 3 bytes per pixel and in 32-bit
modes 4 bytes per pixel). You can create and manipulate bitmaps in system
RAM, or you can write to the special <tt>`screen'</tt> bitmap which represents the
video memory in your graphics card.

<p>
Read chapter "Direct access to video memory" for information on how to get
direct access to the image memory in a bitmap.

<p>
Allegro supports several different types of bitmaps:
<ul><li>
   The <tt>`screen'</tt> bitmap, which represents the hardware video memory. Ultimately
   you have to draw onto this in order for your image to be visible. It is
   destroyed by any subsequent calls to set_gfx_mode(), so you should never
   attempt to destroy it yourself.
<li>
   Memory bitmaps, which are located in system RAM and can be used to store
   graphics or as temporary drawing spaces for double buffered systems. These
   can be obtained by calling create_bitmap(), load_pcx(), or by loading a
   grabber datafile.
<li>
   Sub-bitmaps. These share image memory with a parent bitmap (which can be
   the screen, a video or system bitmap, a memory bitmap, or another
   sub-bitmap), so drawing onto them will also change their parent. They can
   be of any size and located anywhere within the parent bitmap, and can have
   their own clipping rectangles, so they are a useful way of dividing a
   bitmap into several smaller units, eg. splitting a large virtual screen
   into multiple sections (see examples/exscroll.c).

   Warning: Make sure not to destroy a bitmap before all of its sub-bitmaps,
   otherwise bad things will happen when you try to access one of these
   sub-bitmaps.
<li>
   Video memory bitmaps. These are created by the create_video_bitmap()
   function, and are usually implemented as sub-bitmaps of the screen object.
   They must be destroyed by destroy_bitmap() before any subsequent calls to
   set_gfx_mode().
<li>
   System bitmaps. These are created by the create_system_bitmap() function,
   and are a sort of halfway house between memory and video bitmaps. They
   live in system memory, so you aren't limited by the amount of video ram in
   your card, but they are stored in a platform-specific format that may
   enable better hardware acceleration than is possible with a normal memory
   bitmap (see the GFX_HW_SYS_TO_VRAM_BLIT and GFX_HW_SYS_TO_VRAM_BLIT_MASKED
   flags in gfx_capabilities). System bitmaps must be accessed in the same way
   as video bitmaps, using the bank switch functions and bmp_write*() macros.
   Not every platform implements this type of bitmap: if they aren't
   available, create_system_bitmap() will function identically to
   create_bitmap(). They must be destroyed by destroy_bitmap() before any
   subsequent calls to set_gfx_mode().
</ul>

<p><br>
<div class="al-api"><b>extern <a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *<a name="screen">screen</a>;</b></div><br>
   Global pointer to a bitmap, sized VIRTUAL_W x VIRTUAL_H. This is created 
   by set_gfx_mode(), and represents the hardware video memory. Only a part 
   of this bitmap will actually be visible, sized SCREEN_W x SCREEN_H. 
   Normally this is the top left corner of the larger virtual screen, so you 
   can ignore the extra invisible virtual size of the bitmap if you aren't 
   interested in hardware scrolling or page flipping. To move the visible 
   window to other parts of the screen bitmap, call scroll_screen(). 
   Initially the clipping rectangle will be limited to the physical screen 
   size, so if you want to draw onto a larger virtual screen space outside 
   this rectangle, you will need to adjust the clipping.

<p>
   For example, to draw a pixel onto the screen you would write:
<blockquote class="code"><pre>
      <a href="alleg013.html#putpixel" class="autotype" title="Writes a pixel into a bitmap.">putpixel</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, x, y, color);
</pre></blockquote>
   Or to implement a double-buffered system:
<blockquote class="code"><pre>
      /* Make a bitmap in RAM. */
      <a href="alleg001.html#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp = <a href="#create_bitmap" class="autotype" title="Creates a memory bitmap.">create_bitmap</a>(320, 200);
      /* Clean the memory bitmap. */
      <a href="alleg013.html#clear_bitmap" class="autotype" title="Clears the bitmap to color 0.">clear_bitmap</a>(bmp);
      /* Draw onto the memory bitmap. */
      <a href="alleg013.html#putpixel" class="autotype" title="Writes a pixel into a bitmap.">putpixel</a>(bmp, x, y, color);
      /* Copy it to the <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>. */
      <a href="alleg014.html#blit" class="autotype" title="Copies a rectangular area from one bitmap to another.">blit</a>(bmp, <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>, 0, 0, 0, 0, 320, 200);</pre></blockquote>

<p>
   Warning: be very careful when using this pointer at the same time as any
   bitmaps created by the create_video_bitmap() function (see the description
   of this function for more detailed information). And never try to destroy
   it with destroy_bitmap().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="alleg008.html#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#is_screen_bitmap" title="Tells if a bitmap is the screen bitmap or sub bitmap.">is_screen_bitmap</a>,
<a class="xref" href="#create_video_bitmap" title="Creates a video memory bitmap.">create_video_bitmap</a>,
<a class="xref" href="alleg008.html#scroll_screen" title="Requests a hardware scroll request.">scroll_screen</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="alleg045.html#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>#define <a name="SCREEN_W">SCREEN_W</a>;</b></div><br>
<div class="al-api-cont"><b>#define <a name="SCREEN_H">SCREEN_H</a>;</b></div><br>
   Global defines that return the width and height of the screen, or zero if
   the screen has not been initialised yet. Example:
<blockquote class="code"><pre>
      char buf[100];
      ...
      <a href="alleg002.html#uszprintf" class="autotype" title="Writes formatted data into a buffer, specifying size.">uszprintf</a>(buf, sizeof(buf),
                "The <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a> size is %d x %d pixels",
                <a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a>, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="alleg008.html#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#VIRTUAL_W" title="Global define to obtain the virtual size of the screen.">VIRTUAL_W</a>,
<a class="xref" href="#VIRTUAL_H" title="Global define to obtain the virtual size of the screen.">VIRTUAL_H</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="alleg045.html#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>#define <a name="VIRTUAL_W">VIRTUAL_W</a>;</b></div><br>
<div class="al-api-cont"><b>#define <a name="VIRTUAL_H">VIRTUAL_H</a>;</b></div><br>
   Global defines that return the width and height of the virtual screen, or
   zero if the screen has not been initialised yet. Example:
<blockquote class="code"><pre>
      char buf[100];
      ...
      <a href="alleg002.html#uszprintf" class="autotype" title="Writes formatted data into a buffer, specifying size.">uszprintf</a>(buf, sizeof(buf),
                "The virtual <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a> size is %d x %d pixels",
                <a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a>, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="alleg008.html#set_gfx_mode" title="Sets a graphic video mode.">set_gfx_mode</a>,
<a class="xref" href="#SCREEN_W" title="Global define to obtain the size of the screen.">SCREEN_W</a>,
<a class="xref" href="#SCREEN_H" title="Global define to obtain the size of the screen.">SCREEN_H</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *<a name="create_bitmap">create_bitmap</a>(int width, int height);</b></div><br>
   Creates a memory bitmap sized width by height. The bitmap will have
   clipping turned on, and the clipping rectangle set to the full size of the
   bitmap. The image memory will not be cleared, so it will probably contain
   garbage: you should clear the bitmap before using it. This routine always
   uses the global pixel format, as specified by calling set_color_depth().
   The minimum height of the BITMAP must be 1 and width can't be negative.
   Example:
<blockquote class="code"><pre>
      /* Create a 10 pixel tall bitmap, as wide as the <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>. */
      <a href="alleg001.html#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp = <a href="#create_bitmap" class="autotype" title="Creates a memory bitmap.">create_bitmap</a>(<a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a>, 10);
      if (!bmp)
         abort_on_error("Couldn't create bitmap!");
      /* Use the bitmap. */
      ...
      /* Destroy it when we don't need it any more. */
      <a href="#destroy_bitmap" class="autotype" title="Destroys any type of created bitmap.">destroy_bitmap</a>(bmp);</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the created bitmap, or NULL if the bitmap could not
   be created. Remember to free this bitmap later to avoid memory leaks.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_bitmap_ex" title="Creates a memory bitmap specifying color depth.">create_bitmap_ex</a>,
<a class="xref" href="#create_sub_bitmap" title="Creates a memory sub bitmap.">create_sub_bitmap</a>,
<a class="xref" href="#create_video_bitmap" title="Creates a video memory bitmap.">create_video_bitmap</a>,
<a class="xref" href="#create_system_bitmap" title="Creates a system memory bitmap.">create_system_bitmap</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="alleg008.html#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#is_memory_bitmap" title="Tells if a bitmap is a memory bitmap.">is_memory_bitmap</a>,
<a class="xref" href="alleg013.html#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="alleg013.html#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="alleg045.html#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *<a name="create_bitmap_ex">create_bitmap_ex</a>(int color_depth, int width, int height);</b></div><br>
   Creates a bitmap in a specific color depth (8, 15, 16, 24 or 32 bits per 
   pixel). Example:
<blockquote class="code"><pre>
      /* Create <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a> sized bitmap in 32 bits per pixel. */
      <a href="alleg001.html#BITMAP" class="autotype" title="Stores the contents of a bitmap.">BITMAP</a> *bmp = <a href="#create_bitmap_ex" class="autotype" title="Creates a memory bitmap specifying color depth.">create_bitmap_ex</a>(32, <a href="#SCREEN_W" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_W</a>, <a href="#SCREEN_H" class="autotype" title="Global define to obtain the size of the screen.">SCREEN_H</a>);
      if (!bmp)
         abort_on_error("Couldn't create bitmap!");
      /* Use the bitmap. */
      ...
      /* Destroy it when we don't need it any more. */
      <a href="#destroy_bitmap" class="autotype" title="Destroys any type of created bitmap.">destroy_bitmap</a>(bmp);</pre></blockquote>
<p><b>Return value:</b>
   Returns a pointer to the created bitmap, or NULL if the bitmap could not
   be created. Remember to free this bitmap later to avoid memory leaks.
   


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#create_sub_bitmap" title="Creates a memory sub bitmap.">create_sub_bitmap</a>,
<a class="xref" href="#create_video_bitmap" title="Creates a video memory bitmap.">create_video_bitmap</a>,
<a class="xref" href="#create_system_bitmap" title="Creates a system memory bitmap.">create_system_bitmap</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#is_memory_bitmap" title="Tells if a bitmap is a memory bitmap.">is_memory_bitmap</a>,
<a class="xref" href="alleg013.html#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="alleg013.html#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="alleg045.html#ex12bit" title="How to fake a 12-bit truecolor mode on an 8-bit card.">ex12bit</a>,
<a class="eref" href="alleg045.html#exlights" title="One way to do colored lighting effects in a hicolor video mode.">exlights</a>,
<a class="eref" href="alleg045.html#exrgbhsv" title="RGB <-> HSV color space conversions.">exrgbhsv</a>,
<a class="eref" href="alleg045.html#extrans" title="Lighting and translucency effects.">extrans</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *<a name="create_sub_bitmap">create_sub_bitmap</a>(<a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *parent, int x, y, width, height);</b></div><br>
   Creates a sub-bitmap, ie. a bitmap sharing drawing memory with a 
   pre-existing bitmap, but possibly with a different size and clipping 
   settings. When creating a sub-bitmap of the mode-X screen, the x position 
   must be a multiple of four. The sub-bitmap width and height can extend 
   beyond the right and bottom edges of the parent (they will be clipped), 
   but the origin point must lie within the parent region.
<p><b>Return value:</b>
   Returns a pointer to the created sub bitmap, or NULL if the sub bitmap
   could not be created. Remember to free the sub bitmap before freeing
   the parent bitmap to avoid memory leaks and potential crashes accessing
   memory which has been freed.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#create_bitmap_ex" title="Creates a memory bitmap specifying color depth.">create_bitmap_ex</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#is_sub_bitmap" title="Tells if a bitmap is a sub bitmap.">is_sub_bitmap</a>,
<a class="xref" href="alleg013.html#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="alleg013.html#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="alleg045.html#expat" title="Using patterned drawing modes and sub-bitmaps.">expat</a>,
<a class="eref" href="alleg045.html#exscroll" title="Mode-X hardware scrolling and split screens.">exscroll</a>,
<a class="eref" href="alleg045.html#exswitch" title="Controlling the console switch mode for background running.">exswitch</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *<a name="create_video_bitmap">create_video_bitmap</a>(int width, int height);</b></div><br>
   Allocates a video memory bitmap of the specified size. This can be used
   to allocate offscreen video memory for storing source graphics ready for
   a hardware accelerated blitting operation, or to create multiple video
   memory pages which can then be displayed by calling show_video_bitmap().
   Read the introduction of this chapter for a comparison with other types
   of bitmaps and other specific details.

<p>
   Warning: video memory bitmaps are usually allocated from the same space
   as the screen bitmap, so they may overlap with it; it is therefore not
   a good idea to use the global screen at the same time as any surfaces
   returned by this function.
<p><b>Return value:</b>
   Returns a pointer to the bitmap on success, or NULL if you have run out
   of video ram. Remember to destroy this bitmap before any subsequent
   call to set_gfx_mode().
   

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#create_bitmap_ex" title="Creates a memory bitmap specifying color depth.">create_bitmap_ex</a>,
<a class="xref" href="#create_system_bitmap" title="Creates a system memory bitmap.">create_system_bitmap</a>,
<a class="xref" href="#create_sub_bitmap" title="Creates a memory sub bitmap.">create_sub_bitmap</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="alleg008.html#show_video_bitmap" title="Flips the hardware screen to use the specified page.">show_video_bitmap</a>,
<a class="xref" href="alleg008.html#gfx_capabilities" title="Bitfield describing video hardware capabilities.">gfx_capabilities</a>,
<a class="xref" href="#is_video_bitmap" title="Tells if a bitmap is a screen bitmap, video memory or sub bitmap.">is_video_bitmap</a>,
<a class="xref" href="alleg013.html#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="alleg013.html#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="alleg045.html#ex3buf" title="Mode-X triple buffering and retrace interrupt simulation.">ex3buf</a>,
<a class="eref" href="alleg045.html#exaccel" title="Using offscreen video memory to store source graphics for VBE/AF.">exaccel</a>,
<a class="eref" href="alleg045.html#exflip" title="Comparison of double buffering and page flipping.">exflip</a>,
<a class="eref" href="alleg045.html#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>.</blockquote>
<div class="al-api"><b><a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *<a name="create_system_bitmap">create_system_bitmap</a>(int width, int height);</b></div><br>
   Allocates a system memory bitmap of the specified size. Read the
   introduction of this chapter for a comparison with other types of bitmaps
   and other specific details.
<p><b>Return value:</b>
   Returns a pointer to the bitmap on success, NULL otherwise. Remember to
   destroy this bitmap before any subsequent call to set_gfx_mode().
   

<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="#create_bitmap_ex" title="Creates a memory bitmap specifying color depth.">create_bitmap_ex</a>,
<a class="xref" href="#create_video_bitmap" title="Creates a video memory bitmap.">create_video_bitmap</a>,
<a class="xref" href="#create_sub_bitmap" title="Creates a memory sub bitmap.">create_sub_bitmap</a>,
<a class="xref" href="#destroy_bitmap" title="Destroys any type of created bitmap.">destroy_bitmap</a>,
<a class="xref" href="#is_system_bitmap" title="Tells if a bitmap is a system bitmap or sub bitmap.">is_system_bitmap</a>,
<a class="xref" href="alleg013.html#clear_bitmap" title="Clears the bitmap to color 0.">clear_bitmap</a>,
<a class="xref" href="alleg013.html#clear_to_color" title="Clears the bitmap to the specified color.">clear_to_color</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="alleg045.html#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>.</blockquote>
<div class="al-api"><b>void <a name="destroy_bitmap">destroy_bitmap</a>(<a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap);</b></div><br>
   Destroys a memory bitmap, sub-bitmap, video memory bitmap, or system 
   bitmap when you are finished with it. If you pass a NULL pointer this
   function won't do anything. See above for the restrictions as to when you
   are allowed to destroy the various types of bitmaps.

<p>
   The bitmap must not have a mouse cursor shown on it at the time it is
   destroyed.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_bitmap" title="Creates a memory bitmap.">create_bitmap</a>,
<a class="xref" href="alleg010.html#load_bitmap" title="Loads any supported bitmap from a file.">load_bitmap</a>,
<a class="xref" href="alleg004.html#show_mouse" title="Tells Allegro to display a mouse pointer on the screen.">show_mouse</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="alleg045.html#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>void <a name="lock_bitmap">lock_bitmap</a>(<a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap);</b></div><br>
   Under DOS, locks all the memory used by a bitmap. You don't normally need
   to call this function unless you are doing very weird things in your
   program.

<p><br>
<div class="al-api"><b>int <a name="bitmap_color_depth">bitmap_color_depth</a>(<a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Returns the color depth of the specified bitmap (8, 15, 16, 24, or 32).
   Example:
<blockquote class="code"><pre>
      switch (<a href="#bitmap_color_depth" class="autotype" title="Returns the color depth of the specified bitmap.">bitmap_color_depth</a>(<a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a>)) {
         case 8:
            /* Access <a href="#screen" class="autotype" title="Global pointer to the screen hardware video memory.">screen</a> using optimized 8-bit code. */
            break;
         default:
            /* Use generic slow functions. */
            break;
      }</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="alleg008.html#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#bitmap_mask_color" title="Returns the mask color of the specified bitmap.">bitmap_mask_color</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="alleg045.html#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="alleg045.html#exlights" title="One way to do colored lighting effects in a hicolor video mode.">exlights</a>,
<a class="eref" href="alleg045.html#exscn3d" title="Using the 3d scene functions.">exscn3d</a>,
<a class="eref" href="alleg045.html#exswitch" title="Controlling the console switch mode for background running.">exswitch</a>,
<a class="eref" href="alleg045.html#extrans" title="Lighting and translucency effects.">extrans</a>,
<a class="eref" href="alleg045.html#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>,
<a class="eref" href="alleg045.html#exzbuf" title="Z-buffered polygons demo.">exzbuf</a>.</blockquote>
<div class="al-api"><b>int <a name="bitmap_mask_color">bitmap_mask_color</a>(<a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Returns the mask color for the specified bitmap (the value which is 
   skipped when drawing sprites). For 256-color bitmaps this is zero, and 
   for truecolor bitmaps it is bright pink (maximum red and blue, zero
   green). A frequent use of this function is to clear a bitmap with the mask
   color so you can later use this bitmap with masked_blit() or
   draw_sprite() after drawing other stuff on it. Example:
<blockquote class="code"><pre>
      /* Replace mask color with another color. */
      for (y = 0; y < bmp->h; y++)
         for (x = 0; x < bmp->w; x++)
            if (<a href="alleg013.html#getpixel" class="autotype" title="Reads a pixel from a bitmap.">getpixel</a>(bmp, x, y) == <a href="#bitmap_mask_color" class="autotype" title="Returns the mask color of the specified bitmap.">bitmap_mask_color</a>(bmp))
               <a href="alleg013.html#putpixel" class="autotype" title="Writes a pixel into a bitmap.">putpixel</a>(bmp, x, y, another_color);</pre></blockquote>


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="alleg012.html#MASK_COLOR_8" title="Constant representing the mask value in sprites.">MASK_COLOR_8</a>,
<a class="xref" href="alleg008.html#set_color_depth" title="Sets the global pixel color depth.">set_color_depth</a>,
<a class="xref" href="#bitmap_color_depth" title="Returns the color depth of the specified bitmap.">bitmap_color_depth</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="alleg045.html#ex3d" title="3d 'bouncy cubes' demo.">ex3d</a>,
<a class="eref" href="alleg045.html#exmouse" title="Getting input from the mouse.">exmouse</a>,
<a class="eref" href="alleg045.html#expat" title="Using patterned drawing modes and sub-bitmaps.">expat</a>.</blockquote>
<div class="al-api"><b>int <a name="is_same_bitmap">is_same_bitmap</a>(<a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp1, <a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp2);</b></div><br>
   Returns TRUE if the two bitmaps describe the same drawing surface, ie. 
   the pointers are equal, one is a sub-bitmap of the other, or they are 
   both sub-bitmaps of a common parent.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_sub_bitmap" title="Creates a memory sub bitmap.">create_sub_bitmap</a>.</blockquote>
<div class="al-api"><b>int <a name="is_planar_bitmap">is_planar_bitmap</a>(<a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Returns TRUE if bmp is a planar (mode-X or Xtended mode) screen bitmap.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#is_linear_bitmap" title="Tells if a bitmap is linear.">is_linear_bitmap</a>,
<a class="xref" href="#is_memory_bitmap" title="Tells if a bitmap is a memory bitmap.">is_memory_bitmap</a>.</blockquote>
<div class="al-api"><b>int <a name="is_linear_bitmap">is_linear_bitmap</a>(<a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Returns TRUE if bmp is a linear bitmap, i.e. a bitmap that can be accessed
   linearly within each scanline (for example a memory bitmap, the DOS VGA
   or SVGA screen, Windows bitmaps, etc). Linear bitmaps can be used with the
   _putpixel(), _getpixel(), bmp_write_line(), and bmp_read_line() functions.

<p>
   Historically there were only linear and planar bitmaps for Allegro, so
   is_linear_bitmap() is actually an alias for !is_planar_bitmap().


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#is_planar_bitmap" title="Tells if a bitmap is a planar screen bitmap.">is_planar_bitmap</a>,
<a class="xref" href="#is_memory_bitmap" title="Tells if a bitmap is a memory bitmap.">is_memory_bitmap</a>.</blockquote>
<div class="al-api"><b>int <a name="is_memory_bitmap">is_memory_bitmap</a>(<a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Returns TRUE if bmp is a memory bitmap, ie. it was created by calling 
   create_bitmap() or loaded from a grabber datafile or image file. Memory 
   bitmaps can be accessed directly via the line pointers in the bitmap 
   structure, eg. bmp-&gt;line[y][x] = color.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#is_linear_bitmap" title="Tells if a bitmap is linear.">is_linear_bitmap</a>,
<a class="xref" href="#is_planar_bitmap" title="Tells if a bitmap is a planar screen bitmap.">is_planar_bitmap</a>.</blockquote>
<div class="al-api"><b>int <a name="is_screen_bitmap">is_screen_bitmap</a>(<a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Returns TRUE if bmp is the screen bitmap, or a sub-bitmap of the screen.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#create_sub_bitmap" title="Creates a memory sub bitmap.">create_sub_bitmap</a>.</blockquote>
<div class="al-api"><b>int <a name="is_video_bitmap">is_video_bitmap</a>(<a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Returns TRUE if bmp is the screen bitmap, a video memory bitmap, or a 
   sub-bitmap of either.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#screen" title="Global pointer to the screen hardware video memory.">screen</a>,
<a class="xref" href="#create_video_bitmap" title="Creates a video memory bitmap.">create_video_bitmap</a>,
<a class="xref" href="#create_sub_bitmap" title="Creates a memory sub bitmap.">create_sub_bitmap</a>.</blockquote>
<div class="al-api"><b>int <a name="is_system_bitmap">is_system_bitmap</a>(<a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Returns TRUE if bmp is a system bitmap object, or a sub-bitmap of one.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_system_bitmap" title="Creates a system memory bitmap.">create_system_bitmap</a>,
<a class="xref" href="#create_sub_bitmap" title="Creates a memory sub bitmap.">create_sub_bitmap</a>.</blockquote>
<div class="al-api"><b>int <a name="is_sub_bitmap">is_sub_bitmap</a>(<a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Returns TRUE if bmp is a sub-bitmap.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#create_sub_bitmap" title="Creates a memory sub bitmap.">create_sub_bitmap</a>.</blockquote>
<div class="al-api"><b>void <a name="acquire_bitmap">acquire_bitmap</a>(<a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Acquires the specified video bitmap prior to drawing onto it. You never need
   to call the function explicitly as it is low level, and will only give you a
   speed up if you know what you are doing. Using it wrongly may cause slowdown,
   or even lock up your program.

<p>
   Note: You do never need to use acquire_bitmap on a memory bitmap, i.e. a
   normal bitmap created with create_bitmap. It will simply do nothing in that
   case.

<p>
   It still can be useful, because e.g. under the current DirectDraw driver of
   Allegro, most drawing functions need to lock a video bitmap before drawing to
   it. But doing this is very slow, so you will get much better performance if
   you acquire the screen just once at the start of your main redraw function,
   then call multiple drawing operations which need the bitmap locked, and only
   release it when done.

<p>
   Multiple acquire calls may be nested, but you must make sure to match up the
   acquire_bitmap and release_bitmap calls. Be warned that DirectX and X11
   programs activate a mutex lock whenever a surface is locked, which prevents
   them from getting any input messages, so you must be sure to release all your
   bitmaps before using any timer, keyboard, or other non-graphics routines!

<p>
   Note that if you are using hardware accelerated VRAM-&gt;VRAM functions, you
   should not call acquire_bitmap(). Such functions need an unlocked target
   bitmap under DirectX, so there is now just the opposite case from before - if
   the bitmap is already locked with acquire_bitmap, the drawing
   operation has to unlock it.

<p>
   Note: For backwards compatibility, the unlocking behavior of such functions
   is permanent. That is, if you call acquire_bitmap first, then call e.g. an
   accelerated blit, the DirectX bitmap will be unlocked internally (it won't
   affect the nesting counter of acquire/release calls).

<p>
   There is no clear cross-platform way in this Allegro version to know which
   drawing operations need a locked/unlocked state. For example a normal
   rectfill most probably is accelerated under DirectX, and therefore needs the
   screen unlocked, but an XOR rectfill, or one with blending activated, most
   probably is not, and therefore locks the screen. And while the DirectX driver
   will do automatic unlocking, there is no such thing under X11, where the
   function is used to synchronize X11 calls from different threads. Your best
   bet is to never use acquire_bitmap - changes are you are doing something in
   the wrong way if you think you need it.

<p>
   Warning: This function can be very dangerous to use, since the whole program
   may get locked while the bitmap is locked. So the lock should only be held
   for a short time, and you should not call anything but drawing operations
   onto the locked video bitmap while a lock is in place. Especially don't call
   things like show_mouse (or scare_mouse which calls that) or readkey, since
   it will most likely deadlock your entire program.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#release_bitmap" title="Releases a previously locked bitmap.">release_bitmap</a>,
<a class="xref" href="#acquire_screen" title="Shortcut of acquire_bitmap(screen);">acquire_screen</a>,
<a class="xref" href="#release_screen" title="Shortcut of release_bitmap(screen);">release_screen</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="alleg045.html#ex3buf" title="Mode-X triple buffering and retrace interrupt simulation.">ex3buf</a>,
<a class="eref" href="alleg045.html#exaccel" title="Using offscreen video memory to store source graphics for VBE/AF.">exaccel</a>,
<a class="eref" href="alleg045.html#expat" title="Using patterned drawing modes and sub-bitmaps.">expat</a>,
<a class="eref" href="alleg045.html#exquat" title="A comparison between Euler angles and quaternions.">exquat</a>,
<a class="eref" href="alleg045.html#exscroll" title="Mode-X hardware scrolling and split screens.">exscroll</a>,
<a class="eref" href="alleg045.html#exswitch" title="Controlling the console switch mode for background running.">exswitch</a>,
<a class="eref" href="alleg045.html#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>.</blockquote>
<div class="al-api"><b>void <a name="release_bitmap">release_bitmap</a>(<a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp);</b></div><br>
   Releases a bitmap that was previously locked by calling acquire_bitmap(). 
   If the bitmap was locked multiple times, you must release it the same 
   number of times before it will truly be unlocked.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#acquire_bitmap" title="Locks the bitmap before drawing onto it.">acquire_bitmap</a>,
<a class="xref" href="#acquire_screen" title="Shortcut of acquire_bitmap(screen);">acquire_screen</a>,
<a class="xref" href="#release_screen" title="Shortcut of release_bitmap(screen);">release_screen</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="alleg045.html#ex3buf" title="Mode-X triple buffering and retrace interrupt simulation.">ex3buf</a>,
<a class="eref" href="alleg045.html#exaccel" title="Using offscreen video memory to store source graphics for VBE/AF.">exaccel</a>,
<a class="eref" href="alleg045.html#expat" title="Using patterned drawing modes and sub-bitmaps.">expat</a>,
<a class="eref" href="alleg045.html#exquat" title="A comparison between Euler angles and quaternions.">exquat</a>,
<a class="eref" href="alleg045.html#exscroll" title="Mode-X hardware scrolling and split screens.">exscroll</a>,
<a class="eref" href="alleg045.html#exswitch" title="Controlling the console switch mode for background running.">exswitch</a>,
<a class="eref" href="alleg045.html#exupdate" title="Supporting different screen update methods in a single program.">exupdate</a>.</blockquote>
<div class="al-api"><b>void <a name="acquire_screen">acquire_screen</a>();</b></div><br>
   Shortcut version of acquire_bitmap(screen);


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#acquire_bitmap" title="Locks the bitmap before drawing onto it.">acquire_bitmap</a>,
<a class="xref" href="#release_bitmap" title="Releases a previously locked bitmap.">release_bitmap</a>,
<a class="xref" href="#release_screen" title="Shortcut of release_bitmap(screen);">release_screen</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="alleg045.html#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>void <a name="release_screen">release_screen</a>();</b></div><br>
   Shortcut version of release_bitmap(screen);


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#acquire_bitmap" title="Locks the bitmap before drawing onto it.">acquire_bitmap</a>,
<a class="xref" href="#release_bitmap" title="Releases a previously locked bitmap.">release_bitmap</a>,
<a class="xref" href="#acquire_screen" title="Shortcut of acquire_bitmap(screen);">acquire_screen</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="alleg045.html#Available Allegro examples" title="">Available Allegro examples</a>.</blockquote>
<div class="al-api"><b>void <a name="set_clip_rect">set_clip_rect</a>(<a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap, int x1, int y1, int x2, int y2);</b></div><br>
   Each bitmap has an associated clipping rectangle, which is the area of 
   the image that it is OK to draw onto. Nothing will be drawn to positions
   outside this space. This function sets the clipping rectangle for the
   specified bitmap. Pass the coordinates of the top-left and bottom-right
   corners of the clipping rectangle in this order; these are both inclusive,
   i.e. set_clip_rect(bitmap, 16, 16, 32, 32) will allow drawing to (16, 16)
   and (32, 32), but not to (15, 15) and (33, 33).

<p>
   Drawing operations will be performed (at least partially) on the bitmap as
   long as the first coordinates of its clipping rectangle are not greater
   than the second coordinates and its intersection with the actual image
   is non-empty. If either condition is not fulfilled, drawing will be turned
   off for the bitmap, e.g.
<blockquote class="code"><pre>
      <a href="#set_clip_rect" class="autotype" title="Sets the clipping rectangle of a bitmap.">set_clip_rect</a>(bmp, 0, 0, -1, -1); /* disable drawing on bmp */</pre></blockquote>

<p>
   Note that passing "out-of-bitmap" coordinates is allowed, but they are
   likely to be altered (and so the coordinates returned by get_clip_rect()
   will be different). However, such modifications are guaranteed to preserve
   the external effect of the clipping rectangle, that is not to modify the
   actual area of the image that it is OK to draw onto.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#get_clip_rect" title="Returns the clipping rectangle of a bitmap.">get_clip_rect</a>,
<a class="xref" href="#add_clip_rect" title="Intersects a bitmap's clipping rectangle with the given area.">add_clip_rect</a>,
<a class="xref" href="#set_clip_state" title="Turns on or off the clipping of a bitmap.">set_clip_state</a>,
<a class="xref" href="#get_clip_state" title="Tells if clipping is on for a bitmap.">get_clip_state</a>.</blockquote>

<blockquote class="eref"><em><b>Examples using this:</b></em>
<a class="eref" href="alleg045.html#ex12bit" title="How to fake a 12-bit truecolor mode on an 8-bit card.">ex12bit</a>,
<a class="eref" href="alleg045.html#excamera" title="Viewing a 3d world from an arbitrary camera position.">excamera</a>.</blockquote>
<div class="al-api"><b>void <a name="get_clip_rect">get_clip_rect</a>(<a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap, int *x1, int *y1, int *x2, int *y2);</b></div><br>
   Returns the clipping rectangle for the specified bitmap.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_clip_rect" title="Sets the clipping rectangle of a bitmap.">set_clip_rect</a>,
<a class="xref" href="#add_clip_rect" title="Intersects a bitmap's clipping rectangle with the given area.">add_clip_rect</a>,
<a class="xref" href="#set_clip_state" title="Turns on or off the clipping of a bitmap.">set_clip_state</a>,
<a class="xref" href="#get_clip_state" title="Tells if clipping is on for a bitmap.">get_clip_state</a>.</blockquote>
<div class="al-api"><b>void <a name="add_clip_rect">add_clip_rect</a>(<a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap, int x1, int y1, int x2, int y2);</b></div><br>
   Sets the clipping rectangle of the specified bitmap as the intersection of
   its current clipping rectangle and the rectangle described by the four
   coordinates.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_clip_rect" title="Sets the clipping rectangle of a bitmap.">set_clip_rect</a>,
<a class="xref" href="#get_clip_rect" title="Returns the clipping rectangle of a bitmap.">get_clip_rect</a>,
<a class="xref" href="#set_clip_state" title="Turns on or off the clipping of a bitmap.">set_clip_state</a>,
<a class="xref" href="#get_clip_state" title="Tells if clipping is on for a bitmap.">get_clip_state</a>.</blockquote>
<div class="al-api"><b>void <a name="set_clip_state">set_clip_state</a>(<a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap, int state)</b></div><br>
   Turns on (if state is non-zero) or off (if state is zero) clipping for the
   specified bitmap. Turning clipping off may slightly speed up some drawing
   operations (usually a negligible  difference, although every little helps)
   but will result in your program dying a horrible death if you try to draw
   beyond the edges of the bitmap.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_clip_rect" title="Sets the clipping rectangle of a bitmap.">set_clip_rect</a>,
<a class="xref" href="#get_clip_rect" title="Returns the clipping rectangle of a bitmap.">get_clip_rect</a>,
<a class="xref" href="#add_clip_rect" title="Intersects a bitmap's clipping rectangle with the given area.">add_clip_rect</a>,
<a class="xref" href="#get_clip_state" title="Tells if clipping is on for a bitmap.">get_clip_state</a>.</blockquote>
<div class="al-api"><b>int <a name="get_clip_state">get_clip_state</a>(<a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bitmap)</b></div><br>
   Returns non-zero if clipping is turned on for the specified bitmap and
   zero otherwise.


<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_clip_rect" title="Sets the clipping rectangle of a bitmap.">set_clip_rect</a>,
<a class="xref" href="#get_clip_rect" title="Returns the clipping rectangle of a bitmap.">get_clip_rect</a>,
<a class="xref" href="#add_clip_rect" title="Intersects a bitmap's clipping rectangle with the given area.">add_clip_rect</a>,
<a class="xref" href="#set_clip_state" title="Turns on or off the clipping of a bitmap.">set_clip_state</a>.</blockquote>
<div class="al-api"><b>int <a name="is_inside_bitmap">is_inside_bitmap</a>(<a class="autotype" href="alleg001.html#BITMAP" title="Stores the contents of a bitmap.">BITMAP</a> *bmp, int x, int y, int clip);</b></div><br>
   Returns non-zero if point (x, y) lies inside the bitmap. If <tt>`clip'</tt> is
   non-zero, the function compares the coordinates with the clipping
   rectangle, that is it returns non-zero if the point lies inside the
   clipping rectangle or if clipping is disabled for the bitmap. If <tt>`clip'</tt>
   is zero, the function compares the coordinates with the actual dimensions
   of the bitmap.




<blockquote class="xref"><em><b>See also:</b></em>
<a class="xref" href="#set_clip_rect" title="Sets the clipping rectangle of a bitmap.">set_clip_rect</a>,
<a class="xref" href="#set_clip_state" title="Turns on or off the clipping of a bitmap.">set_clip_state</a>,
<a class="xref" href="alleg013.html#getpixel" title="Reads a pixel from a bitmap.">getpixel</a>.</blockquote>
<hr><div class="al-back-to-contents"><a href="allegro.html">Back to contents</a></div>

</body>
</html>
