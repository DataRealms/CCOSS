This is allegro.info, produced by makeinfo version 6.6 from
allegro.texi.

INFO-DIR-SECTION Libraries
START-INFO-DIR-ENTRY
* Allegro: (allegro).                 The Allegro game programming library.
END-INFO-DIR-ENTRY

This is the Info version of the Allegro manual

By Shawn Hargreaves


File: allegro.info,  Node: Top,  Prev: (dir),  Up: (dir)

          ______   ___    ___
         /\  _  \ /\_ \  /\_ \
         \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
          \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
           \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
            \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
             \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
                                            /\____/
                                            \_/__/     Version 4.4.3


                     A game programming library.

                  By Shawn Hargreaves, Mar 03, 2019.

                     See the AUTHORS file for a
                    complete list of contributors.

#include <std_disclaimer.h>

"I do not accept responsibility for any effects, adverse or otherwise,
that this code may have on you, your computer, your sanity, your dog,
and anything else that you can think of.  Use it at your own risk."

* Menu:

* API::                     API
* Platform::                Platform specifics
* Miscellaneous::           Miscellaneous
* Tools::                   Tools
* Community::               Community
* Conclusion::              Conclusion
* Index::                   Index


File: allegro.info,  Node: API,  Next: Using,  Up: Top

1 API
*****

* Menu:

* Using::                   Using Allegro
* Structures::              Structures and types defined by Allegro
* Unicode::                 Unicode routines
* Configuration::           Configuration routines
* Mouse::                   Mouse routines
* Timer::                   Timer routines
* Keyboard::                Keyboard routines
* Joystick::                Joystick routines
* Graphics::                Graphics modes
* Bitmap::                  Bitmap objects
* Loading::                 Loading image files
* Palette::                 Palette routines
* Truecolor::               Truecolor pixel formats
* Drawing::                 Drawing primitives
* Blitting::                Blitting and sprites
* RLE::                     RLE sprites
* Compiled::                Compiled sprites
* Fonts::                   Fonts
* Text::                    Text output
* Polygon::                 Polygon rendering
* Transparency::            Transparency and patterned drawing
* Converting::              Converting between color formats
* Direct::                  Direct access to video memory
* FLIC::                    FLIC routines
* Sound::                   Sound init routines
* Mixer::                   Mixer routines
* Digital::                 Digital sample routines
* Music::                   Music routines (MIDI)
* Audio::                   Audio stream routines
* Recording::               Recording routines
* File::                    File and compression routines
* Datafile::                Datafile routines
* Fixed::                   Fixed point math routines
* 3D::                      3D math routines
* Quaternion::              Quaternion math routines
* GUI::                     GUI routines


File: allegro.info,  Node: Using,  Next: Structures,  Prev: API,  Up: API

1.1 Using Allegro
=================

See readme.txt for a general introduction, copyright details, and
information about how to install Allegro and link your program with it.

* Menu:

* install_allegro::
* allegro_init::
* allegro_exit::
* END_OF_MAIN::
* allegro_id::
* allegro_error::
* ALLEGRO_VERSION::
* ALLEGRO_SUB_VERSION::
* ALLEGRO_WIP_VERSION::
* ALLEGRO_VERSION_STR::
* ALLEGRO_DATE_STR::
* ALLEGRO_DATE::
* AL_ID::
* MAKE_VERSION::
* os_type::
* os_version::
* os_multitasking::
* allegro_message::
* set_window_title::
* set_close_button_callback::
* desktop_color_depth::
* get_desktop_resolution::
* check_cpu::
* cpu_vendor::
* cpu_family::
* cpu_model::
* cpu_capabilities::


File: allegro.info,  Node: install_allegro,  Next: allegro_init,  Up: Using

1.1.1 install_allegro
---------------------

int install_allegro(int system_id, int *errno_ptr, int (*atexit_ptr)());
     Initialises the Allegro library.  You must call either this or
     allegro_init() before doing anything other than using the Unicode
     routines.  If you want to use a text mode other than UTF-8, you can
     set it with set_uformat() before you call this.  The other
     functions that can be called before this one will be marked
     explicitly in the documentation, like set_config_file().

     The available system ID codes will vary from one platform to
     another, but you will almost always want to pass SYSTEM_AUTODETECT.
     Alternatively, SYSTEM_NONE installs a stripped down version of
     Allegro that won't even try to touch your hardware or do anything
     platform specific: this can be useful for situations where you only
     want to manipulate memory bitmaps, such as the text mode datafile
     tools or the Windows GDI interfacing functions.

     The 'errno_ptr' and 'atexit_ptr' parameters should point to the
     errno variable and atexit function from your libc: these are
     required because when Allegro is linked as a DLL, it doesn't have
     direct access to your local libc data.  'atexit_ptr' may be NULL,
     in which case it is your responsibility to call allegro_exit()
     manually.  Example:

          install_allegro(SYSTEM_AUTODETECT, &errno, atexit);

     This function returns zero on success and non-zero on failure (e.g.
     no system driver could be used).  Note: in previous versions of
     Allegro this function would abort on error.

See also:
*Note allegro_init::.
*Note allegro_exit::.
*Note set_uformat::.
*Note set_config_file::.


File: allegro.info,  Node: allegro_init,  Next: allegro_exit,  Prev: install_allegro,  Up: Using

1.1.2 allegro_init
------------------

int allegro_init();
     Macro which initialises the Allegro library.  This is the same
     thing as calling install_allegro(SYSTEM_AUTODETECT, &errno,
     atexit).

See also:
*Note install_allegro::.
*Note allegro_exit::.
*Note Available Allegro examples: Available.


File: allegro.info,  Node: allegro_exit,  Next: END_OF_MAIN,  Prev: allegro_init,  Up: Using

1.1.3 allegro_exit
------------------

void allegro_exit();
     Closes down the Allegro system.  This includes returning the system
     to text mode and removing whatever mouse, keyboard, and timer
     routines have been installed.  You don't normally need to bother
     making an explicit call to this function, because allegro_init()
     installs it as an atexit() routine so it will be called
     automatically when your program exits.

     Note that after you call this function, other functions like
     destroy_bitmap() will most likely crash.  This is a problem for C++
     global destructors, which usually get called after atexit(), so
     don't put Allegro calls in them.  You can write the destructor code
     in another method which you can manually call before your program
     exits, avoiding this problem.

See also:
*Note install_allegro::.
*Note allegro_init::.
*Note destroy_bitmap::.
*Note ex3d::.
*Note exscn3d::.
*Note exswitch::.
*Note exxfade::.
*Note exzbuf::.


File: allegro.info,  Node: END_OF_MAIN,  Next: allegro_id,  Prev: allegro_exit,  Up: Using

1.1.4 END_OF_MAIN
-----------------

Macro END_OF_MAIN()
     In order to maintain cross-platform compatibility, you have to put
     this macro at the very end of your main function.  This macro uses
     some 'magic' to mangle your main procedure on platforms that need
     it like Windows, some flavours of UNIX or MacOS X. On the other
     platforms this macro compiles to nothing, so you don't have to
     #ifdef around it.  Example:

          int main(void)
          {
             allegro_init();
             /* more stuff goes here */
             ...
             return 0;
          }
          END_OF_MAIN()

See also:
*Note Windows specifics: Windows.
*Note Unix specifics: Unix.
*Note MacOS X specifics: MacOS.
*Note Differences between platforms: Differences.
*Note Available Allegro examples: Available.


File: allegro.info,  Node: allegro_id,  Next: allegro_error,  Prev: END_OF_MAIN,  Up: Using

1.1.5 allegro_id
----------------

extern char allegro_id[];
     Text string containing a date and version number for the library,
     in case you want to display these somewhere.


File: allegro.info,  Node: allegro_error,  Next: ALLEGRO_VERSION,  Prev: allegro_id,  Up: Using

1.1.6 allegro_error
-------------------

extern char allegro_error[ALLEGRO_ERROR_SIZE];
     Text string used by set_gfx_mode(), install_sound() and other
     functions to report error messages.  If they fail and you want to
     tell the user why, this is the place to look for a description of
     the problem.  Example:

          void abort_on_error(const char *message)
          {
             if (screen != NULL)
                set_gfx_mode(GFX_TEXT, 0, 0, 0, 0);

             allegro_message("%s.\nLast Allegro error `%s'\n",
                             message, allegro_error);
             exit(-1);
          }
          ...
             if (some_allegro_function() == ERROR_CODE)
                abort_on_error("Error calling some function!");

See also:
*Note set_gfx_mode::.
*Note install_sound::.
*Note Available Allegro examples: Available.


File: allegro.info,  Node: ALLEGRO_VERSION,  Next: ALLEGRO_SUB_VERSION,  Prev: allegro_error,  Up: Using

1.1.7 ALLEGRO_VERSION
---------------------

#define ALLEGRO_VERSION
     Defined to the major version of Allegro.  From a version number
     like 4.1.16, this would be defined to the integer 4.


File: allegro.info,  Node: ALLEGRO_SUB_VERSION,  Next: ALLEGRO_WIP_VERSION,  Prev: ALLEGRO_VERSION,  Up: Using

1.1.8 ALLEGRO_SUB_VERSION
-------------------------

#define ALLEGRO_SUB_VERSION
     Defined to the middle version of Allegro.  From a version number
     like 4.1.16, this would be defined to the integer 1.


File: allegro.info,  Node: ALLEGRO_WIP_VERSION,  Next: ALLEGRO_VERSION_STR,  Prev: ALLEGRO_SUB_VERSION,  Up: Using

1.1.9 ALLEGRO_WIP_VERSION
-------------------------

#define ALLEGRO_WIP_VERSION
     Defined to the minor version of Allegro.  From a version number
     like 4.1.16, this would be defined to the integer 16.


File: allegro.info,  Node: ALLEGRO_VERSION_STR,  Next: ALLEGRO_DATE_STR,  Prev: ALLEGRO_WIP_VERSION,  Up: Using

1.1.10 ALLEGRO_VERSION_STR
--------------------------

#define ALLEGRO_VERSION_STR
     Defined to a text string containing all version numbers and maybe
     some additional text.  This could be '4.2.1 (SVN)' for an Allegro
     version obtained straight from the SVN repository.


File: allegro.info,  Node: ALLEGRO_DATE_STR,  Next: ALLEGRO_DATE,  Prev: ALLEGRO_VERSION_STR,  Up: Using

1.1.11 ALLEGRO_DATE_STR
-----------------------

#define ALLEGRO_DATE_STR
     Defined to a text string containing the year this version of
     Allegro was released, like '2004'.


File: allegro.info,  Node: ALLEGRO_DATE,  Next: AL_ID,  Prev: ALLEGRO_DATE_STR,  Up: Using

1.1.12 ALLEGRO_DATE
-------------------

#define ALLEGRO_DATE
     Defined to an integer containing the release date of Allegro in the
     packed format 'yyyymmdd'.  Example:

          const int year = ALLEGRO_DATE / 10000;
          const int month = (ALLEGRO_DATE / 100) % 100;
          const int day = ALLEGRO_DATE % 100;

          allegro_message("Year %d, month %d, day %d\n",
             year, month, day);


File: allegro.info,  Node: AL_ID,  Next: MAKE_VERSION,  Prev: ALLEGRO_DATE,  Up: Using

1.1.13 AL_ID
------------

Macro AL_ID(a,b,c,d)
     This macro can be used to create a packed 32 bit integer from 8 bit
     characters, on both 32 and 64 bit machines.  These can be used for
     various things, like custom datafile objects or system IDs.
     Example:

          #define OSTYPE_LINUX       AL_ID('T','U','X',' ')

See also:
*Note DAT_ID::.


File: allegro.info,  Node: MAKE_VERSION,  Next: os_type,  Prev: AL_ID,  Up: Using

1.1.14 MAKE_VERSION
-------------------

Macro MAKE_VERSION(a, b, c)
     This macro can be used to check if some Allegro version is (binary)
     compatible with the current version.  It is safe to use > and < to
     check if one version is more recent than another.  The third number
     is ignored if the second number is even, so MAKE_VERSION(4, 2, 0)
     is equivalent to MAKE_VERSION(4, 2, 1).  This is because of our
     version numbering policy since 4.0.0: the second number is even for
     stable releases, which must be ABI-compatible with earlier versions
     of the same series.  This macro is mainly useful for addon packages
     and libraries.  See the 'ABI compatibility information' section of
     the manual for more detailed information.  Example:

          /* Check if the current version is compatible with Allegro 4.2.0 */
          #if (MAKE_VERSION(4, 2, 0) <= MAKE_VERSION(ALLEGRO_VERSION, \
                             ALLEGRO_SUB_VERSION, ALLEGRO_WIP_VERSION))
             /* Allegro 4.2.0 compatibility */
          #else
             /* Work-around */
          #endif

See also:
*Note ALLEGRO_VERSION::.
*Note ALLEGRO_SUB_VERSION::.
*Note ALLEGRO_WIP_VERSION::.


File: allegro.info,  Node: os_type,  Next: os_version,  Prev: MAKE_VERSION,  Up: Using

1.1.15 os_type
--------------

extern int os_type;
     Set by allegro_init() to one of the values:

          OSTYPE_UNKNOWN    - unknown, or regular MSDOS
          OSTYPE_WIN3       - Windows 3.1 or earlier
          OSTYPE_WIN95      - Windows 95
          OSTYPE_WIN98      - Windows 98
          OSTYPE_WINME      - Windows ME
          OSTYPE_WINNT      - Windows NT
          OSTYPE_WIN2000    - Windows 2000
          OSTYPE_WINXP      - Windows XP
          OSTYPE_WIN2003    - Windows 2003
          OSTYPE_WINVISTA   - Windows Vista
          OSTYPE_OS2        - OS/2
          OSTYPE_WARP       - OS/2 Warp 3
          OSTYPE_DOSEMU     - Linux DOSEMU
          OSTYPE_OPENDOS    - Caldera OpenDOS
          OSTYPE_LINUX      - Linux
          OSTYPE_SUNOS      - SunOS/Solaris
          OSTYPE_FREEBSD    - FreeBSD
          OSTYPE_NETBSD     - NetBSD
          OSTYPE_IRIX       - IRIX
          OSTYPE_DARWIN     - Darwin
          OSTYPE_QNX        - QNX
          OSTYPE_UNIX       - Unknown Unix variant
          OSTYPE_BEOS       - BeOS
          OSTYPE_MACOS      - MacOS
          OSTYPE_MACOSX     - MacOS X

See also:
*Note allegro_init::.
*Note os_version::.
*Note os_multitasking::.


File: allegro.info,  Node: os_version,  Next: os_multitasking,  Prev: os_type,  Up: Using

1.1.16 os_version
-----------------

extern int os_version;
extern int os_revision;
     The major and minor version of the Operating System currently
     running.  Set by allegro_init().  If Allegro for some reason was
     not able to retrieve the version of the Operating System,
     os_version and os_revision will be set to -1.  For example: Under
     Win98 SE (v4.10.2222) os_version will be set to 4 and os_revision
     to 10.

See also:
*Note os_type::.
*Note os_multitasking::.


File: allegro.info,  Node: os_multitasking,  Next: allegro_message,  Prev: os_version,  Up: Using

1.1.17 os_multitasking
----------------------

extern int os_multitasking;
     Set by allegro_init() to either TRUE or FALSE depending on whether
     your Operating System is multitasking or not.

See also:
*Note os_type::.
*Note os_version::.


File: allegro.info,  Node: allegro_message,  Next: set_window_title,  Prev: os_multitasking,  Up: Using

1.1.18 allegro_message
----------------------

void allegro_message(const char *text_format, ...);
     Outputs a message, using a printf() format string.  Usually you
     want to use this to report messages to the user in an OS
     independent way when some Allegro subsystem cannot be initialised.
     But you must not use this function if you are in a graphic mode,
     only before calling set_gfx_mode(), or after a
     set_gfx_mode(GFX_TEXT). Also, this function depends on a system
     driver being installed, which means that it won't display the
     message at all on some platforms if Allegro has not been
     initialised correctly.

     On platforms featuring a windowing system, it will bring up a
     blocking GUI message box.  If there is no windowing system, it will
     try to print the string to a text console, attempting to work
     around codepage differences by reducing any accented characters to
     7-bit ASCII approximations.  Example:

          if (allegro_init() != 0)
             exit(1);

          if (init_my_data() != 0) {
             allegro_message("Sorry, missing game data!\n");
             exit(2);
          }

See also:
*Note allegro_init::.
*Note install_allegro::.
*Note set_uformat::.
*Note Available Allegro examples: Available.


File: allegro.info,  Node: set_window_title,  Next: set_close_button_callback,  Prev: allegro_message,  Up: Using

1.1.19 set_window_title
-----------------------

void set_window_title(const char *name);
     On platforms that are capable of it, this routine alters the window
     title for your Allegro program.  Note that Allegro cannot set the
     window title when running in a DOS box under Windows.  Example:

          set_window_title("Allegro rules!");

See also:
*Note set_close_button_callback::.
*Note set_uformat::.
*Note exunicod::.


File: allegro.info,  Node: set_close_button_callback,  Next: desktop_color_depth,  Prev: set_window_title,  Up: Using

1.1.20 set_close_button_callback
--------------------------------

int set_close_button_callback(void (*proc)(void));
     On platforms that have a close button, this routine installs a
     callback function to handle the close event.  In other words, when
     the user clicks the close button on your program's window or any
     equivalent device, the function you specify here will be called.

     This function should not generally attempt to exit the program or
     save any data itself.  The function could be called at any time,
     and there is usually a risk of conflict with the main thread of the
     program.  Instead, you should set a flag during this function, and
     test it on a regular basis in the main loop of the program.

     Pass NULL as the 'proc' argument to this function to disable the
     close button functionality, which is the default state.

     Note that Allegro cannot intercept the close button of a DOS box in
     Windows.

     Also note that the supplied callback is also called under MacOS X
     when the user hits Command-Q or selects "Quit" from the application
     menu.  Example:

          volatile int close_button_pressed = FALSE;

          void close_button_handler(void)
          {
             close_button_pressed = TRUE;
          }
          END_OF_FUNCTION(close_button_handler)
          ...

          allegro_init();
          LOCK_FUNCTION(close_button_handler);
          set_close_button_callback(close_button_handler);
          ...

          while (!close_button_pressed)
             do_stuff();

     Returns zero on success and non-zero on failure (e.g.  the feature
     is not supported by the platform).

See also:
*Note set_window_title::.


File: allegro.info,  Node: desktop_color_depth,  Next: get_desktop_resolution,  Prev: set_close_button_callback,  Up: Using

1.1.21 desktop_color_depth
--------------------------

int desktop_color_depth();
     Finds out the currently selected desktop color depth.  You can use
     this information to make your program use the same color depth as
     the desktop, which will likely make it run faster because the
     graphic driver won't be doing unnecessary color conversions behind
     your back.

     Under some OSes, switching to a full screen graphics mode may
     automatically change the desktop color depth.  You have, therefore,
     to call this function before setting any graphics mode in order to
     retrieve the real desktop color depth.  Example:

          allegro_init();
          ...
          if ((depth = desktop_color_depth()) != 0) {
             set_color_depth(depth);
          }

     Returns the color depth or zero on platforms where this information
     is not available or does not apply.

See also:
*Note get_desktop_resolution::.
*Note set_color_depth::.
*Note set_gfx_mode::.


File: allegro.info,  Node: get_desktop_resolution,  Next: check_cpu,  Prev: desktop_color_depth,  Up: Using

1.1.22 get_desktop_resolution
-----------------------------

int get_desktop_resolution(int *width, int *height);
     Finds out the currently selected desktop resolution.  You can use
     this information to avoid creating windows bigger than the current
     resolution.  This is especially important for some windowed drivers
     which are unable to create windows bigger than the desktop.  Each
     parameter is a pointer to an integer where one dimension of the
     screen will be stored.

     Under some OSes, switching to a full screen graphics mode may
     automatically change the desktop resolution.  You have, therefore,
     to call this function before setting any graphics mode in order to
     retrieve the real desktop resolution.  Example:

          int width, height;

          allegro_init();
          ...
          if (get_desktop_resolution(&width, &height) == 0) {
             /* Got the resolution correctly */
          }

     Returns zero on success, or a negative number if this information
     is not available or does not apply, in which case the values stored
     in the variables you provided for 'width' and 'height' are
     undefined.

See also:
*Note desktop_color_depth::.
*Note set_gfx_mode::.


File: allegro.info,  Node: check_cpu,  Next: cpu_vendor,  Prev: get_desktop_resolution,  Up: Using

1.1.23 check_cpu
----------------

void check_cpu();
     Detects the CPU type, setting the following global variables.  You
     don't normally need to call this, because allegro_init() will do it
     for you.

See also:
*Note cpu_vendor::.
*Note cpu_family::.
*Note cpu_model::.
*Note cpu_capabilities::.
*Note allegro_init::.


File: allegro.info,  Node: cpu_vendor,  Next: cpu_family,  Prev: check_cpu,  Up: Using

1.1.24 cpu_vendor
-----------------

extern char cpu_vendor[];
     On Intel PCs, contains the CPU vendor name if known.  On Mac OSX
     systems this contains the PPC subtype name.  On other platforms,
     this may be an empty string.  You can read this variable after you
     have called check_cpu() (which is automatically called by
     allegro_init()).

See also:
*Note check_cpu::.
*Note cpu_family::.
*Note cpu_model::.
*Note cpu_capabilities::.
*Note allegro_init::.


File: allegro.info,  Node: cpu_family,  Next: cpu_model,  Prev: cpu_vendor,  Up: Using

1.1.25 cpu_family
-----------------

extern int cpu_family;
     Contains the Intel type, where applicable.  Allegro defines the
     following CPU family types:

          CPU_FAMILY_UNKNOWN  - The type of processor is unknown
          CPU_FAMILY_I386     - The processor is an Intel-compatible 386
          CPU_FAMILY_I486     - The processor is an Intel-compatible 486
          CPU_FAMILY_I586     - The processor is a Pentium or equivalent
          CPU_FAMILY_I686     - The processor is a Pentium Pro, II, III
                                or equivalent
          CPU_FAMILY_ITANIUM  - The processor is an Itanium processor
          CPU_FAMILY_POWERPC  - The processor is a PowerPC processor
          CPU_FAMILY_EXTENDED - The processor type needs to be read
                                from the cpu_model

     You can read this variable after you have called check_cpu() (which
     is automatically called by allegro_init()).

See also:
*Note check_cpu::.
*Note cpu_vendor::.
*Note cpu_model::.
*Note cpu_capabilities::.
*Note allegro_init::.


File: allegro.info,  Node: cpu_model,  Next: cpu_capabilities,  Prev: cpu_family,  Up: Using

1.1.26 cpu_model
----------------

extern int cpu_model;
     Contains the CPU submodel, where applicable.  Allegro defines at
     least the following CPU family types (see include/allegro/system.h
     for a more complete list):

          CPU_FAMILY_I586:
             CPU_MODEL_PENTIUM, CPU_MODEL_K5, CPU_MODEL_K6

          CPU_FAMILY_I686:
             CPU_MODEL_PENTIUMPRO, CPU_MODEL_PENTIUMII,
             CPU_MODEL_PENTIUMIIIKATMAI, CPU_MODEL_PENTIUMIIICOPPERMINE,
             CPU_MODEL_ATHLON, CPU_MODEL_DURON

          CPU_FAMILY_EXTENDED:
             CPU_MODEL_PENTIUMIV, CPU_MODEL_XEON,
             CPU_MODEL_ATHLON64, CPU_MODEL_OPTERON

          CPU_FAMILY_POWERPC:
             CPU_MODEL_POWERPC_x, for x=601-604, 620, 750, 7400, 7450

     You can read this variable after you have called check_cpu() (which
     is automatically called by allegro_init()).  Make sure you check
     the cpu_family and cpu_vendor so you know which models make sense
     to check.

See also:
*Note check_cpu::.
*Note cpu_vendor::.
*Note cpu_family::.
*Note cpu_capabilities::.
*Note allegro_init::.


File: allegro.info,  Node: cpu_capabilities,  Next: fixed,  Prev: cpu_model,  Up: Using

1.1.27 cpu_capabilities
-----------------------

extern int cpu_capabilities;
     Contains CPU flags indicating what features are available on the
     current CPU. The flags can be any combination of these:

          CPU_ID       - Indicates that the "cpuid" instruction is
                         available. If this is set, then all Allegro CPU
                         variables are 100% reliable, otherwise there
                         may be some mistakes.
          CPU_FPU      - An FPU is available.
          CPU_IA64     - Running on Intel 64 bit CPU
          CPU_AMD64    - Running on AMD 64 bit CPU
          CPU_MMX      - Intel MMX  instruction set is available.
          CPU_MMXPLUS  - Intel MMX+ instruction set is available.
          CPU_SSE      - Intel SSE  instruction set is available.
          CPU_SSE2     - Intel SSE2 instruction set is available.
          CPU_SSE3     - Intel SSE3 instruction set is available.
          CPU_3DNOW    - AMD 3DNow! instruction set is available.
          CPU_ENH3DNOW - AMD Enhanced 3DNow! instruction set is
                         available.
          CPU_CMOV     - Pentium Pro "cmov" instruction is available.

     You can check for multiple features by OR-ing the flags together.
     For example, to check if the CPU has an FPU and MMX instructions
     available, you'd do:

          if ((cpu_capabilities & (CPU_FPU | CPU_MMX)) ==
              (CPU_FPU | CPU_MMX)) {
             printf("CPU has both an FPU and MMX instructions!\n");
          }

     You can read this variable after you have called check_cpu() (which
     is automatically called by allegro_init()).

See also:
*Note check_cpu::.
*Note cpu_vendor::.
*Note cpu_family::.
*Note cpu_model::.
*Note cpu_capabilities::.
*Note allegro_init::.


File: allegro.info,  Node: Structures,  Next: Unicode,  Prev: Using,  Up: API

1.2 Structures and types defined by Allegro
===========================================

There are several structures and types defined by Allegro which are used
in many functions (like the BITMAP structure).  This section of the
manual describes their useful content from a user point of view when
they don't fit very well any of the existing manual sections, and
redirects you to the appropriate section when it's already described
there.  Note that unless stated otherwise, the contents shown here are
just for read only purposes, there might be other internal flags, but
you shouldn't depend on them being available in past/future versions of
Allegro.

* Menu:

* fixed::
* BITMAP::
* RLE_SPRITE::
* COMPILED_SPRITE::
* JOYSTICK_INFO::
* JOYSTICK_BUTTON_INFO::
* JOYSTICK_STICK_INFO::
* JOYSTICK_AXIS_INFO::
* GFX_MODE_LIST::
* GFX_MODE::
* PAL_SIZE::
* PALETTE::
* RGB::
* V3D::
* V3D_f::
* COLOR_MAP::
* RGB_MAP::
* al_ffblk::
* DATAFILE::
* MATRIX::
* MATRIX_f::
* QUAT::
* DIALOG::
* MENU::
* DIALOG_PLAYER::
* MENU_PLAYER::
* FONT::
* ZBUFFER::
* SAMPLE::
* MIDI::
* AUDIOSTREAM::
* PACKFILE::
* PACKFILE_VTABLE::
* LZSS_PACK_DATA::
* LZSS_UNPACK_DATA::


File: allegro.info,  Node: fixed,  Next: BITMAP,  Prev: cpu_capabilities,  Up: Structures

1.2.1 fixed
-----------

typedef long fixed
     This is a fixed point integer which can replace float with similar
     results and is faster than float on low end machines.  Read chapter
     "Fixed point math routines" for the full explanation.

See also:
*Note Fixed point math routines: Fixed.
*Note ex12bit::.
*Note ex3buf::.
*Note ex3d::.
*Note excustom::.
*Note exfixed::.
*Note exrotscl::.
*Note exspline::.
*Note exsprite::.
*Note exstars::.
*Note exupdate::.


File: allegro.info,  Node: BITMAP,  Next: RLE_SPRITE,  Prev: fixed,  Up: Structures

1.2.2 BITMAP
------------

typedef struct BITMAP

          int w, h;               - size of the bitmap in pixels
          int clip;               - non-zero if clipping is turned on
          int cl, cr, ct, cb;     - clip rectangle left, right, top,
                                    and bottom
          unsigned char *line[];  - pointers to the start of each line

     There is some other stuff in the structure as well, but it is
     liable to change and you shouldn't use anything except the above.
     The 'w' and 'h' fields can be used to obtain the size of an
     existing bitmap:

          bmp = load_bitmap("file.bmp", pal);
          allegro_message("Bitmap size: (%dx%d)\n", bmp->w, bmp->h);

     The clipping rectangle is inclusive on the left and top (0 allows
     drawing to position 0) but exclusive on the right and bottom (10
     allows drawing to position 9, but not to 10).  Note this is not the
     same format as that of the clipping API, which takes inclusive
     coordinates for all four corners.  All the values of this structure
     should be regarded as read-only, with the exception of the line
     field, whose access is described in depth in the "Direct access to
     video memory" section of the manual.  If you want to modify the
     clipping region, please refrain from changing this structure.  Use
     set_clip_rect() instead.

See also:
*Note create_bitmap::.
*Note set_clip_rect::.
*Note bitmap_color_depth::.
*Note RLE_SPRITE::.
*Note COMPILED_SPRITE::.
*Note Direct access to video memory: Direct.
*Note Available Allegro examples: Available.


File: allegro.info,  Node: RLE_SPRITE,  Next: COMPILED_SPRITE,  Prev: BITMAP,  Up: Structures

1.2.3 RLE_SPRITE
----------------

typedef struct RLE_SPRITE

          int w, h;           - width and height in pixels
          int color_depth;    - color depth of the image

     RLE sprites store the image in a simple run-length encoded format,
     where repeated zero pixels are replaced by a single length count,
     and strings of non-zero pixels are preceded by a counter giving the
     length of the solid run.  Read chapter "RLE sprites" for a
     description of the restrictions and how to obtain/use this
     structure.

See also:
*Note get_rle_sprite::.
*Note BITMAP::.
*Note COMPILED_SPRITE::.
*Note RLE sprites: RLE.


File: allegro.info,  Node: COMPILED_SPRITE,  Next: JOYSTICK_INFO,  Prev: RLE_SPRITE,  Up: Structures

1.2.4 COMPILED_SPRITE
---------------------

typedef struct COMPILED_SPRITE

          short planar;        - set if it's a planar (mode-X) sprite
          short color_depth;   - color depth of the image
          short w, h;          - size of the sprite

     Compiled sprites are stored as actual machine code instructions
     that draw a specific image onto a bitmap, using mov instructions
     with immediate data values.  Read chapter "Compiled sprites" for a
     description of the restrictions and how to obtain/use this
     structure.

See also:
*Note get_compiled_sprite::.
*Note BITMAP::.
*Note RLE_SPRITE::.
*Note Compiled sprites: Compiled.


File: allegro.info,  Node: JOYSTICK_INFO,  Next: JOYSTICK_BUTTON_INFO,  Prev: COMPILED_SPRITE,  Up: Structures

1.2.5 JOYSTICK_INFO
-------------------

typedef struct JOYSTICK_INFO

          int flags;                       - status flags for this
                                             joystick
          int num_sticks;                  - how many stick inputs?
          int num_buttons;                 - how many buttons?
          JOYSTICK_STICK_INFO stick[n];    - stick state information
          JOYSTICK_BUTTON_INFO button[n];  - button state information

     Read chapter "Joystick routines" for a description on how to
     obtain/use this structure.

See also:
*Note joy::.
*Note Joystick routines: Joystick.


File: allegro.info,  Node: JOYSTICK_BUTTON_INFO,  Next: JOYSTICK_STICK_INFO,  Prev: JOYSTICK_INFO,  Up: Structures

1.2.6 JOYSTICK_BUTTON_INFO
--------------------------

typedef struct JOYSTICK_BUTTON_INFO

          int b;                           - boolean on/off flag
          char *name;                      - description of this
                                             button

     Read chapter "Joystick routines" for a description on how to
     obtain/use this structure.

See also:
*Note joy::.
*Note Joystick routines: Joystick.


File: allegro.info,  Node: JOYSTICK_STICK_INFO,  Next: JOYSTICK_AXIS_INFO,  Prev: JOYSTICK_BUTTON_INFO,  Up: Structures

1.2.7 JOYSTICK_STICK_INFO
-------------------------

typedef struct JOYSTICK_STICK_INFO

          int flags;                       - status flags for this
                                             input
          int num_axis;                    - how many axes do we
                                             have? (note the misspelling)
          JOYSTICK_AXIS_INFO axis[n];      - axis state information
          char *name;                      - description of this
                                             input

     Read chapter "Joystick routines" for a description on how to
     obtain/use this structure.

See also:
*Note joy::.
*Note Joystick routines: Joystick.


File: allegro.info,  Node: JOYSTICK_AXIS_INFO,  Next: GFX_MODE_LIST,  Prev: JOYSTICK_STICK_INFO,  Up: Structures

1.2.8 JOYSTICK_AXIS_INFO
------------------------

typedef struct JOYSTICK_AXIS_INFO

          int pos;                         - analogue axis position
          int d1, d2;                      - digital axis position
          char *name;                      - description of this axis

     Read chapter "Joystick routines" for a description on how to
     obtain/use this structure.

See also:
*Note joy::.
*Note Joystick routines: Joystick.


File: allegro.info,  Node: GFX_MODE_LIST,  Next: GFX_MODE,  Prev: JOYSTICK_AXIS_INFO,  Up: Structures

1.2.9 GFX_MODE_LIST
-------------------

typedef struct GFX_MODE_LIST

          int num_modes;
          GFX_MODE *mode;

     Structure returned by get_gfx_mode_list, which contains an array of
     GFX_MODE structures.

See also:
*Note GFX_MODE::.
*Note get_gfx_mode_list::.


File: allegro.info,  Node: GFX_MODE,  Next: PAL_SIZE,  Prev: GFX_MODE_LIST,  Up: Structures

1.2.10 GFX_MODE
---------------

typedef struct GFX_MODE

          int width, height, bpp;

     Structure contained in GFX_MODE_LIST.

See also:
*Note GFX_MODE_LIST::.
*Note get_gfx_mode_list::.


File: allegro.info,  Node: PAL_SIZE,  Next: PALETTE,  Prev: GFX_MODE,  Up: Structures

1.2.11 PAL_SIZE
---------------

#define PAL_SIZE
     Preprocessor constant equal to 256.

See also:
*Note RGB::.
*Note PALETTE::.
*Note COLOR_MAP::.


File: allegro.info,  Node: PALETTE,  Next: RGB,  Prev: PAL_SIZE,  Up: Structures

1.2.12 PALETTE
--------------

typedef PALETTE RGB[PAL_SIZE]
     Allegro palettes are arrays of PAL_SIZE RGB entries.

See also:
*Note RGB::.
*Note Palette routines: Palette.
*Note Available Allegro examples: Available.


File: allegro.info,  Node: RGB,  Next: V3D,  Prev: PALETTE,  Up: Structures

1.2.13 RGB
----------

typedef struct RGB

          unsigned char r, g, b;

     Palette entry.  It contains an additional field for the purpose of
     padding but you should not usually care about it.  Read chapter
     "Palette routines" for a description on how to obtain/use this
     structure.

See also:
*Note Palette routines: Palette.
*Note PALETTE::.
*Note ex12bit::.
*Note ex3d::.
*Note excolmap::.
*Note exconfig::.
*Note expal::.
*Note exrgbhsv::.
*Note exscroll::.
*Note exshade::.
*Note extrans::.
*Note extruec::.


File: allegro.info,  Node: V3D,  Next: V3D_f,  Prev: RGB,  Up: Structures

1.2.14 V3D
----------

typedef struct V3D

          fixed x, y, z;       - position
          fixed u, v;          - texture map coordinates
          int c;               - color

     A vertex structure used by polygon3d and other polygon rendering
     functions.  Read the description of polygon3d() for a description
     on how to obtain/use this structure.

See also:
*Note V3D_f::.
*Note polygon3d::.
*Note Fixed point trig::.
*Note ex3d::.


File: allegro.info,  Node: V3D_f,  Next: COLOR_MAP,  Prev: V3D,  Up: Structures

1.2.15 V3D_f
------------

typedef struct V3D_f

          float x, y, z;       - position
          float u, v;          - texture map coordinates
          int c;               - color

     Like V3D but using float values instead of fixed ones.  Read the
     description of polygon3d_f() for a description on how to obtain/use
     this structure.

See also:
*Note V3D::.
*Note polygon3d_f: polygon3d.
*Note Fixed point trig::.
*Note excamera::.
*Note exscn3d::.
*Note exzbuf::.


File: allegro.info,  Node: COLOR_MAP,  Next: RGB_MAP,  Prev: V3D_f,  Up: Structures

1.2.16 COLOR_MAP
----------------

typedef struct COLOR_MAP

          unsigned char data[PAL_SIZE][PAL_SIZE];

     Read chapter "Transparency and patterned drawing", section
     "256-color transparency" for a description on how to obtain/use
     this structure.

See also:
*Note 256-color transparency::.
*Note color_map::.
*Note ex3d::.
*Note excolmap::.
*Note exlights::.
*Note exshade::.
*Note extrans::.


File: allegro.info,  Node: RGB_MAP,  Next: al_ffblk,  Prev: COLOR_MAP,  Up: Structures

1.2.17 RGB_MAP
--------------

typedef struct RGB_MAP

          unsigned char data[32][32][32];

     Read chapter "Converting between color formats" for a description
     on how to obtain/use this structure.

See also:
*Note Converting between color formats: Converting.
*Note create_rgb_table::.
*Note ex3d::.
*Note excolmap::.
*Note exrgbhsv::.
*Note exshade::.
*Note extrans::.


File: allegro.info,  Node: al_ffblk,  Next: DATAFILE,  Prev: RGB_MAP,  Up: Structures

1.2.18 al_ffblk
---------------

struct al_ffblk

          int attrib;       - actual attributes of the file found
          time_t time;      - modification time of file
          char name[512];   - name of file

     Read the description of al_findfirst for a description on how to
     obtain/use this structure.

See also:
*Note al_findfirst::.
*Note al_ffblk_get_size::.


File: allegro.info,  Node: DATAFILE,  Next: MATRIX,  Prev: al_ffblk,  Up: Structures

1.2.19 DATAFILE
---------------

typedef struct DATAFILE

          void *dat;     - pointer to the actual data
          int type;      - type of the data
          long size;     - size of the data in bytes
          void *prop;    - list of object properties

     Read chapter "Datafile routines", section "Using datafiles" for a
     description on how to obtain/use this structure.

See also:
*Note load_datafile::.
*Note Using datafiles::.
*Note excustom::.
*Note exdata::.
*Note exexedat::.
*Note exgui::.
*Note exsprite::.
*Note exunicod::.


File: allegro.info,  Node: MATRIX,  Next: MATRIX_f,  Prev: DATAFILE,  Up: Structures

1.2.20 MATRIX
-------------

typedef struct MATRIX

          fixed v[3][3];           - 3x3 scaling and rotation component
          fixed t[3];              - x/y/z translation component

     Fixed point matrix structure.  Read chapter "3D math routines" for
     a description on how to obtain/use this structure.

See also:
*Note MATRIX_f::.
*Note 3D math routines: 3D.
*Note ex12bit::.
*Note ex3d::.
*Note exstars::.


File: allegro.info,  Node: MATRIX_f,  Next: QUAT,  Prev: MATRIX,  Up: Structures

1.2.21 MATRIX_f
---------------

typedef struct MATRIX_f

          float v[3][3];           - 3x3 scaling and rotation component
          float t[3];              - x/y/z translation component

     Floating point matrix structure.  Read chapter "3D math routines"
     for a description on how to obtain/use this structure.

See also:
*Note MATRIX::.
*Note 3D math routines: 3D.
*Note excamera::.
*Note exquat::.
*Note exscn3d::.
*Note exzbuf::.


File: allegro.info,  Node: QUAT,  Next: DIALOG,  Prev: MATRIX_f,  Up: Structures

1.2.22 QUAT
-----------

typedef struct QUAT

          float w, x, y, z;

     Read chapter "Quaternion math routines" for a description on how to
     obtain/use this structure.

See also:
*Note Quaternion math routines: Quaternion.
*Note exquat::.


File: allegro.info,  Node: DIALOG,  Next: MENU,  Prev: QUAT,  Up: Structures

1.2.23 DIALOG
-------------

typedef struct DIALOG

          int (*proc)(int, DIALOG *, int); - dialog procedure
                                             (message handler)
          int x, y, w, h;       - position and size of the object
          int fg, bg;           - foreground and background colors
          int key;              - ASCII keyboard shortcut
          int flags;            - flags about the status of the object
          int d1, d2;           - whatever you want to use them for
          void *dp, *dp2, *dp3; - pointers to more object-specific data

     This is the structure which contains a GUI object.  Read chapter
     "GUI routines" for a description on how to obtain/use this
     structure.

See also:
*Note do_dialog::.
*Note GUI routines: GUI.
*Note excustom::.
*Note exgui::.
*Note exrgbhsv::.


File: allegro.info,  Node: MENU,  Next: DIALOG_PLAYER,  Prev: DIALOG,  Up: Structures

1.2.24 MENU
-----------

typedef struct MENU

          char *text;          - the text to display for the menu item
          int (*proc)(void);   - called when the menu item is clicked
          struct MENU *child;  - nested child menu
          int flags;           - disabled or checked state
          void *dp;            - pointer to any data you need

     Structure used to hold an entry of a menu.  Read chapter "GUI
     routines", section "GUI menus" for a description on how to
     obtain/use this structure.

See also:
*Note do_menu::.
*Note GUI menus::.
*Note exgui::.


File: allegro.info,  Node: DIALOG_PLAYER,  Next: MENU_PLAYER,  Prev: MENU,  Up: Structures

1.2.25 DIALOG_PLAYER
--------------------

typedef struct DIALOG_PLAYER
     A structure which holds GUI data used internally by Allegro.  Read
     the documentation of init_dialog() for a description on how to
     obtain/use this structure.

See also:
*Note init_dialog::.
*Note update_dialog::.
*Note shutdown_dialog::.
*Note GUI routines: GUI.


File: allegro.info,  Node: MENU_PLAYER,  Next: FONT,  Prev: DIALOG_PLAYER,  Up: Structures

1.2.26 MENU_PLAYER
------------------

typedef struct MENU_PLAYER
     A structure which holds GUI data used internally by Allegro.  Read
     the documentation of init_menu() for a description on how to
     obtain/use this structure.

See also:
*Note init_menu::.
*Note update_menu::.
*Note shutdown_menu::.
*Note GUI menus::.


File: allegro.info,  Node: FONT,  Next: ZBUFFER,  Prev: MENU_PLAYER,  Up: Structures

1.2.27 FONT
-----------

typedef struct FONT
     A structure holding an Allegro font, usually created beforehand
     with the grabber tool or Allegro's default font.  Read chapter
     "Fonts" for a description on how to load/destroy fonts, and chapter
     "Text output" for a description on how to show text.

See also:
*Note font::.
*Note excustom::.
*Note exfont::.
*Note exunicod::.


File: allegro.info,  Node: ZBUFFER,  Next: SAMPLE,  Prev: FONT,  Up: Structures

1.2.28 ZBUFFER
--------------

typedef struct BITMAP ZBUFFER
     Structure used by Allegro's 3d zbuffered rendering functions.  You
     are not supposed to mix ZBUFFER with BITMAP even though it is
     currently possible to do so.  This is just an internal
     representation, and it may change in the future.

See also:
*Note Zbuffered rendering::.
*Note BITMAP::.
*Note exzbuf::.
*Note BITMAP::.


File: allegro.info,  Node: SAMPLE,  Next: MIDI,  Prev: ZBUFFER,  Up: Structures

1.2.29 SAMPLE
-------------

typedef struct SAMPLE

          int bits;                   - 8 or 16
          int stereo;                 - sample type flag
          int freq;                   - sample frequency
          int priority;               - 0-255
          unsigned long len;          - length (in samples)
          unsigned long loop_start;   - loop start position
          unsigned long loop_end;     - loop finish position
          void *data;                 - raw sample data

     A sample structure, which holds sound data, used by the digital
     sample routines.  You can consider all of these fields as read only
     except priority, loop_start and loop_end, which you can change them
     for example after loading a sample from disk.

     The priority is a value from 0 to 255 (by default set to 128) and
     controls how hardware voices on the sound card are allocated if you
     attempt to play more than the driver can handle.  This may be used
     to ensure that the less important sounds are cut off while the
     important ones are preserved.

     The variables loop_start and loop_end specify the loop position in
     sample units, and are set by default to the start and end of the
     sample.

     If you are creating your own samples on the fly, you might also
     want to modify the raw data of the sample pointed by the data
     field.  The sample data are always in unsigned format.  This means
     that if you are loading a PCM encoded sound file with signed 16-bit
     samples, you would have to XOR every two bytes (i.e.  every sample
     value) with 0x8000 to change the signedness.

See also:
*Note load_sample::.
*Note Digital sample routines: Digital.
*Note Voice control::.
*Note exsample::.


File: allegro.info,  Node: MIDI,  Next: AUDIOSTREAM,  Prev: SAMPLE,  Up: Structures

1.2.30 MIDI
-----------

typedef struct MIDI
     A structure holding MIDI data.  Read chapter "Music routines
     (MIDI)" for a description on how to obtain/use this structure.

See also:
*Note load_midi::.
*Note Music routines (MIDI): Music.
*Note exmidi::.


File: allegro.info,  Node: AUDIOSTREAM,  Next: PACKFILE,  Prev: MIDI,  Up: Structures

1.2.31 AUDIOSTREAM
------------------

typedef struct AUDIOSTREAM

          int voice;  - the hardware voice used for the sample

     A structure holding an audiostream, which is a convenience wrapper
     around a SAMPLE structure to double buffer sounds too big to fit
     into memory, or do clever things like generating the sound wave
     real time.

     While you shouldn't modify directly the value of the voice, you can
     use all of the voice functions in chapter "Digital sample routines"
     to modify the properties of the sound, like the frequency.

See also:
*Note play_audio_stream::.
*Note Audio stream routines: Audio.
*Note Voice control::.
*Note exstream::.


File: allegro.info,  Node: PACKFILE,  Next: PACKFILE_VTABLE,  Prev: AUDIOSTREAM,  Up: Structures

1.2.32 PACKFILE
---------------

typedef struct PACKFILE
     A packfile structure, similar to the libc FILE structure.  Read
     chapter "File and compression routines" for a description on how to
     obtain/use this structure.  Note that prior to version 4.1.18, some
     internal fields were accidentally documented - but PACKFILE should
     be treated as an opaque structure, just like the libc FILE type.

See also:
*Note File and compression routines: File.
*Note pack_fopen::.
*Note pack_fopen_chunk::.
*Note pack_fopen_vtable::.
*Note expackf::.


File: allegro.info,  Node: PACKFILE_VTABLE,  Next: LZSS_PACK_DATA,  Prev: PACKFILE,  Up: Structures

1.2.33 PACKFILE_VTABLE
----------------------

typedef struct PACKFILE_VTABLE

          int pf_fclose(void *userdata);
          int pf_getc(void *userdata);
          int pf_ungetc(int c, void *userdata);
          long pf_fread(void *p, long n, void *userdata);
          int pf_putc(int c, void *userdata);
          long pf_fwrite(const void *p, long n, void *userdata);
          int pf_fseek(void *userdata, int offset);
          int pf_feof(void *userdata);
          int pf_ferror(void *userdata);

     This is the vtable which must be provided for custom packfiles,
     which then can read from and write to wherever you like (eg.  files
     in memory).  You should provide all the entries of the vtable, even
     if they are empty stubs doing nothing, to avoid Allegro (or you)
     calling a NULL method at some point.

See also:
*Note File and compression routines: File.
*Note pack_fopen_vtable::.
*Note expackf::.


File: allegro.info,  Node: LZSS_PACK_DATA,  Next: LZSS_UNPACK_DATA,  Prev: PACKFILE_VTABLE,  Up: Structures

1.2.34 LZSS_PACK_DATA
---------------------

typedef struct LZSS_PACK_DATA
     Opaque structure for handling LZSS compression.  Read chapter "File
     and compression routines for a description on how to obtain/use
     this structure.

See also:
*Note File and compression routines: File.
*Note create_lzss_pack_data::.


File: allegro.info,  Node: LZSS_UNPACK_DATA,  Next: set_uformat,  Prev: LZSS_PACK_DATA,  Up: Structures

1.2.35 LZSS_UNPACK_DATA
-----------------------

typedef struct LZSS_UNPACK_DATA
     Opaque structure for handling LZSS decompression.  Read chapter
     "File and compression routines for a description on how to
     obtain/use this structure.

See also:
*Note File and compression routines: File.
*Note create_lzss_unpack_data::.


File: allegro.info,  Node: Unicode,  Next: Configuration,  Prev: Structures,  Up: API

1.3 Unicode routines
====================

Allegro can manipulate and display text using any character values from
0 right up to 2^32-1 (although the current implementation of the grabber
can only create fonts using characters up to 2^16-1).  You can choose
between a number of different text encoding formats, which controls how
strings are stored and how Allegro interprets strings that you pass to
it.  This setting affects all aspects of the system: whenever you see a
function that returns a char * type, or that takes a char * as an
argument, that text will be in whatever format you have told Allegro to
use.

By default, Allegro uses UTF-8 encoded text (U_UTF8).  This is a
variable-width format, where characters can occupy anywhere from one to
four bytes.  The nice thing about it is that characters ranging from
0-127 are encoded directly as themselves, so UTF-8 is upwardly
compatible with 7-bit ASCII ("Hello, World!"  means the same thing
regardless of whether you interpret it as ASCII or UTF-8 data).  Any
character values above 128, such as accented vowels, the UK currency
symbol, and Arabic or Chinese characters, will be encoded as a sequence
of two or more bytes, each in the range 128-255.  This means you will
never get what looks like a 7-bit ASCII character as part of the
encoding of a different character value, which makes it very easy to
manipulate UTF-8 strings.

There are a few editing programs that understand UTF-8 format text
files.  Alternatively, you can write your strings in plain ASCII or
16-bit Unicode formats, and then use the Allegro textconv program to
convert them into UTF-8.

If you prefer to use some other text format, you can set Allegro to work
with normal 8-bit ASCII (U_ASCII), or 16-bit Unicode (U_UNICODE)
instead, or you can provide some handler functions to make it support
whatever other text encoding you like (for example it would be easy to
add support for 32 bit UCS-4 characters, or the Chinese GB-code format).

There is some limited support for alternative 8-bit codepages, via the
U_ASCII_CP mode.  This is very slow, so you shouldn't use it for serious
work, but it can be handy as an easy way to convert text between
different codepages.  By default the U_ASCII_CP mode is set up to reduce
text to a clean 7-bit ASCII format, trying to replace any accented
vowels with their simpler equivalents (this is used by the
allegro_message() function when it needs to print an error report onto a
text mode DOS screen).  If you want to work with other codepages, you
can do this by passing a character mapping table to the set_ucodepage()
function.

Note that you can use the Unicode routines before you call
install_allegro() or allegro_init().  If you want to work in a text mode
other than UTF-8, it is best to set it with set_uformat() just before
you call these.

* Menu:

* set_uformat::
* get_uformat::
* register_uformat::
* set_ucodepage::
* need_uconvert::
* uconvert_size::
* do_uconvert::
* uconvert::
* uconvert_ascii::
* uconvert_toascii::
* empty_string::
* ugetc::
* ugetx::
* usetc::
* uwidth::
* ucwidth::
* uisok::
* uoffset::
* ugetat::
* usetat::
* uinsert::
* uremove::
* ustrsize::
* ustrsizez::
* uwidth_max::
* utolower::
* utoupper::
* uisspace::
* uisdigit::
* ustrdup::
* _ustrdup::
* ustrcpy::
* ustrzcpy::
* ustrcat::
* ustrzcat::
* ustrlen::
* ustrcmp::
* ustrncpy::
* ustrzncpy::
* ustrncat::
* ustrzncat::
* ustrncmp::
* ustricmp::
* ustrnicmp::
* ustrlwr::
* ustrupr::
* ustrchr::
* ustrrchr::
* ustrstr::
* ustrpbrk::
* ustrtok::
* ustrtok_r::
* uatof::
* ustrtol::
* ustrtod::
* ustrerror::
* usprintf::
* uszprintf::
* uvsprintf::
* uvszprintf::


File: allegro.info,  Node: set_uformat,  Next: get_uformat,  Prev: LZSS_UNPACK_DATA,  Up: Unicode

1.3.1 set_uformat
-----------------

void set_uformat(int type);
     Sets the current text encoding format.  This will affect all parts
     of Allegro, wherever you see a function that returns a char *, or
     takes a char * as a parameter.  'type' should be one of these
     values:

          U_ASCII     - fixed size, 8-bit ASCII characters
          U_ASCII_CP  - alternative 8-bit codepage (see set_ucodepage())
          U_UNICODE   - fixed size, 16-bit Unicode characters
          U_UTF8      - variable size, UTF-8 format Unicode characters

     Although you can change the text format on the fly, this is not a
     good idea.  Many strings, for example the names of your hardware
     drivers and any language translations, are loaded when you call
     allegro_init(), so if you change the encoding format after this,
     they will be in the wrong format, and things will not work
     properly.  Generally you should only call set_uformat() once,
     before allegro_init(), and then leave it on the same setting for
     the duration of your program.

See also:
*Note get_uformat::.
*Note register_uformat::.
*Note set_ucodepage::.
*Note set_uformat::.
*Note uconvert::.
*Note ustrsize::.
*Note ugetc::.
*Note ugetx::.
*Note usetc::.
*Note uwidth::.
*Note ucwidth::.
*Note uisok::.
*Note uoffset::.
*Note ugetat::.
*Note usetat::.
*Note uinsert::.
*Note uremove::.
*Note allegro_init::.
*Note exunicod::.


File: allegro.info,  Node: get_uformat,  Next: register_uformat,  Prev: set_uformat,  Up: Unicode

1.3.2 get_uformat
-----------------

int get_uformat(void);
     Finds out what text encoding format is currently selected.  This
     function is probably useful only if you are writing an Allegro
     addon dealing with text strings and you use a different codepath
     for each possible format.  Example:

          switch(get_uformat()) {
             case U_ASCII:
                do_something();
                break;
             case U_UTF8:
                do_something_else();
                break;
             ...
          }

     Returns the currently selected text encoding format.  See the
     documentation of set_uformat() for a list of encoding formats.

See also:
*Note set_uformat::.


File: allegro.info,  Node: register_uformat,  Next: set_ucodepage,  Prev: get_uformat,  Up: Unicode

1.3.3 register_uformat
----------------------

void register_uformat(int type, int (*u_getc)(const char *s), int (*u_getx)(char **s), int (*u_setc)(char *s, int c), int (*u_width)(const char *s), int (*u_cwidth)(int c), int (*u_isok)(int c));
     Installs a set of custom handler functions for a new text encoding
     format.  The 'type' is the ID code for your new format, which
     should be a 4-character string as produced by the AL_ID() macro,
     and which can later be passed to functions like set_uformat() and
     uconvert().  The function parameters are handlers that implement
     the character access for your new type: see below for details of
     these.

See also:
*Note set_uformat::.
*Note uconvert::.
*Note ugetc::.
*Note ugetx::.
*Note usetc::.
*Note uwidth::.
*Note ucwidth::.
*Note uisok::.


File: allegro.info,  Node: set_ucodepage,  Next: need_uconvert,  Prev: register_uformat,  Up: Unicode

1.3.4 set_ucodepage
-------------------

void set_ucodepage(const unsigned short *table, const unsigned short *extras);
     When you select the U_ASCII_CP encoding mode, a set of tables are
     used to convert between 8-bit characters and their Unicode
     equivalents.  You can use this function to specify a custom set of
     mapping tables, which allows you to support different 8-bit
     codepages.

     The 'table' parameter points to an array of 256 shorts, which
     contain the Unicode value for each character in your codepage.  The
     'extras' parameter, if not NULL, points to a list of mapping pairs,
     which will be used when reducing Unicode data to your codepage.
     Each pair consists of a Unicode value, followed by the way it
     should be represented in your codepage.  The list is terminated by
     a zero Unicode value.  This allows you to create a many->one
     mapping, where many different Unicode characters can be represented
     by a single codepage value (eg.  for reducing accented vowels to
     7-bit ASCII).

     Allegro will use the 'table' parameter when it needs to convert an
     ASCII string to an Unicode string.  But when Allegro converts an
     Unicode string to ASCII, it will use both parameters.  First, it
     will loop through the 'table' parameter looking for an index
     position pointing at the Unicode value it is trying to convert (ie.
     the 'table' parameter is also used for reverse matching).  If that
     fails, the 'extras' list is used.  If that fails too, Allegro will
     put the character '^', giving up the conversion.

     Note that Allegro comes with a default 'table' and 'extras'
     parameters set internally.  The default 'table' will convert 8-bit
     characters to '^'.  The default 'extras' list reduces Latin-1 and
     Extended-A characters to 7 bits in a sensible way (eg.  an accented
     vowel will be reduced to the same vowel without the accent).

See also:
*Note set_uformat::.


File: allegro.info,  Node: need_uconvert,  Next: uconvert_size,  Prev: set_ucodepage,  Up: Unicode

1.3.5 need_uconvert
-------------------

int need_uconvert(const char *s, int type, int newtype);
     Given a pointer to a string ('s'), a description of the type of the
     string ('type'), and the type that you would like this string to be
     converted into ('newtype'), this function tells you whether any
     conversion is required.  No conversion will be needed if 'type' and
     'newtype' are the same, or if one type is ASCII, the other is
     UTF-8, and the string contains only character values less than 128.
     As a convenience shortcut, you can pass the value U_CURRENT as
     either of the type parameters, to represent whatever text encoding
     format is currently selected.  Example:

          if (need_uconvert(text, U_UTF8, U_CURRENT)) {
             /* conversion is required */
          }

     Returns non-zero if any conversion is required or zero otherwise.

See also:
*Note set_uformat::.
*Note get_uformat::.
*Note do_uconvert::.
*Note uconvert::.


File: allegro.info,  Node: uconvert_size,  Next: do_uconvert,  Prev: need_uconvert,  Up: Unicode

1.3.6 uconvert_size
-------------------

int uconvert_size(const char *s, int type, int newtype);
     Finds out how many bytes are required to store the specified string
     's' after a conversion from 'type' to 'newtype', including the
     mandatory zero terminator of the string.  You can use U_CURRENT for
     either 'type' or 'newtype' as a shortcut to represent whatever text
     encoding format is currently selected.  Example:

          length = uconvert_size(old_string, U_CURRENT, U_UNICODE);
          new_string = malloc(length);
          ustrcpy(new_string, old_string);

     Returns the number of bytes required to store the string after
     conversion.

See also:
*Note need_uconvert::.
*Note do_uconvert::.


File: allegro.info,  Node: do_uconvert,  Next: uconvert,  Prev: uconvert_size,  Up: Unicode

1.3.7 do_uconvert
-----------------

void do_uconvert(const char *s, int type, char *buf, int newtype, int size);
     Converts the specified string 's' from 'type' to 'newtype', storing
     at most 'size' bytes into the output 'buf'.  The type parameters
     can use the value U_CURRENT as a shortcut to represent the
     currently selected encoding format.  Example:

          char temp_string[256];
          do_uconvert(input_string, U_CURRENT, temp_string, U_ASCII, 256);

     Note that, even for empty strings, your destination string must
     have at least enough bytes to store the terminating null character
     of the string, and your parameter 'size' must reflect this.
     Otherwise, the debug version of Allegro will abort at an assertion,
     and the release version of Allegro will overrun the destination
     buffer.

See also:
*Note uconvert::.


File: allegro.info,  Node: uconvert,  Next: uconvert_ascii,  Prev: do_uconvert,  Up: Unicode

1.3.8 uconvert
--------------

char *uconvert(const char *s, int type, char *buf, int newtype, int size);
     Higher level function running on top of do_uconvert().  This
     function converts the specified string 's' from 'type' to
     'newtype', storing at most 'size' bytes into the output 'buf'
     (including the terminating null character), but it checks before
     doing the conversion, and doesn't bother if the string formats are
     already the same (either both types are equal, or one is ASCII, the
     other is UTF-8, and the string contains only 7-bit ASCII
     characters).

     As a convenience, if 'buf' is NULL it will convert the string into
     an internal static buffer and the 'size' parameter will be ignored.
     You should be wary of using this feature, though, because that
     buffer will be overwritten the next time this routine is called, so
     don't expect the data to persist across any other library calls.
     The static buffer may hold less than 1024 characters, so you won't
     be able to convert large chunks of text.  Example:

          char *p = uconvert(input_string, U_CURRENT, buffer, U_ASCII, 256);

     Returns a pointer to 'buf' (or the static buffer if you used NULL)
     if a conversion was performed.  Otherwise returns a copy of 's'.
     In any cases, you should use the return value rather than assuming
     that the string will always be moved to 'buf'.

See also:
*Note set_uformat::.
*Note need_uconvert::.
*Note uconvert::.
*Note uconvert_ascii::.
*Note uconvert_toascii::.
*Note do_uconvert::.


File: allegro.info,  Node: uconvert_ascii,  Next: uconvert_toascii,  Prev: uconvert,  Up: Unicode

1.3.9 uconvert_ascii
--------------------

char *uconvert_ascii(const char *s, char buf[]);
     Helper macro for converting strings from ASCII into the current
     encoding format.  Expands to uconvert(s, U_ASCII, buf, U_CURRENT,
     sizeof(buf)).

See also:
*Note uconvert::.
*Note exunicod::.


File: allegro.info,  Node: uconvert_toascii,  Next: empty_string,  Prev: uconvert_ascii,  Up: Unicode

1.3.10 uconvert_toascii
-----------------------

char *uconvert_toascii(const char *s, char buf[]);
     Helper macro for converting strings from the current encoding
     format into ASCII. Expands to uconvert(s, U_CURRENT, buf, U_ASCII,
     sizeof(buf)).

See also:
*Note uconvert::.


File: allegro.info,  Node: empty_string,  Next: ugetc,  Prev: uconvert_toascii,  Up: Unicode

1.3.11 empty_string
-------------------

extern char empty_string[];
     You can't just rely on "" to be a valid empty string in any
     encoding format.  This global buffer contains a number of
     consecutive zeros, so it will be a valid empty string no matter
     whether the program is running in ASCII, Unicode, or UTF-8 mode.


File: allegro.info,  Node: ugetc,  Next: ugetx,  Prev: empty_string,  Up: Unicode

1.3.12 ugetc
------------

int ugetc(const char *s);
     Low level helper function for reading Unicode text data.  Example:

          int first_unicode_letter = ugetc(text_string);

     Returns the character pointed to by 's' in the current encoding
     format.

See also:
*Note ugetx::.
*Note usetc::.
*Note uwidth::.
*Note ucwidth::.
*Note uisok::.


File: allegro.info,  Node: ugetx,  Next: usetc,  Prev: ugetc,  Up: Unicode

1.3.13 ugetx
------------

int ugetx(char **s);
int ugetxc(const char **s);
     Low level helper function for reading Unicode text data.  ugetxc is
     provided for working with pointer-to-pointer-to-const char data.
     Example:

          char *p = string;
          int first_letter, second_letter, third_letter;
          first_letter = ugetx(&p);
          second_letter = ugetx(&p);
          third_letter = ugetx(&p);

     Returns the character pointed to by 's' in the current encoding
     format, and advances the pointer to the next character after the
     one just returned.

See also:
*Note ugetc::.
*Note usetc::.
*Note uwidth::.
*Note ucwidth::.
*Note uisok::.


File: allegro.info,  Node: usetc,  Next: uwidth,  Prev: ugetx,  Up: Unicode

1.3.14 usetc
------------

int usetc(char *s, int c);
     Low level helper function for writing Unicode text data.  Writes
     the character 'c' to the address pointed to by 's'.

     Returns the number of bytes written, which is equal to the width of
     the character in the current encoding format.

See also:
*Note ugetc::.
*Note ugetx::.
*Note uwidth::.
*Note ucwidth::.
*Note uisok::.


File: allegro.info,  Node: uwidth,  Next: ucwidth,  Prev: usetc,  Up: Unicode

1.3.15 uwidth
-------------

int uwidth(const char *s);
     Low level helper function for testing Unicode text data.

     Returns the number of bytes occupied by the first character of the
     specified string, in the current encoding format.

See also:
*Note uwidth_max::.
*Note ugetc::.
*Note ugetx::.
*Note usetc::.
*Note ucwidth::.
*Note uisok::.


File: allegro.info,  Node: ucwidth,  Next: uisok,  Prev: uwidth,  Up: Unicode

1.3.16 ucwidth
--------------

int ucwidth(int c);
     Low level helper function for testing Unicode text data.

     Returns the number of bytes that would be occupied by the specified
     character value, when encoded in the current format.

See also:
*Note uwidth_max::.
*Note ugetc::.
*Note ugetx::.
*Note usetc::.
*Note uwidth::.
*Note uisok::.


File: allegro.info,  Node: uisok,  Next: uoffset,  Prev: ucwidth,  Up: Unicode

1.3.17 uisok
------------

int uisok(int c);
     Low level helper function for testing Unicode text data.  Finds out
     if the character value 'c' can be encoded correctly in the current
     format, which can be useful if you are converting from Unicode to
     ASCII or another encoding format where the range of valid
     characters is limited.

     Returns non-zero if the value can be correctly encoded, zero
     otherwise.

See also:
*Note ugetc::.
*Note ugetx::.
*Note usetc::.
*Note uwidth::.
*Note ucwidth::.


File: allegro.info,  Node: uoffset,  Next: ugetat,  Prev: uisok,  Up: Unicode

1.3.18 uoffset
--------------

int uoffset(const char *s, int index);
     Finds out the offset (in bytes from the start of the string) of the
     character at the specified 'index' in the string 's'.  A zero
     'index' parameter will return the first character of the string.
     If 'index' is negative, it counts backward from the end of the
     string, so an 'index' of '-1' will return an offset to the last
     character.  Example:

          int from_third_letter = uoffset(text_string, 2);

     Returns the offset in bytes to the specified character.

See also:
*Note ugetat::.
*Note usetat::.
*Note uinsert::.
*Note uremove::.


File: allegro.info,  Node: ugetat,  Next: usetat,  Prev: uoffset,  Up: Unicode

1.3.19 ugetat
-------------

int ugetat(const char *s, int index);
     Finds out the character value at the specified 'index' in the
     string.  A zero 'index' parameter will return the first character
     of the string.  If 'index' is negative, it counts backward from the
     end of the string, so an 'index' of '-1' will return the last
     character of the string.  Example:

          int third_letter = ugetat(text_string, 2);

     Returns the character value at the specified index in the string.

See also:
*Note uoffset::.
*Note usetat::.
*Note uinsert::.
*Note uremove::.


File: allegro.info,  Node: usetat,  Next: uinsert,  Prev: ugetat,  Up: Unicode

1.3.20 usetat
-------------

int usetat(char *s, int index, int c);
     Replaces the character at the specified index in the string with
     value 'c', handling any adjustments for variable width data (ie.
     if 'c' encodes to a different width than the previous value at that
     location).  If 'index' is negative, it counts backward from the end
     of the string.  Example:

          usetat(text_string, 2, letter_a);

     Returns the number of bytes by which the trailing part of the
     string was moved.  This is of interest only with text encoding
     formats where characters have a variable length, like UTF-8.

See also:
*Note uoffset::.
*Note ugetat::.
*Note uinsert::.
*Note uremove::.


File: allegro.info,  Node: uinsert,  Next: uremove,  Prev: usetat,  Up: Unicode

1.3.21 uinsert
--------------

int uinsert(char *s, int index, int c);
     Inserts the character 'c' at the specified 'index' in the string,
     sliding the rest of the data along to make room.  If 'index' is
     negative, it counts backward from the end of the string.  Example:

          uinsert(text_string, 0, prefix_letter);

     Returns the number of bytes by which the trailing part of the
     string was moved.

See also:
*Note uoffset::.
*Note ugetat::.
*Note usetat::.
*Note uremove::.


File: allegro.info,  Node: uremove,  Next: ustrsize,  Prev: uinsert,  Up: Unicode

1.3.22 uremove
--------------

int uremove(char *s, int index);
     Removes the character at the specified 'index' within the string,
     sliding the rest of the data back to fill the gap.  If 'index' is
     negative, it counts backward from the end of the string.  Example:

          int length_in_bytes = ustrsizez(text_string);
          ...
          length_in_bytes -= uremove(text_string, -1);

     Returns the number of bytes by which the trailing part of the
     string was moved.

See also:
*Note uoffset::.
*Note ugetat::.
*Note usetat::.
*Note uinsert::.


File: allegro.info,  Node: ustrsize,  Next: ustrsizez,  Prev: uremove,  Up: Unicode

1.3.23 ustrsize
---------------

int ustrsize(const char *s);
     Returns the size of the specified string in bytes, not including
     the trailing null character.

See also:
*Note ustrsizez::.
*Note empty_string::.
*Note exunicod::.


File: allegro.info,  Node: ustrsizez,  Next: uwidth_max,  Prev: ustrsize,  Up: Unicode

1.3.24 ustrsizez
----------------

int ustrsizez(const char *s);
     Returns the size of the specified string in bytes, including the
     trailing null character.

See also:
*Note ustrsize::.
*Note empty_string::.
*Note exunicod::.


File: allegro.info,  Node: uwidth_max,  Next: utolower,  Prev: ustrsizez,  Up: Unicode

1.3.25 uwidth_max
-----------------

int uwidth_max(int type);
     Low level helper function for working with Unicode text data.
     Returns the largest number of bytes that one character can occupy
     in the given encoding format.  Pass U_CURRENT to represent the
     current format.  Example:

          char *temp_buffer = malloc(256 * uwidth_max(U_UTF8));

See also:
*Note uwidth::.
*Note ucwidth::.


File: allegro.info,  Node: utolower,  Next: utoupper,  Prev: uwidth_max,  Up: Unicode

1.3.26 utolower
---------------

int utolower(int c);
     This function returns 'c', converting it to lower case if it is
     upper case.

See also:
*Note utoupper::.
*Note ugetc::.
*Note ugetx::.
*Note usetc::.
*Note uwidth::.
*Note ucwidth::.
*Note uisok::.


File: allegro.info,  Node: utoupper,  Next: uisspace,  Prev: utolower,  Up: Unicode

1.3.27 utoupper
---------------

int utoupper(int c);
     This function returns 'c', converting it to upper case if it is
     lower case.

See also:
*Note utolower::.
*Note ugetc::.
*Note ugetx::.
*Note usetc::.
*Note uwidth::.
*Note ucwidth::.
*Note uisok::.


File: allegro.info,  Node: uisspace,  Next: uisdigit,  Prev: utoupper,  Up: Unicode

1.3.28 uisspace
---------------

int uisspace(int c);
     Returns nonzero if 'c' is whitespace, that is, carriage return,
     newline, form feed, tab, vertical tab, or space.  Example:

          for (counter = 0; counter < ustrlen(text_string); counter++) {
             if (uisspace(ugetat(text_string, counter)))
                usetat(text_string, counter, '_');
          }

See also:
*Note uisdigit::.
*Note ugetc::.
*Note usetc::.
*Note uwidth::.
*Note ucwidth::.
*Note uisok::.


File: allegro.info,  Node: uisdigit,  Next: ustrdup,  Prev: uisspace,  Up: Unicode

1.3.29 uisdigit
---------------

int uisdigit(int c);
     Returns nonzero if 'c' is a digit.

          for (counter = 0; counter < ustrlen(text_string); counter++) {
             if (uisdigit(ugetat(text_string, counter)))
                usetat(text_string, counter, '*');
          }

See also:
*Note uisspace::.
*Note ugetc::.
*Note usetc::.
*Note uwidth::.
*Note ucwidth::.
*Note uisok::.


File: allegro.info,  Node: ustrdup,  Next: _ustrdup,  Prev: uisdigit,  Up: Unicode

1.3.30 ustrdup
--------------

char *ustrdup(const char *src)
     This functions copies the null-terminated string 'src' into a newly
     allocated area of memory, effectively duplicating it.  Example:

          void manipulate_string(const char *input_string)
          {
             char *temp_buffer = ustrdup(input_string);
             /* Now we can modify temp_buffer */
             ...

     Returns the newly allocated string.  This memory must be freed by
     the caller.  Returns NULL if it cannot allocate space for the
     duplicated string.

See also:
*Note _ustrdup::.
*Note uconvert::.
*Note ustrsize::.
*Note ustrsizez::.
*Note exconfig::.


File: allegro.info,  Node: _ustrdup,  Next: ustrcpy,  Prev: ustrdup,  Up: Unicode

1.3.31 _ustrdup
---------------

char *_ustrdup(const char *src, void* (*malloc_func)(size_t))
     Does the same as ustrdup(), but allows the user to specify a custom
     memory allocator function.

See also:
*Note ustrdup::.
*Note uconvert::.
*Note ustrsize::.
*Note ustrsizez::.


File: allegro.info,  Node: ustrcpy,  Next: ustrzcpy,  Prev: _ustrdup,  Up: Unicode

1.3.32 ustrcpy
--------------

char *ustrcpy(char *dest, const char *src);
     This function copies 'src' (including the terminating null
     character into 'dest'.  You should try to avoid this function
     because it is very easy to overflow the destination buffer.  Use
     ustrzcpy instead.

     Returns the value of dest.

See also:
*Note uconvert::.
*Note ustrzcpy::.
*Note ustrncpy::.
*Note exunicod::.


File: allegro.info,  Node: ustrzcpy,  Next: ustrcat,  Prev: ustrcpy,  Up: Unicode

1.3.33 ustrzcpy
---------------

char *ustrzcpy(char *dest, int size, const char *src);
     This function copies 'src' (including the terminating null
     character) into 'dest', whose length in bytes is specified by
     'size' and which is guaranteed to be null-terminated even if 'src'
     is bigger than 'size'.

     Note that, even for empty strings, your destination string must
     have at least enough bytes to store the terminating null character
     of the string, and your parameter 'size' must reflect this.
     Otherwise, the debug version of Allegro will abort at an assertion,
     and the release version of Allegro will overrun the destination
     buffer.

     Returns the value of 'dest'.

See also:
*Note uconvert::.
*Note ustrcpy::.
*Note ustrzncpy::.
*Note ex3buf::.
*Note exgui::.


File: allegro.info,  Node: ustrcat,  Next: ustrzcat,  Prev: ustrzcpy,  Up: Unicode

1.3.34 ustrcat
--------------

char *ustrcat(char *dest, const char *src);
     This function concatenates 'src' to the end of 'dest''.  You should
     try to avoid this function because it is very easy to overflow the
     destination buffer, use ustrzcat instead.

     Returns the value of 'dest'.

See also:
*Note uconvert::.
*Note ustrzcat::.
*Note ustrncat::.
*Note exunicod::.


File: allegro.info,  Node: ustrzcat,  Next: ustrlen,  Prev: ustrcat,  Up: Unicode

1.3.35 ustrzcat
---------------

char *ustrzcat(char *dest, int size, const char *src);
     This function concatenates 'src' to the end of 'dest', whose length
     in bytes is specified by 'size' and which is guaranteed to be
     null-terminated even when 'src' is bigger than 'size'.

     Note that, even for empty strings, your destination string must
     have at least enough bytes to store the terminating null character
     of the string, and your parameter 'size' must reflect this.
     Otherwise, the debug version of Allegro will abort at an assertion,
     and the release version of Allegro will overrun the destination
     buffer.

     Returns the value of 'dest'.

See also:
*Note uconvert::.
*Note ustrcat::.
*Note ustrzncat::.
*Note exgui::.


File: allegro.info,  Node: ustrlen,  Next: ustrcmp,  Prev: ustrzcat,  Up: Unicode

1.3.36 ustrlen
--------------

int ustrlen(const char *s);
     This function returns the number of characters in 's'.  Note that
     this doesn't have to equal the string's size in bytes.

See also:
*Note uconvert::.
*Note ustrsize::.
*Note ustrsizez::.


File: allegro.info,  Node: ustrcmp,  Next: ustrncpy,  Prev: ustrlen,  Up: Unicode

1.3.37 ustrcmp
--------------

int ustrcmp(const char *s1, const char *s2);
     This function compares 's1' and 's2'.

     Returns zero if the strings are equal, a positive number if 's1'
     comes after 's2' in the ASCII collating sequence, else a negative
     number.

See also:
*Note uconvert::.
*Note ustrsize::.
*Note ustrsizez::.
*Note ustrncmp::.
*Note ustricmp::.
*Note ustrnicmp::.


File: allegro.info,  Node: ustrncpy,  Next: ustrzncpy,  Prev: ustrcmp,  Up: Unicode

1.3.38 ustrncpy
---------------

char *ustrncpy(char *dest, const char *src, int n);
     This function is like ustrcpy() except that no more than 'n'
     characters from 'src' are copied into 'dest'.  If 'src' is shorter
     than 'n' characters, null characters are appended to 'dest' as
     padding until 'n' characters have been written.

     Note that if 'src' is longer than 'n' characters, 'dest' will not
     be null-terminated.

     The return value is the value of 'dest'.

See also:
*Note uconvert::.
*Note ustrcpy::.
*Note ustrzncpy::.


File: allegro.info,  Node: ustrzncpy,  Next: ustrncat,  Prev: ustrncpy,  Up: Unicode

1.3.39 ustrzncpy
----------------

char *ustrzncpy(char *dest, int size, const char *src, int n);
     This function is like ustrzcpy() except that no more than 'n'
     characters from 'src' are copied into 'dest' whose length in bytes
     is specified by 'size' and which is guaranteed to be
     null-terminated even if 'src' is bigger than 'size'.  If 'src' is
     shorter than 'n' characters, null characters are appended to 'dest'
     as padding until 'n' characters have been written.  In any case,
     'dest' is guaranteed to be null-terminated.

     Note that, even for empty strings, your destination string must
     have at least enough bytes to store the terminating null character
     of the string, and your parameter 'size' must reflect this.
     Otherwise, the debug version of Allegro will abort at an assertion,
     and the release version of Allegro will overrun the destination
     buffer.

     The return value is the value of 'dest'.

See also:
*Note uconvert::.
*Note ustrzcpy::.
*Note ustrncpy::.
*Note exkeys::.


File: allegro.info,  Node: ustrncat,  Next: ustrzncat,  Prev: ustrzncpy,  Up: Unicode

1.3.40 ustrncat
---------------

char *ustrncat(char *dest, const char *src, int n);
     This function is like ustrcat() except that no more than 'n'
     characters from 'src' are appended to the end of 'dest'.  If the
     terminating null character in 'src' is reached before 'n'
     characters have been written, the null character is copied, but no
     other characters are written.  If 'n' characters are written before
     a terminating null is encountered, the function appends its own
     null character to 'dest', so that 'n+1' characters are written.
     You should try to avoid this function because it is very easy to
     overflow the destination buffer.  Use ustrzncat instead.

     The return value is the value of 'dest'.

See also:
*Note uconvert::.
*Note ustrcat::.
*Note ustrzncat::.


File: allegro.info,  Node: ustrzncat,  Next: ustrncmp,  Prev: ustrncat,  Up: Unicode

1.3.41 ustrzncat
----------------

char *ustrzncat(char *dest, int size, const char *src, int n);
     This function is like ustrzcat() except that no more than 'n'
     characters from 'src' are appended to the end of 'dest'.  If the
     terminating null character in 'src' is reached before 'n'
     characters have been written, the null character is copied, but no
     other characters are written.  Note that 'dest' is guaranteed to be
     null-terminated.

     The return value is the value of 'dest'.

See also:
*Note uconvert::.
*Note ustrzcat::.
*Note ustrncat::.


File: allegro.info,  Node: ustrncmp,  Next: ustricmp,  Prev: ustrzncat,  Up: Unicode

1.3.42 ustrncmp
---------------

int ustrncmp(const char *s1, const char *s2, int n);
     This function compares up to 'n' characters of 's1' and 's2'.
     Example:

          if (ustrncmp(prefix, long_string, ustrlen(prefix)) == 0) {
             /* long_string starts with prefix */
          }

     Returns zero if the substrings are equal, a positive number if 's1'
     comes after 's2' in the ASCII collating sequence, else a negative
     number.

See also:
*Note uconvert::.
*Note ustrsize::.
*Note ustrsizez::.
*Note ustrcmp::.
*Note ustricmp::.
*Note ustrnicmp::.


File: allegro.info,  Node: ustricmp,  Next: ustrnicmp,  Prev: ustrncmp,  Up: Unicode

1.3.43 ustricmp
---------------

int ustricmp(const char *s1, const char *s2);
     This function compares 's1' and 's2', ignoring case.  Example:

          if (ustricmp(string, user_input) == 0) {
             /* string and user_input are equal (ignoring case) */
          }

     Returns zero if the strings are equal, a positive number if 's1'
     comes after 's2' in the ASCII collating sequence, else a negative
     number.

See also:
*Note uconvert::.
*Note ustrsize::.
*Note ustrsizez::.
*Note ustrnicmp::.
*Note ustrcmp::.
*Note ustrncmp::.
*Note exconfig::.


File: allegro.info,  Node: ustrnicmp,  Next: ustrlwr,  Prev: ustricmp,  Up: Unicode

1.3.44 ustrnicmp
----------------

int ustrnicmp(const char *s1, const char *s2, int n);
     This function compares up to 'n' characters of 's1' and 's2',
     ignoring case.  Example:

          if (ustrnicmp(prefix, long_string, ustrlen(prefix)) == 0) {
             /* long_string starts with prefix (ignoring case) */
          }

     Returns zero if the strings are equal, a positive number if 's1'
     comes after 's2' in the ASCII collating sequence, else a negative
     number.

See also:
*Note uconvert::.
*Note ustrsize::.
*Note ustrsizez::.
*Note ustricmp::.
*Note ustrcmp::.
*Note ustrncmp::.


File: allegro.info,  Node: ustrlwr,  Next: ustrupr,  Prev: ustrnicmp,  Up: Unicode

1.3.45 ustrlwr
--------------

char *ustrlwr(char *s);
     This function replaces all upper case letters in 's' with lower
     case letters.  Example:

          char buffer[] = "UPPER CASE STRING";
          allegro_message(ustrlwr(buffer));

     The return value is the value of 's'.

See also:
*Note uconvert::.
*Note utolower::.
*Note ustrupr::.


File: allegro.info,  Node: ustrupr,  Next: ustrchr,  Prev: ustrlwr,  Up: Unicode

1.3.46 ustrupr
--------------

char *ustrupr(char *s);
     This function replaces all lower case letters in 's' with upper
     case letters.  Example:

          char buffer[] = "lower case string";
          allegro_message(ustrupr(buffer));

     The return value is the value of 's'.

See also:
*Note uconvert::.
*Note utolower::.
*Note ustrlwr::.


File: allegro.info,  Node: ustrchr,  Next: ustrrchr,  Prev: ustrupr,  Up: Unicode

1.3.47 ustrchr
--------------

char *ustrchr(const char *s, int c);
     Finds the first occurrence of the character 'c' in the string 's'.
     Example:

          char *p = ustrchr("one,two,three,four", ',');

     Returns a pointer to the first occurrence of 'c' in 's', or NULL if
     no match was found.  Note that if 'c' is NULL, this will return a
     pointer to the end of the string.

See also:
*Note uconvert::.
*Note ustrrchr::.
*Note ustrstr::.
*Note ustrpbrk::.
*Note ustrtok::.


File: allegro.info,  Node: ustrrchr,  Next: ustrstr,  Prev: ustrchr,  Up: Unicode

1.3.48 ustrrchr
---------------

char *ustrrchr(const char *s, int c);
     Finds the last occurrence of the character 'c' in the string 's'.
     Example:

          char *p = ustrrchr("one,two,three,four", ',');

     Returns a pointer for the last occurrence of 'c' in 's', or NULL if
     no match was found.

See also:
*Note uconvert::.
*Note ustrchr::.
*Note ustrstr::.
*Note ustrpbrk::.
*Note ustrtok::.


File: allegro.info,  Node: ustrstr,  Next: ustrpbrk,  Prev: ustrrchr,  Up: Unicode

1.3.49 ustrstr
--------------

char *ustrstr(const char *s1, const char *s2);
     This function finds the first occurrence of string 's2' in string
     's1'.  Example:

          char *p = ustrstr("hello world", "world");

     Returns a pointer within 's1', or NULL if 's2' wasn't found.

See also:
*Note uconvert::.
*Note ustrchr::.
*Note ustrrchr::.
*Note ustrpbrk::.
*Note ustrtok::.


File: allegro.info,  Node: ustrpbrk,  Next: ustrtok,  Prev: ustrstr,  Up: Unicode

1.3.50 ustrpbrk
---------------

char *ustrpbrk(const char *s, const char *set);
     This function finds the first character in 's' that matches any
     character in 'set'.  Example:

          char *p = ustrpbrk("one,two-three.four", "-. ");

     Returns a pointer to the first match, or NULL if none are found.

See also:
*Note uconvert::.
*Note ustrchr::.
*Note ustrrchr::.
*Note ustrstr::.
*Note ustrtok::.


File: allegro.info,  Node: ustrtok,  Next: ustrtok_r,  Prev: ustrpbrk,  Up: Unicode

1.3.51 ustrtok
--------------

char *ustrtok(char *s, const char *set);
     This function retrieves tokens from 's' which are delimited by
     characters from 'set'.  To initiate the search, pass the string to
     be searched as 's'.  For the remaining tokens, pass NULL instead.
     Warning: Since ustrtok alters the string it is parsing, you should
     always copy the string to a temporary buffer before parsing it.
     Also, this function is not re-entrant (ie.  you cannot parse two
     strings at the same time).  Example:

          char *word;
          char string[]="some-words with dashes";
          char *temp = ustrdup(string);
          word = ustrtok(temp, " -");
          while (word) {
             allegro_message("Found `%s'\n", word);
             word = ustrtok(NULL, " -");
          }
          free(temp);

     Returns a pointer to the token, or NULL if no more are found.

See also:
*Note uconvert::.
*Note ustrchr::.
*Note ustrrchr::.
*Note ustrstr::.
*Note ustrpbrk::.
*Note ustrtok_r::.
*Note allegro_message::.
*Note ustrncpy::.
*Note exgui::.


File: allegro.info,  Node: ustrtok_r,  Next: uatof,  Prev: ustrtok,  Up: Unicode

1.3.52 ustrtok_r
----------------

char *ustrtok_r(char *s, const char *set, char **last);
     Reentrant version of ustrtok.  The 'last' parameter is used to keep
     track of where the parsing is up to and must be a pointer to a char
     * variable allocated by the user that remains the same while
     parsing the same string.  Example:

          char *word, *last;
          char string[]="some-words with dashes";
          char *temp = ustrdup(string);
          word = ustrtok_r(string, " -", &last);
          while (word) {
             allegro_message("Found `%s'\n", word);
             word = ustrtok_r(NULL, " -", &last);
          }
          free(temp);

     Returns a pointer to the token, or NULL if no more are found.  You
     can free the memory pointed to by 'last' once NULL is returned.

See also:
*Note ustrtok::.


File: allegro.info,  Node: uatof,  Next: ustrtol,  Prev: ustrtok_r,  Up: Unicode

1.3.53 uatof
------------

double uatof(const char *s);
     Convert as much of the string as possible to an equivalent double
     precision real number.  This function is almost like 'ustrtod(s,
     NULL)'.

     Returns the equivalent value, or zero if the string does not
     represent a number.

See also:
*Note uconvert::.
*Note ustrtol::.
*Note ustrtod::.


File: allegro.info,  Node: ustrtol,  Next: ustrtod,  Prev: uatof,  Up: Unicode

1.3.54 ustrtol
--------------

long ustrtol(const char *s, char **endp, int base);
     This function converts the initial part of 's' to a signed integer,
     setting '*endp' to point to the first unused character, if 'endp'
     is not a NULL pointer.  The 'base' argument indicates what base the
     digits (or letters) should be treated as.  If 'base' is zero, the
     base is determined by looking for '0x', '0X', or '0' as the first
     part of the string, and sets the base used to 16, 16, or 8 if it
     finds one.  The default base is 10 if none of those prefixes are
     found.  Example:

          char *endp, *string = "456.203 askdfg";
          int number = ustrtol(string, &endp, 10);

     Returns the string converted as a value of type 'long int'.  If
     nothing was converted, returns zero with '*endp' pointing to the
     beginning of 's'.

See also:
*Note uconvert::.
*Note ustrtod::.
*Note uatof::.


File: allegro.info,  Node: ustrtod,  Next: ustrerror,  Prev: ustrtol,  Up: Unicode

1.3.55 ustrtod
--------------

double ustrtod(const char *s, char **endp);
     This function converts as many characters of 's' that look like a
     floating point number into one, and sets '*endp' to point to the
     first unused character, if 'endp' is not a NULL pointer.  Example:

          char *endp, *string = "456.203 askdfg";
          double number = ustrtod(string, &endp);

     Returns the string converted as a value of type 'double'.  If
     nothing was converted, returns zero with *endp pointing to the
     beginning of s.

See also:
*Note uconvert::.
*Note ustrtol::.
*Note uatof::.


File: allegro.info,  Node: ustrerror,  Next: usprintf,  Prev: ustrtod,  Up: Unicode

1.3.56 ustrerror
----------------

const char *ustrerror(int err);
     This function returns a string that describes the error code 'err',
     which normally comes from the variable 'errno'.  Example:

          PACKFILE *input_file = pack_fopen("badname", "r");
          if (input_file == NULL)
             allegro_message("%s\nSorry!\n", ustrerror(errno));

     Returns a pointer to a static string that should not be modified or
     freed.  If you make subsequent calls to ustrerror(), the string
     will be overwritten.

See also:
*Note uconvert::.
*Note allegro_error::.


File: allegro.info,  Node: usprintf,  Next: uszprintf,  Prev: ustrerror,  Up: Unicode

1.3.57 usprintf
---------------

int usprintf(char *buf, const char *format, ...);
     This function writes formatted data into the output buffer.  A NULL
     character is written to mark the end of the string.  You should try
     to avoid this function because it is very easy to overflow the
     destination buffer.  Use uszprintf instead.

     Returns the number of characters written, not including the
     terminating null character.

See also:
*Note uconvert::.
*Note uszprintf::.
*Note uvsprintf::.
*Note exkeys::.


File: allegro.info,  Node: uszprintf,  Next: uvsprintf,  Prev: usprintf,  Up: Unicode

1.3.58 uszprintf
----------------

int uszprintf(char *buf, int size, const char *format, ...);
     This function writes formatted data into the output buffer, whose
     length in bytes is specified by 'size' and which is guaranteed to
     be NULL terminated.  Example:

          char buffer[10];
          int player_score;
          ...
          uszprintf(buffer, sizeof(buffer), "Your score is: %d", player_score);

     Returns the number of characters that would have been written
     without eventual truncation (like with usprintf), not including the
     terminating null character.

See also:
*Note uconvert::.
*Note usprintf::.
*Note uvszprintf::.
*Note exgui::.


File: allegro.info,  Node: uvsprintf,  Next: uvszprintf,  Prev: uszprintf,  Up: Unicode

1.3.59 uvsprintf
----------------

int uvsprintf(char *buf, const char *format, va_list args);
     This is like usprintf(), but you pass the variable argument list
     directly, instead of the arguments themselves.  You can use this
     function to implement printf like functions, also called variadic
     functions.  You should try to avoid this function because it is
     very easy to overflow the destination buffer.  Use uvszprintf
     instead.

     Returns the number of characters written, not including the
     terminating null character.

See also:
*Note uconvert::.
*Note usprintf::.
*Note uvszprintf::.


File: allegro.info,  Node: uvszprintf,  Next: set_config_file,  Prev: uvsprintf,  Up: Unicode

1.3.60 uvszprintf
-----------------

int uvszprintf(char *buf, int size, const char *format, va_list args);
     This is like uszprintf(), but you pass the variable argument list
     directly, instead of the arguments themselves.  Example:

          #include <stdarg.h>

          void log_message(const char *format, ...)
          {
             char buffer[100];
             va_list parameters;

             va_start(parameters, format);
             uvszprintf(buffer, sizeof(buffer), format, parameters);
             va_end(parameters);

             append_buffer_to_logfile(log_name, buffer);
             send_buffer_to_other_networked_players(multicast_ip, buffer);
             and_also_print_it_on_the_screen(cool_font, buffer);
          }

          void some_other_function(void)
          {
             log_message("Hello %s, are you %d years old?\n", "Dave", 25);
          }

     Returns the number of characters that would have been written
     without eventual truncation (like with uvsprintf), not including
     the terminating null character.

See also:
*Note uconvert::.
*Note uszprintf::.
*Note uvsprintf::.


File: allegro.info,  Node: Configuration,  Next: Mouse,  Prev: Unicode,  Up: API

1.4 Configuration routines
==========================

Various parts of Allegro, such as the sound routines and the
load_joystick_data() function, require some configuration information.
This data is stored in text files as a collection of 'variable=value'
lines, along with comments that begin with a '#' character and continue
to the end of the line.  The configuration file may optionally be
divided into sections, which begin with a '[sectionname]' line.  Each
section has a unique namespace, to prevent variable name conflicts, but
any variables that aren't in a section are considered to belong to all
the sections simultaneously.

Note that variable and section names cannot contain spaces.

By default the configuration data is read from a file called
'allegro.cfg', which can be located either in the same directory as the
program executable, or the directory pointed to by the ALLEGRO
environment variable.  Under Unix, it also checks for '~/allegro.cfg',
'~/.allegrorc', '/etc/allegro.cfg', and '/etc/allegrorc', in that order;
under BeOS only the last two are also checked.  MacOS X also checks in
the Contents/Resources directory of the application bundle, if any,
before doing the checks above.

If you don't like this approach, you can specify any filename you like,
or use a block of binary configuration data provided by your program
(which could for example be loaded from a datafile).  You can also
extend the paths searched for allegro resources with
set_allegro_resource_path().

You can store whatever custom information you like in the config file,
along with the standard variables that are used by Allegro (see below).
Allegro comes with a setup directory where you can find configuration
programs.  The standalone setup program is likely to be of interest to
final users.  It allows any user to create an 'allegro.cfg' file without
the need to touch a text editor and enter values by hand.  It also
provides a few basic tests like sound playing for sound card testing.
You are welcome to include the setup program with your game, either as
is or with modified graphics to fit better your game.

* Menu:

* set_config_file::
* set_config_data::
* override_config_file::
* override_config_data::
* push_config_state::
* pop_config_state::
* flush_config_file::
* reload_config_texts::
* hook_config_section::
* config_is_hooked::
* get_config_string::
* get_config_int::
* get_config_hex::
* get_config_float::
* get_config_id::
* get_config_argv::
* get_config_text::
* set_config_string::
* set_config_int::
* set_config_hex::
* set_config_float::
* set_config_id::
* list_config_entries::
* list_config_sections::
* free_config_entries::
* Standard config variables::


File: allegro.info,  Node: set_config_file,  Next: set_config_data,  Prev: uvszprintf,  Up: Configuration

1.4.1 set_config_file
---------------------

void set_config_file(const char *filename);
     Sets the configuration file to be used by all subsequent config
     functions.  (Allegro will not search for this file in other
     locations as it does with allegro.cfg at the time of
     initialization.)

     All pointers returned by previous calls to get_config_string() and
     other related functions are invalidated when you call this
     function!  You can call this function before install_allegro() to
     change the configuration file, but after set_uformat() if you want
     to use a text encoding format other than the default.

See also:
*Note set_config_data::.
*Note override_config_file::.
*Note push_config_state::.
*Note set_uformat::.
*Note Standard config variables::.
*Note set_config_string::.
*Note get_config_string::.
*Note exconfig::.


File: allegro.info,  Node: set_config_data,  Next: override_config_file,  Prev: set_config_file,  Up: Configuration

1.4.2 set_config_data
---------------------

void set_config_data(const char *data, int length);
     Specifies a block of data to be used by all subsequent config
     functions, which you have already loaded from disk (eg.  as part of
     some more complicated format of your own, or in a grabber
     datafile).  This routine makes a copy of the information, so you
     can safely free the data after calling it.

See also:
*Note set_config_file::.
*Note override_config_data::.
*Note push_config_state::.
*Note Standard config variables::.
*Note set_config_string::.
*Note get_config_string::.


File: allegro.info,  Node: override_config_file,  Next: override_config_data,  Prev: set_config_data,  Up: Configuration

1.4.3 override_config_file
--------------------------

void override_config_file(const char *filename);
     Specifies a file containing config overrides.  These settings will
     be used in addition to the parameters in the main config file, and
     where a variable is present in both files this version will take
     priority.  This can be used by application programmers to override
     some of the config settings from their code, while still leaving
     the main config file free for the end user to customise.  For
     example, you could specify a particular sample frequency and IBK
     instrument file, but the user could still use an 'allegro.cfg' file
     to specify the port settings and irq numbers.

     The override config file will not only take precedence when
     reading, but will also be used for storing values.  When you are
     done with using the override config file, you can call
     override_config_file with a NULL parameter, so config data will be
     directly read from the current config file again.

     Note: The override file is completely independent from the current
     configuration.  You can e.g.  call set_config_file, and the
     override file will still be active.  Also the flush_config_file
     function will only affect the current config file (which can be
     changed with set_config_file), never the overriding one specified
     with this function.  The modified override config is written back
     to disk whenever you call override_config_file.

     Example:

          override_config_file("my.cfg");
          /* This will read from my.cfg, and if it doesn't find a
           * setting, will read from the current config file instead.
           */
          language = get_config_string("system", "language", NULL);
          /* This will always write to my.cfg, no matter if the
           * settings is already present or not.
           */
          set_config_string("system", "language", "RU");
          /* This forces the changed setting to be written back to
           * disk. Else it is written back at the next call to
           * override_config_file, or when Allegro shuts down.
           */
          override_config_file(NULL);

     Note that this function and override_config_data() are mutually
     exclusive, i.e.  calling one will cancel the effects of the other.

See also:
*Note override_config_data::.
*Note set_config_file::.


File: allegro.info,  Node: override_config_data,  Next: push_config_state,  Prev: override_config_file,  Up: Configuration

1.4.4 override_config_data
--------------------------

void override_config_data(const char *data, int length);
     Version of override_config_file() which uses a block of data that
     has already been read into memory.  The length of the block has to
     be specified in bytes.  Example:

          /* Force German as system language, Spanish keyboard map. */
          const char *override_data = "[system]\n"
             "language=DE\n"
             "keyboard=ES";
          override_config_data(override_data, ustrsize(override_data));

     Note that this function and override_config_file() are mutually
     exclusive, i.e.  calling one will cancel the effects of the other.

See also:
*Note override_config_file::.
*Note set_config_data::.


File: allegro.info,  Node: push_config_state,  Next: pop_config_state,  Prev: override_config_data,  Up: Configuration

1.4.5 push_config_state
-----------------------

void push_config_state();
     Pushes the current configuration state (filename, variable values,
     etc).  onto an internal stack, allowing you to select some other
     config source and later restore the current settings by calling
     pop_config_state().  This function is mostly intended for internal
     use by other library functions, for example when you specify a
     config filename to the save_joystick_data() function, it pushes the
     config state before switching to the file you specified.

See also:
*Note pop_config_state::.
*Note set_config_file::.
*Note save_joystick_data::.
*Note exconfig::.


File: allegro.info,  Node: pop_config_state,  Next: flush_config_file,  Prev: push_config_state,  Up: Configuration

1.4.6 pop_config_state
----------------------

void pop_config_state();
     Pops a configuration state previously stored by
     push_config_state(), replacing the current config source with it.

See also:
*Note push_config_state::.
*Note exconfig::.


File: allegro.info,  Node: flush_config_file,  Next: reload_config_texts,  Prev: pop_config_state,  Up: Configuration

1.4.7 flush_config_file
-----------------------

void flush_config_file();
     Writes the current config file to disk if the contents have changed
     since it was loaded or since the latest call to the function.

See also:
*Note set_config_file::.
*Note override_config_file::.
*Note push_config_state::.


File: allegro.info,  Node: reload_config_texts,  Next: hook_config_section,  Prev: flush_config_file,  Up: Configuration

1.4.8 reload_config_texts
-------------------------

void reload_config_texts(const char *new_language);
     Reloads the translated strings returned by get_config_text().  This
     is useful to switch to another language in your program at runtime.
     If you want to modify the '[system]' language configuration
     variable yourself, or you have switched configuration files, you
     will want to pass NULL to just reload whatever language is
     currently selected.  Or you can pass a string containing the two
     letter code of the language you desire to switch to, and the
     function will modify the language variable.  After you call this
     function, the previously returned pointers of get_config_text()
     will be invalid.  Example:

          ...
          /* The user selects French from a language choice menu. */
          reload_config_texts("FR");

See also:
*Note get_config_text::.
*Note get_config_string::.
*Note Standard config variables::.


File: allegro.info,  Node: hook_config_section,  Next: config_is_hooked,  Prev: reload_config_texts,  Up: Configuration

1.4.9 hook_config_section
-------------------------

void hook_config_section(const char *section, int (*intgetter)(const char *name, int def), const char *(*stringgetter)(const char *name, const char *def), void (*stringsetter)(const char *name, const char *value));
     Takes control of the specified config file section, so that your
     hook functions will be used to manipulate it instead of the normal
     disk file access.  If both the getter and setter functions are
     NULL, a currently present hook will be unhooked.  Hooked functions
     have the highest priority.  If a section is hooked, the hook will
     always be called, so you can also hook a '#' section: even
     override_config_file() cannot override a hooked section.  Example:

          int decode_encrypted_int(const char *name, int def)
          {
             ...
          }

          const char *decode_encrypted_string(const char *name, const char *def)
          {
             ...
          }

          void encode_plaintext_string(const char *name, const char *value)
          {
             ...
          }

          int main(int argc, char *argv[])
          {
             ...
             /* Make it harder for users to tinker with the high scores. */
             hook_config_section("high_scores", decode_encrypted_int,
                decode_encrypted_string, encode_plaintext_string);
             ...
          } END_OF_MAIN()

See also:
*Note config_is_hooked::.


File: allegro.info,  Node: config_is_hooked,  Next: get_config_string,  Prev: hook_config_section,  Up: Configuration

1.4.10 config_is_hooked
-----------------------

int config_is_hooked(const char *section);
     Returns TRUE if the specified config section has been hooked.
     Example:

          if (config_is_hooked("high_scores")) {
             hook_config_section("high_scores, NULL, NULL, NULL);
          }

See also:
*Note hook_config_section::.


File: allegro.info,  Node: get_config_string,  Next: get_config_int,  Prev: config_is_hooked,  Up: Configuration

1.4.11 get_config_string
------------------------

const char *get_config_string(const char *section, const char *name, const char *def);
     Retrieves a string variable from the current config file.  The
     section name may be set to NULL to read variables from the root of
     the file, or used to control which set of parameters (eg.  sound or
     joystick) you are interested in reading.  Example:

          const char *lang = get_config_string("system", "language", "EN");

     Returns a pointer to the constant string found in the configuration
     file.  If the named variable cannot be found, or its entry in the
     config file is empty, the value of 'def' is returned.

See also:
*Note set_config_file::.
*Note set_config_string::.
*Note get_config_argv::.
*Note get_config_float::.
*Note get_config_hex::.
*Note get_config_int::.
*Note get_config_id::.
*Note get_config_text::.
*Note exconfig::.


File: allegro.info,  Node: get_config_int,  Next: get_config_hex,  Prev: get_config_string,  Up: Configuration

1.4.12 get_config_int
---------------------

int get_config_int(const char *section, const char *name, int def);
     Reads an integer variable from the current config file.  See the
     comments about get_config_string().

See also:
*Note set_config_file::.
*Note set_config_int::.
*Note get_config_string::.
*Note get_config_argv::.
*Note get_config_float::.
*Note get_config_hex::.
*Note get_config_id::.
*Note exconfig::.


File: allegro.info,  Node: get_config_hex,  Next: get_config_float,  Prev: get_config_int,  Up: Configuration

1.4.13 get_config_hex
---------------------

int get_config_hex(const char *section, const char *name, int def);
     Reads an integer variable from the current config file, in
     hexadecimal format.  See the comments about get_config_string().

See also:
*Note set_config_file::.
*Note set_config_hex::.
*Note get_config_string::.
*Note get_config_argv::.
*Note get_config_float::.
*Note get_config_int::.
*Note get_config_id::.


File: allegro.info,  Node: get_config_float,  Next: get_config_id,  Prev: get_config_hex,  Up: Configuration

1.4.14 get_config_float
-----------------------

float get_config_float(const char *section, const char *name, float def);
     Reads a floating point variable from the current config file.  See
     the comments about get_config_string().

See also:
*Note set_config_file::.
*Note set_config_float::.
*Note get_config_string::.
*Note get_config_argv::.
*Note get_config_hex::.
*Note get_config_int::.
*Note get_config_id::.


File: allegro.info,  Node: get_config_id,  Next: get_config_argv,  Prev: get_config_float,  Up: Configuration

1.4.15 get_config_id
--------------------

int get_config_id(const char *section, const char *name, int def);
     Reads a 4-letter driver ID variable from the current config file.
     See the comments about get_config_string().

See also:
*Note set_config_file::.
*Note set_config_id::.
*Note get_config_string::.
*Note get_config_argv::.
*Note get_config_float::.
*Note get_config_hex::.
*Note get_config_int::.


File: allegro.info,  Node: get_config_argv,  Next: get_config_text,  Prev: get_config_id,  Up: Configuration

1.4.16 get_config_argv
----------------------

char **get_config_argv(const char *section, const char *name, int *argc);
     Reads a token list (words separated by spaces) from the current
     config file.  The token list is stored in a temporary buffer that
     will be clobbered by the next call to get_config_argv(), so the
     data should not be expected to persist.

     Returns an argv style argument list and sets 'argc' to the number
     of retrieved tokens.  If the variable is not present, returns NULL
     and sets argc to zero.

See also:
*Note set_config_file::.
*Note get_config_string::.
*Note get_config_float::.
*Note get_config_hex::.
*Note get_config_int::.
*Note get_config_id::.
*Note exconfig::.


File: allegro.info,  Node: get_config_text,  Next: set_config_string,  Prev: get_config_argv,  Up: Configuration

1.4.17 get_config_text
----------------------

const char *get_config_text(const char *msg);
     This function is primarily intended for use by internal library
     code, but it may perhaps be helpful to application programmers as
     well.  It uses the 'language.dat' or 'XXtext.cfg' files (where XX
     is a language code) to look up a translated version of the
     parameter in the currently selected language.

     This is basically the same thing as calling get_config_string()
     with '[language]' as the section, 'msg' as the variable name, and
     'msg' as the default value, but it contains some special code to
     handle Unicode format conversions.  The 'msg' parameter is always
     given in ASCII format, but the returned string will be converted
     into the current text encoding, with memory being allocated as
     required, so you can assume that this pointer will persist without
     having to manually allocate storage space for each string.

     Note that if you are planning on distributing your game on the Unix
     platform there is a special issue with how to deal with the
     'language.dat' file.  Read section "Files shared by Allegro" of the
     chapter "Unix specifics" to learn more about this.

     Returns a suitable translation if one can be found or a copy of the
     parameter if nothing else is available.

See also:
*Note get_config_string::.
*Note reload_config_texts::.
*Note Standard config variables::.


File: allegro.info,  Node: set_config_string,  Next: set_config_int,  Prev: get_config_text,  Up: Configuration

1.4.18 set_config_string
------------------------

void set_config_string(const char *section, const char *name, const char *val);
     Writes a string variable to the current config file, replacing any
     existing value it may have, or removes the variable if 'val' is
     NULL. The section name may be set to NULL to write the variable to
     the root of the file, or used to control which section the variable
     is inserted into.  The altered file will be cached in memory, and
     not actually written to disk until you call allegro_exit().  Note
     that you can only write to files in this way, so the function will
     have no effect if the current config source was specified with
     set_config_data() rather than set_config_file().

     As a special case, variable or section names that begin with a '#'
     character are treated specially and will not be read from or
     written to the disk.  Addon packages can use this to store version
     info or other status information into the config module, from where
     it can be read with the get_config_string() function.

See also:
*Note set_config_file::.
*Note get_config_string::.
*Note set_config_float::.
*Note set_config_hex::.
*Note set_config_int::.
*Note set_config_id::.


File: allegro.info,  Node: set_config_int,  Next: set_config_hex,  Prev: set_config_string,  Up: Configuration

1.4.19 set_config_int
---------------------

void set_config_int(const char *section, const char *name, int val);
     Writes an integer variable to the current config file.  See the
     comments about set_config_string().

See also:
*Note set_config_file::.
*Note get_config_int::.
*Note set_config_string::.
*Note set_config_float::.
*Note set_config_hex::.
*Note set_config_id::.


File: allegro.info,  Node: set_config_hex,  Next: set_config_float,  Prev: set_config_int,  Up: Configuration

1.4.20 set_config_hex
---------------------

void set_config_hex(const char *section, const char *name, int val);
     Writes an integer variable to the current config file, in
     hexadecimal format.  See the comments about set_config_string().

See also:
*Note set_config_file::.
*Note get_config_hex::.
*Note set_config_string::.
*Note set_config_float::.
*Note set_config_int::.
*Note set_config_id::.


File: allegro.info,  Node: set_config_float,  Next: set_config_id,  Prev: set_config_hex,  Up: Configuration

1.4.21 set_config_float
-----------------------

void set_config_float(const char *section, const char *name, float val);
     Writes a floating point variable to the current config file.  See
     the comments about set_config_string().

See also:
*Note set_config_file::.
*Note get_config_float::.
*Note set_config_string::.
*Note set_config_hex::.
*Note set_config_int::.
*Note set_config_id::.


File: allegro.info,  Node: set_config_id,  Next: list_config_entries,  Prev: set_config_float,  Up: Configuration

1.4.22 set_config_id
--------------------

void set_config_id(const char *section, const char *name, int val);
     Writes a 4-letter driver ID variable to the current config file.
     See the comments about set_config_string().

See also:
*Note set_config_file::.
*Note get_config_id::.
*Note set_config_string::.
*Note set_config_float::.
*Note set_config_hex::.
*Note set_config_int::.


File: allegro.info,  Node: list_config_entries,  Next: list_config_sections,  Prev: set_config_id,  Up: Configuration

1.4.23 list_config_entries
--------------------------

int list_config_entries(const char *section, const char ***names);
     This function can be used to get a list of all entries in the given
     config section.  The names parameter is a pointer to an array of
     strings.  If it points to a NULL pointer, the list will be
     allocated, else it will be re-allocated.  You should free the list
     again with free_config_entries if you don't need it anymore, or you
     can pass it again to list_config_entries and the memory will be
     re-used.  See the following example for how you can use it, it will
     print out the complete contents of the current configuration:

          int i, n;
          char const **sections = NULL;
          char const **entries = NULL;

          /* List all entries not in any section. */
          n = list_config_entries(NULL, &entries);
          for (i = 0; i
             printf(" %s=\"%s\"\n", entries[i], get_config_string(
                    NULL, entries[i], "-"));

          /* List all sections (and entries in them). */
          n = list_config_sections(&sections);
          /* loop through all section names */
          for (i = 0; i
          {
             int j, m;
             printf("%s\n", sections[i]);
             m = list_config_entries(sections[i], &entries);
             /* loop through all entries in the section */
             for (j = 0; j
             {
                 printf(" %s=\"%s\"\n", entries[j], get_config_string(
                    sections[i], entries[j], "-"));
             }
          }
          /* It is enough to free the arrays once at the end. */
          free_config_entries(&sections);
          free_config_entries(&entries);

     Returns the number of valid strings in the names array.

See also:
*Note set_config_file::.
*Note get_config_string::.
*Note list_config_sections::.
*Note free_config_entries::.


File: allegro.info,  Node: list_config_sections,  Next: free_config_entries,  Prev: list_config_entries,  Up: Configuration

1.4.24 list_config_sections
---------------------------

int list_config_sections(const char ***names);
     The names parameter is a pointer to an array of strings.  If it
     points to a NULL pointer, the list will be allocated, else it will
     be re-allocated.  After the function returns, it will contain the
     names of all sections in the current configuration.  Use
     free_config_entries to free the allocated memory again.  See
     list_config_entries for more information and an example how to use
     it.

     Returns the number of valid strings in the names array.

See also:
*Note list_config_entries::.
*Note set_config_file::.
*Note get_config_string::.
*Note free_config_entries::.


File: allegro.info,  Node: free_config_entries,  Next: Standard config variables,  Prev: list_config_sections,  Up: Configuration

1.4.25 free_config_entries
--------------------------

int free_config_entries(const char ***names);

     Once you are done with the string arrays filled in by
     list_config_entries and list_config_sections, you can free them
     again with this function.  The passed array pointer will be set to
     NULL, and you directly can pass the same pointer again to
     list_config_entries or list_config_sections later - but you also
     could pass them again without freeing first, since the memory is
     re-allocated when the pointer is not NULL.

     See list_config_entries for an example of how to use it.

See also:
*Note list_config_entries::.
*Note list_config_sections::.


File: allegro.info,  Node: Standard config variables,  Next: install_mouse,  Prev: free_config_entries,  Up: Configuration

1.4.26 Standard config variables
--------------------------------

Allegro uses these standard variables from the configuration file:

   * [system]
     Section containing general purpose variables:

        * system = x
          Specifies which system driver to use.  This is currently only
          useful on Linux, for choosing between the X-Windows ("XWIN")
          or console ("LNXC") modes.
        * keyboard = x
          Specifies which keyboard layout to use.  The parameter is the
          name of a keyboard mapping file produced by the keyconf
          utility, and can either be a fully qualified file path or a
          base name like 'us' or 'uk'.  If the latter, Allegro will look
          first for a separate config file with that name (eg.
          'uk.cfg') and then for an object with that name in the
          'keyboard.dat' file (eg.  'UK_CFG'). The config file or
          'keyboard.dat' file can be stored in the same directory as the
          program, or in the location pointed to by the ALLEGRO
          environment variable.  Look in the 'keyboard.dat' file to see
          what mappings are currently available.
        * language = x
          Specifies which language file to use for error messages and
          other bits of system text.  The parameter is the name of a
          translation file, and can either be a fully qualified file
          path or a base name like 'en' or 'es'.  If the latter, Allegro
          will look first for a separate config file with a name in the
          form 'entext.cfg', and then for an object with that name in
          the 'language.dat' file (eg.  'ENTEXT_CFG'). The config file
          or 'language.dat' file can be stored in the same directory as
          the program, or in the location pointed to by the ALLEGRO
          environment variable.

          Look in the 'language.dat' file to see which mappings are
          currently available.  If there is none for your language, you
          can create it using the English one as model, and even send it
          to the Allegro development team to include it in future
          releases.
        * disable_screensaver = x
          Specifies whether to disable the screensaver: 0 to never
          disable it, 1 to disable it in fullscreen mode only and 2 to
          always disable it.  Default is 1.
        * menu_opening_delay = x
          Sets how long the menus take to auto-open.  The time is given
          in milliseconds (default is '300').  Specifying '-1' will
          disable the auto-opening feature.
        * XInitThreads = x
          If this is set to 0, the X11 port will not call XInitThreads.
          This can have slight performance advantages and was required
          on some broken X11 servers, but it makes Allegro incompatible
          with other X11 libraries like Mesa.
   * [graphics]
     Section containing graphics configuration information, using the
     variables:

        * gfx_card = x
          Specifies which graphics driver to use when the program
          requests GFX_AUTODETECT. Multiple possible drivers can be
          suggested with extra lines in the form 'gfx_card1 = x',
          'gfx_card2 = x', etc, or you can specify different drivers for
          each mode and color depth with variables in the form
          'gfx_card_24bpp = x', 'gfx_card_640x480x16 = x', etc.
        * gfx_cardw = x
          Specifies which graphics driver to use when the program
          requests GFX_AUTODETECT_WINDOWED. This variable functions
          exactly like gfx_card in all other respects.  If it is not
          set, Allegro will look for the gfx_card variable.
        * disable_vsync = x
          Specifies whether to disable synchronization with the vertical
          blank when page-flipping (yes or no).  Disabling
          synchronization may increase the frame rate on slow systems,
          at the expense of introducing flicker on fast systems.
        * vbeaf_driver = x
          DOS and Linux only: specifies where to look for the VBE/AF
          driver (vbeaf.drv).  If this variable is not set, Allegro will
          look in the same directory as the program, and then fall back
          on the standard locations ('c:\' for DOS, '/usr/local/lib',
          '/usr/lib', '/lib', and '/' for Linux, or the directory
          specified with the VBEAF_PATH environment variable).
        * framebuffer = x
          Linux only: specifies what device file to use for the fbcon
          driver.  If this variable is not set, Allegro checks the
          FRAMEBUFFER environment variable, and then defaults to
          '/dev/fb0'.
        * force_centering = x
          Unix/X11 only: specifies whether to force window centering in
          fullscreen mode when the XWFS driver is used (yes or no).
          Enabling this setting may cause some artifacts to appear on
          KDE desktops.
        * disable_direct_updating = x
          Windows only: specifies whether to disable direct updating
          when the GFX_DIRECTX_WIN driver is used in color conversion
          mode (yes or no).  Direct updating can cause artifacts to be
          left on the desktop when the window is moved or minimized;
          disabling it results in a significant performance loss.
   * [mouse]
     Section containing mouse configuration information, using the
     variables:

        * mouse = x
          Mouse driver type.  Available DOS drivers are:

               MICK - mickey mode driver (normally the best)
               I33  - int 0x33 callback driver
               POLL - timer polling (for use under NT)

          Linux console mouse drivers are:

               MS   - Microsoft serial mouse
               IMS  - Microsoft serial mouse with Intellimouse extension
               LPS2 - PS2 mouse
               LIPS - PS2 mouse with Intellimouse extension
               GPMD - GPM repeater data (Mouse Systems protocol)
               EV   - Event interfaces (EVDEV)

        * num_buttons = x
          Sets the number of mouse buttons viewed by Allegro.  You don't
          normally need to set this variable because Allegro will
          autodetect it.  You can only use it to restrict the set of
          actual mouse buttons to zero or positive values, negative
          values will be ignored.
        * emulate_three = x
          Sets whether to emulate a third mouse button by detecting
          chords of the left and right buttons (yes or no).  Defaults to
          no.
        * mouse_device = x
          Linux only: specifies the name of the mouse device file (eg.
          '/dev/mouse').
        * ev_absolute = x
          Linux only: specifies the mode for the default EV input: 0 -
          relative mode: pointer position changes if the input moves, 1
          - absolute mode: pointer position is the input position.  If
          unspecified, the mode is relative.  If the device supports
          several tools (such as a graphic tablet), the default input is
          the mouse.  If the device has only one tool (e.g.  a normal
          mouse) the default input is this tool.  All additional tools
          work in absolute mode.
        * ev_min_x = x
          ev_max_x = x
          ev_min_y = x
          ev_max_y = x
          ev_min_z = x
          ev_max_z = x
          Linux only: for absolute EV inputs, minimum and maximum value.
          By default this information is autodetected.  If you want to
          use only part of a tablet, you need to set the entries for X
          and Y axis by hand.
        * ev_abs_to_rel_x = x
          ev_abs_to_rel_y = x
          ev_abs_to_rel_z = x
          Linux only: scaling factor for tablet mouse speed.  Defaults
          to 1.  This is used only when the input sends absolute events
          (tablet, joystick, etc.)  and the cursor should behave like a
          mouse.  If you are using a mouse on a tablet, you need to set
          these entries for X and Y axis (try numbers between 1 and 40).
        * mouse_accel_factor = x
          Windows only: specifies the mouse acceleration factor.
          Defaults to 1.  Set it to 0 in order to disable mouse
          acceleration.  2 accelerates twice as much as 1.
   * [sound]
     Section containing sound configuration information, using the
     variables:

        * digi_card = x
          Sets the driver to use for playing digital samples.
        * midi_card = x
          Sets the driver to use for MIDI music.
        * digi_input_card = x
          Sets the driver to use for digital sample input.
        * midi_input_card = x
          Sets the driver to use for MIDI data input.
        * digi_voices = x
          Specifies the minimum number of voices to reserve for use by
          the digital sound driver.  How many are possible depends on
          the driver.
        * midi_voices = x
          Specifies the minimum number of voices to reserve for use by
          the MIDI sound driver.  How many are possible depends on the
          driver.
        * digi_volume = x
          Sets the volume for digital sample playback, from 0 to 255.
        * midi_volume = x
          Sets the volume for midi music playback, from 0 to 255.
        * quality = x
          Controls the sound quality vs.  performance tradeoff for the
          sample mixing code.  This can be set to any of the values:

               0 - fast mixing of 8-bit data into 16-bit buffers
               1 - true 16-bit mixing (requires a 16-bit stereo sound card)
               2 - interpolated 16-bit mixing

        * flip_pan = x
          Toggling this between 0 and 1 reverses the left/right panning
          of samples, which might be needed because some SB cards get
          the stereo image the wrong way round.
        * sound_freq = x
          DOS, Unix and BeOS: sets the sample frequency.  With the SB
          driver, possible rates are 11906 (any), 16129 (any), 22727 (SB
          2.0 and above), and 45454 (only on SB 2.0 or SB16, not the
          stereo SB Pro driver).  On the ESS Audiodrive, possible rates
          are 11363, 17046, 22729, or 44194.  On the Ensoniq Soundscape,
          possible rates are 11025, 16000, 22050, or 48000.  On the
          Windows Sound System, possible rates are 11025, 22050, 44100,
          or 48000.  Don't worry if you set some other number by
          mistake: Allegro will automatically round it to the closest
          supported frequency.
        * sound_bits = x
          Unix and BeOS: sets the preferred number of bits (8 or 16).
        * sound_stereo = x
          Unix and BeOS: selects mono or stereo output (0 or 1).
        * sound_port = x
          DOS only: sets the sound card port address (this is usually
          220).
        * sound_dma = x
          DOS only: sets the sound card DMA channel (this is usually 1).
        * sound_irq = x
          DOS only: sets the sound card IRQ number (this is usually 7).
        * fm_port = x
          DOS only: sets the port address of the OPL synth (this is
          usually 388).
        * mpu_port = x
          DOS only: sets the port address of the MPU-401 MIDI interface
          (this is usually 330).
        * mpu_irq = x
          DOS only: sets the IRQ for the MPU-401 (this is usually the
          same as sound_irq).
        * ibk_file = x
          DOS only: specifies the name of a .IBK file which will be used
          to replace the standard Adlib patch set.
        * ibk_drum_file = x
          DOS only: specifies the name of a .IBK file which will be used
          to replace the standard set of Adlib percussion patches.
        * oss_driver = x
          Unix only: sets the OSS device driver name.  Usually
          '/dev/dsp' or '/dev/audio', but could be a particular device
          (e.g.  '/dev/dsp2').
        * oss_numfrags = x
          oss_fragsize = x
          Unix only: sets number of OSS driver fragments (buffers) and
          size of each buffer in samples.  Buffers are filled with data
          in the interrupts where interval between subsequent interrupts
          is not less than 10 ms.  If hardware can play all information
          from buffers faster than 10 ms, then there will be clicks,
          when hardware have played all data and library has not
          prepared new data yet.  On the other hand, if it takes too
          long for device driver to play data from all buffers, then
          there will be delays between action which triggers sound and
          sound itself.
        * oss_midi_driver = x
          Unix only: sets the OSS MIDI device name.  Usually
          '/dev/sequencer'.
        * oss_mixer_driver = x
          Unix only: sets the OSS mixer device name.  Usually
          '/dev/mixer'.
        * esd_server = x
          Unix only: where to find the ESD (Enlightened Sound Daemon)
          server.
        * alsa_card = x
          alsa_pcmdevice = x
          Unix only: card number and PCM device for the ALSA 0.5 sound
          driver.
        * alsa_device = x
          Unix only: device name for the ALSA 0.9 sound driver.  The
          format is <driver>[:<card>,<device>], for example: 'hw:0,1'.
        * alsa_mixer_device = x
          Unix only: mixer device name for the ALSA 0.9 sound driver.
          The default is "default".
        * alsa_mixer_elem = x
          Unix only: mixer element name for the ALSA 0.9 driver.  The
          default is PCM.
        * alsa_numfrags = x
          Unix only: number of ALSA driver fragments (buffers).
        * alsa_fragsize = x
          Unix only: size of each ALSA fragment, in samples.
        * alsa_rawmidi_card = x
          Unix only: card number and device for the ALSA 0.5 midi
          driver.
        * alsa_rawmidi_device = x
          Unix only: device for the ALSA 0.5 midi driver or device name
          for the ALSA 0.9 midi driver (see alsa_device for the format).
        * jack_client_name = x
          Sets the name with which Allegro should identify itself to the
          Jack audio server.
        * jack_buffer_size = x
          Forces a buffer size for the transfer buffer from Allegro's
          mixer to Jack.
        * be_midi_quality = x
          BeOS only: system MIDI synthesizer instruments quality.  0
          uses low quality 8-bit 11 kHz samples, 1 uses 16-bit 22 kHz
          samples.
        * be_midi_freq = x
          BeOS only: MIDI sample mixing frequency in Hz.  Can be 11025,
          22050 or 44100.
        * be_midi_interpolation = x
          BeOS only: specifies the MIDI samples interpolation method.  0
          doesn't interpolate, it's fast but has the worst quality; 1
          does a fast interpolation with better performances, but it's a
          bit slower than the previous method; 2 does a linear
          interpolation between samples, it is the slowest method but
          gives the best performances.
        * be_midi_reverb = x
          BeOS only: reverberation intensity, from 0 to 5.  0 disables
          it, 5 is the strongest one.
        * ca_midi_quality = x
          MacOS X only: CoreAudio MIDI synthesizer rendering quality,
          from 0 to 127.  Higher qualities sound better but increase the
          CPU work load.
        * ca_midi_reverb = x
          MacOS X only: CoreAudio MIDI synthesizer reverberation
          intensity, from 0 to 5.  0 equals to a small room (low
          reverb), 5 to a plate (high reverb).
        * patches = x
          Specifies where to find the sample set for the DIGMID driver.
          This can either be a Gravis style directory containing a
          collection of .pat files and a 'default.cfg' index, or an
          Allegro datafile produced by the pat2dat utility.  If this
          variable is not set, Allegro will look either for a
          'default.cfg' or 'patches.dat' file in the same directory as
          the program, the directory pointed to by the ALLEGRO
          environment variable, and the standard GUS directory pointed
          to by the ULTRASND environment variable.
   * [midimap]
     If you are using the SB MIDI output or MPU-401 drivers with an
     external synthesiser that is not General MIDI compatible, you can
     use the midimap section of the config file to specify a patch
     mapping table for converting GM patch numbers into whatever bank
     and program change messages will select the appropriate sound on
     your synth.  This is a real piece of self-indulgence.  I have a
     Yamaha TG500, which has some great sounds but no GM patch set, and
     I just had to make it work somehow...

     This section consists of a set of lines in the form:

        * p<n> = bank0 bank1 prog pitch
          With this statement, n is the GM program change number
          (1-128), bank0 and bank1 are the two bank change messages to
          send to your synth (on controllers #0 and #32), prog is the
          program change message to send to your synth, and pitch is the
          number of semitones to shift everything that is played with
          that sound.  Setting the bank change numbers to -1 will
          prevent them from being sent.

          For example, the line:

               p36 = 0 34 9 12

          specifies that whenever GM program 36 (which happens to be a
          fretless bass) is selected, Allegro should send a bank change
          message #0 with a parameter of 0, a bank change message #32
          with a parameter of 34, a program change with a parameter of
          9, and then should shift everything up by an octave.
   * [joystick]
     Section containing joystick configuration information, using the
     variables:

        * joytype = x
          Specifies which joystick driver to use when the program
          requests JOY_TYPE_AUTODETECT.
        * joystick_device = x
          BeOS and Linux only: specifies the name of the joystick device
          to be used (as reported in the system joystick preferences
          under BeOS). The first device found is used by default.  If
          you want to specify the device for each joystick, use
          variables of the form joystick_device_n, where n is the
          joystick number.
        * throttle_axis = x
          Linux only: sets the axis number the throttle is located at.
          This variable will be used for every detected joystick.  If
          you want to specify the axis number for each joystick
          individually, use variables of the form throttle_axis_n, where
          n is the joystick number.

See also:
*Note set_config_file::.
*Note set_config_string::.
*Note get_config_string::.


File: allegro.info,  Node: Mouse,  Next: Timer,  Prev: Configuration,  Up: API

1.5 Mouse routines
==================

Allegro provides functions for reading the mouse state and displaying a
mouse cursor on-screen.  You can read the absolute position of the mouse
and the state of the mouse buttons from global variables.  Additionally,
you can read the mouse position difference as mouse mickeys, which is
the number of pixels the cursor moved since the last time this
information was read.

Allegro offers three ways to display the mouse cursor:

   * Standard Allegro cursor
     Allegro is responsible for drawing the mouse cursor from a timer.
     Use set_mouse_sprite() and show_mouse() to define your own cursor
     and display it on the screen.  You need to call
     scare_mouse()/unscare_mouse() to hide the mouse cursor whenever you
     draw to the screen.
   * Custom operating system cursor (hardware cursor)
     Allegro will let the operating system draw the mouse cursor.  Use
     set_mouse_sprite() and show_mouse() (or show_os_cursor) to define
     your own cursor and display it on the screen.  Not all graphics
     drivers are capable of this and some may only be able to display
     cursors up to a certain size.  Allegro will fall back on its own
     cursor drawing if it cannot let the OS handle this.  On some
     platforms, the hardware cursor is incompatible with
     get_mouse_mickeys() and it is therefor disabled by default.  In
     such cases you need to call enable_hardware_cursor() to enable it
     explicitly.
   * Default operating system cursor
     Allegro will not draw its own cursor, but use the operating system
     default cursor.  You can use the select_mouse_cursor() function to
     select the cursor shape to display.  As with custom operating
     system cursors, you need to call enable_hardware_cursor() before
     you can use this.  Or you can use the low level show_os_cursor()
     function.

Not all drivers will support all functionality.  See the platform
specific information for more details.

* Menu:

* install_mouse::
* remove_mouse::
* poll_mouse::
* mouse_needs_poll::
* enable_hardware_cursor::
* disable_hardware_cursor::
* select_mouse_cursor::
* set_mouse_cursor_bitmap::
* mouse_x::
* mouse_sprite::
* show_mouse::
* scare_mouse::
* scare_mouse_area::
* unscare_mouse::
* show_os_cursor::
* freeze_mouse_flag::
* position_mouse::
* position_mouse_z::
* position_mouse_w::
* set_mouse_range::
* set_mouse_speed::
* set_mouse_sprite::
* set_mouse_sprite_focus::
* get_mouse_mickeys::
* mouse_callback::
* mouse_on_screen::


File: allegro.info,  Node: install_mouse,  Next: remove_mouse,  Prev: Standard config variables,  Up: Mouse

1.5.1 install_mouse
-------------------

int install_mouse();
     Installs the Allegro mouse handler.  You must do this before using
     any other mouse functions.

     Returns -1 on failure, zero if the mouse handler is already
     installed (in which case this function does nothing) and the number
     of buttons on the mouse if the mouse handler has successfully been
     installed (ie.  this is the first time a handler is installed or
     you have removed the previous one).

     Note that the number of mouse buttons returned by this function is
     more an indication than a physical reality.  With most devices
     there is no way of telling how many buttons there are, and any user
     can override the number of mouse buttons returned by this function
     with a custom configuration file and the variable num_buttons.
     Even if this value is overridden by the user, the global mouse
     variables will still report whatever the hardware is sending.

See also:
*Note remove_mouse::.
*Note poll_mouse::.
*Note mouse_x::.
*Note show_mouse::.
*Note get_mouse_mickeys::.
*Note position_mouse::.
*Note set_mouse_range::.
*Note set_mouse_speed::.
*Note Standard config variables::.
*Note Available Allegro examples: Available.


File: allegro.info,  Node: remove_mouse,  Next: poll_mouse,  Prev: install_mouse,  Up: Mouse

1.5.2 remove_mouse
------------------

void remove_mouse();
     Removes the mouse handler.  You don't normally need to bother
     calling this, because allegro_exit() will do it for you.

See also:
*Note install_mouse::.
*Note allegro_exit::.


File: allegro.info,  Node: poll_mouse,  Next: mouse_needs_poll,  Prev: remove_mouse,  Up: Mouse

1.5.3 poll_mouse
----------------

int poll_mouse();
     Wherever possible, Allegro will read the mouse input asynchronously
     (ie.  from inside an interrupt handler), but on some platforms that
     may not be possible, in which case you must call this routine at
     regular intervals to update the mouse state variables.  To help you
     test your mouse polling code even if you are programming on a
     platform that doesn't require it, after the first time that you
     call this function Allegro will switch into polling mode, so from
     that point onwards you will have to call this routine in order to
     get any mouse input at all, regardless of whether the current
     driver actually needs to be polled or not.

     Returns zero on success, or a negative number on failure (ie.  no
     mouse driver installed).

See also:
*Note mouse_needs_poll::.
*Note install_mouse::.
*Note mouse_x::.
*Note exlights::.
*Note exmouse::.
*Note exshade::.
*Note exspline::.
*Note extrans::.


File: allegro.info,  Node: mouse_needs_poll,  Next: enable_hardware_cursor,  Prev: poll_mouse,  Up: Mouse

1.5.4 mouse_needs_poll
----------------------

int mouse_needs_poll();
     Returns TRUE if the current mouse driver is operating in polling
     mode.

See also:
*Note poll_mouse::.
*Note install_mouse::.
*Note mouse_x::.


File: allegro.info,  Node: enable_hardware_cursor,  Next: disable_hardware_cursor,  Prev: mouse_needs_poll,  Up: Mouse

1.5.5 enable_hardware_cursor
----------------------------

void enable_hardware_cursor(void);
     After calling this function, Allegro will let the operating system
     draw the mouse cursor instead of doing it itself.  This is not
     possible with all graphics drivers though: you'll need to check the
     gfx_capabilities flags after calling show_mouse() to see if this
     works.  On some platforms, enabling the hardware cursor causes
     get_mouse_mickeys() to return only a limited range of values, so
     you should not call this function if you need mouse mickeys.

See also:
*Note install_mouse::.
*Note show_mouse::.
*Note set_mouse_sprite::.
*Note get_mouse_mickeys::.
*Note gfx_capabilities::.
*Note disable_hardware_cursor::.
*Note show_os_cursor::.
*Note exsyscur::.


File: allegro.info,  Node: disable_hardware_cursor,  Next: select_mouse_cursor,  Prev: enable_hardware_cursor,  Up: Mouse

1.5.6 disable_hardware_cursor
-----------------------------

void disable_hardware_cursor(void);
     After calling this function, Allegro will be responsible for
     drawing the mouse cursor rather than the operating system.  On some
     platforms calling enable_hardware_cursor() makes the return values
     of get_mouse_mickeys() unreliable.  After calling this function,
     get_mouse_mickeys() returns reliable results again.

See also:
*Note install_mouse::.
*Note show_mouse::.
*Note set_mouse_sprite::.
*Note get_mouse_mickeys::.
*Note gfx_capabilities::.
*Note enable_hardware_cursor::.


File: allegro.info,  Node: select_mouse_cursor,  Next: set_mouse_cursor_bitmap,  Prev: disable_hardware_cursor,  Up: Mouse

1.5.7 select_mouse_cursor
-------------------------

void select_mouse_cursor(int cursor);
     This function allows you to use the operating system's native mouse
     cursors rather than some custom cursor.  You will need to enable
     this functionality by calling enable_hardware_cursor() beforehand.
     If the operating system does not support this functionality, or if
     it has not been enabled, then Allegro will substitute its own
     cursor images.  You can change these substitute images using
     set_mouse_cursor_bitmap().

     Note that the effects of this function are not apparent until
     show_mouse() is called.

     To know whether the operating system's native cursor is being used,
     or if Allegro has made a substitution, you can check the
     GFX_SYSTEM_CURSOR flag in gfx_capabilities after calling
     show_mouse().

     The cursor argument selects the type of cursor to be displayed:

     MOUSE_CURSOR_NONE
     Selects an invisible mouse cursor.  In that sense, it is similar to
     calling show_mouse(NULL);

     MOUSE_CURSOR_ALLEGRO
     Selects the custom Allegro cursor, i.e.  the one that you set with
     set_mouse_sprite().

     MOUSE_CURSOR_ARROW
     The operating system default arrow cursor.

     MOUSE_CURSOR_BUSY
     The operating system default 'busy' cursor (hourglass).

     MOUSE_CURSOR_QUESTION
     The operating system default 'question' cursor (arrow with question
     mark).

     MOUSE_CURSOR_EDIT
     The operating system default 'edit' cursor (vertical bar).

     Example:

          /* initialize mouse sub-system */
          install_mouse();
          enable_hardware_cursor();

          /* Set busy pointer */
          select_mouse_cursor(MOUSE_CURSOR_BUSY);
          show_mouse(screen);

          /* Initialize stuff */
          ...

          /* Set normal arrow pointer */
          select_mouse_cursor(MOUSE_CURSOR_ARROW);

See also:
*Note install_mouse::.
*Note show_mouse::.
*Note set_mouse_sprite::.
*Note gfx_capabilities::.
*Note enable_hardware_cursor::.
*Note set_mouse_cursor_bitmap::.
*Note show_os_cursor::.
*Note exsyscur::.


File: allegro.info,  Node: set_mouse_cursor_bitmap,  Next: mouse_x,  Prev: select_mouse_cursor,  Up: Mouse

1.5.8 set_mouse_cursor_bitmap
-----------------------------

void set_mouse_cursor_bitmap(int cursor, BITMAP *bmp);
     This function changes the cursor image Allegro uses if
     select_mouse_cursor() is called but no native operating system
     cursor can be used, e.g.  because you did not call
     enable_hardware_cursor().

     The cursor argument can be one of:
     MOUSE_CURSOR_ALLEGRO
     MOUSE_CURSOR_ARROW
     MOUSE_CURSOR_BUSY
     MOUSE_CURSOR_QUESTION
     MOUSE_CURSOR_EDIT

     but not MOUSE_CURSOR_NONE.

     The bmp argument can either point to a valid bitmap or it can be
     NULL. Passing a bitmap makes Allegro use that image in place of its
     own default substitution (should the operating system's native
     cursor be unavailable).  The bitmap must remain available for the
     duration in which it could be used.  Passing NULL lets Allegro
     revert to its default substitutions.

     The effect of this function will not be apparent until show_mouse()
     is called.

See also:
*Note install_mouse::.
*Note show_mouse::.
*Note set_mouse_sprite::.
*Note gfx_capabilities::.
*Note enable_hardware_cursor::.
*Note show_os_cursor::.
*Note BITMAP::.


File: allegro.info,  Node: mouse_x,  Next: mouse_sprite,  Prev: set_mouse_cursor_bitmap,  Up: Mouse

1.5.9 mouse_x
-------------

extern volatile int mouse_x;
extern volatile int mouse_y;
extern volatile int mouse_z;
extern volatile int mouse_w;
extern volatile int mouse_b;
extern volatile int mouse_pos;
     Global variables containing the current mouse position and button
     state.  Wherever possible these values will be updated
     asynchronously, but if mouse_needs_poll() returns TRUE, you must
     manually call poll_mouse() to update them with the current input
     state.  The 'mouse_x' and 'mouse_y' positions are integers ranging
     from zero to the bottom right corner of the screen.  The 'mouse_z'
     and 'mouse_w' variables hold the current vertical and horizontal
     wheel position, when using an input driver that supports wheel
     mice.  The 'mouse_b' variable is a bitfield indicating the state of
     each button: bit 0 is the left button, bit 1 the right, and bit 2
     the middle button.  Additional non standard mouse buttons might be
     available as higher bits in this variable.  Usage example:

          if (mouse_b & 1)
             printf("Left button is pressed\n");

          if (!(mouse_b & 2))
             printf("Right button is not pressed\n");

     The 'mouse_pos' variable has the current X coordinate in the upper
     16 bits and the Y in the lower 16 bits.  This may be useful in
     tight polling loops where a mouse interrupt could occur between
     your reading of the two separate variables, since you can copy this
     value into a local variable with a single instruction and then
     split it up at your leisure.  Example:

          int pos, x, y;

          pos = mouse_pos;
          x = pos >> 16;
          y = pos & 0x0000ffff;

See also:
*Note install_mouse::.
*Note poll_mouse::.
*Note mouse_needs_poll::.
*Note exalpha::.
*Note exlights::.
*Note exmouse::.
*Note exshade::.
*Note exspline::.
*Note extrans::.


File: allegro.info,  Node: mouse_sprite,  Next: show_mouse,  Prev: mouse_x,  Up: Mouse

1.5.10 mouse_sprite
-------------------

extern BITMAP *mouse_sprite;
extern int mouse_x_focus;
extern int mouse_y_focus;
     Global variables containing the current mouse sprite and the focus
     point.  These are read-only, and only to be modified using the
     set_mouse_sprite() and set_mouse_sprite_focus() functions.

See also:
*Note set_mouse_sprite::.
*Note set_mouse_sprite_focus::.
*Note BITMAP::.


File: allegro.info,  Node: show_mouse,  Next: scare_mouse,  Prev: mouse_sprite,  Up: Mouse

1.5.11 show_mouse
-----------------

void show_mouse(BITMAP *bmp);
     Tells Allegro to display a mouse pointer on the screen.  This will
     only work if the timer module has been installed.  The mouse
     pointer will be drawn onto the specified bitmap, which should
     normally be 'screen' (see later for information about bitmaps).  To
     hide the mouse pointer, call show_mouse(NULL).

     Warning: if you draw anything onto the screen while the pointer is
     visible, a mouse movement interrupt could occur in the middle of
     your drawing operation.  If this happens the mouse buffering and
     graphics drawing code will get confused and will leave 'mouse
     droppings' all over the screen.  To prevent this, you must make
     sure you turn off the mouse pointer whenever you draw onto the
     screen.  This is not needed if you are using a hardware cursor.

     Note: you must not be showing a mouse pointer on a bitmap at the
     time that the bitmap is destroyed with destroy_bitmap(), e.g.  call
     show_mouse(NULL); before destroying the bitmap.  This does not
     apply to 'screen' since you never destroy 'screen' with
     destroy_bitmap().

See also:
*Note install_mouse::.
*Note install_timer::.
*Note set_mouse_sprite::.
*Note scare_mouse::.
*Note freeze_mouse_flag::.
*Note show_os_cursor::.
*Note exmouse::.
*Note expal::.
*Note exshade::.
*Note exspline::.
*Note exsyscur::.
*Note BITMAP::.


File: allegro.info,  Node: scare_mouse,  Next: scare_mouse_area,  Prev: show_mouse,  Up: Mouse

1.5.12 scare_mouse
------------------

void scare_mouse();
     Helper for hiding the mouse pointer prior to a drawing operation.
     This will temporarily get rid of the pointer, but only if that is
     really required (ie.  the mouse is visible, and is displayed on the
     physical screen rather than some other memory surface, and it is
     not a hardware or OS cursor).  The previous mouse state is stored
     for subsequent calls to unscare_mouse().

See also:
*Note unscare_mouse::.
*Note scare_mouse_area::.
*Note show_mouse::.


File: allegro.info,  Node: scare_mouse_area,  Next: unscare_mouse,  Prev: scare_mouse,  Up: Mouse

1.5.13 scare_mouse_area
-----------------------

void scare_mouse_area(int x, int y, int w, int h);
     Like scare_mouse(), but will only hide the cursor if it is inside
     the specified rectangle.  Otherwise the cursor will simply be
     frozen in place until you call unscare_mouse(), so it cannot
     interfere with your drawing.

See also:
*Note unscare_mouse::.
*Note scare_mouse::.
*Note show_mouse::.


File: allegro.info,  Node: unscare_mouse,  Next: show_os_cursor,  Prev: scare_mouse_area,  Up: Mouse

1.5.14 unscare_mouse
--------------------

void unscare_mouse();
     Undoes the effect of a previous call to scare_mouse() or
     scare_mouse_area(), restoring the original pointer state.

See also:
*Note scare_mouse::.
*Note scare_mouse_area::.


File: allegro.info,  Node: show_os_cursor,  Next: freeze_mouse_flag,  Prev: unscare_mouse,  Up: Mouse

1.5.15 show_os_cursor
---------------------

int show_os_cursor(int cursor);
     In case you do not need Allegro's mouse cursor API, which
     automatically emulates a cursor in software if no other cursor is
     available, you can use this low level function to try to display or
     hide the system cursor directly.  The cursor parameter takes the
     same values as select_mouse_cursor.  This function is very similar
     to calling enable_hardware_cursor, select_mouse_cursor and
     show_mouse, but will not try to do anything if no system cursor is
     available.

     The most common use for this function is to just call it once at
     the beginning of the program to tell it to display the system
     cursor inside the Allegro window.  The return value can be used to
     see if this succeeded or not.  On some systems (e.g.  DirectX
     fullscreen) this is not supported and the function will always
     fail, and in other cases only some of the cursors will work, or in
     the case of MOUSE_CURSOR_ALLEGRO, only certain bitmap sizes may be
     supported.

     You never should use show_os_cursor together with the function
     show_mouse and other functions affecting it (select_mouse_cursor,
     enable_hardware_cursor, disable_hardware_cursor, scare_mouse,
     unscare_mouse).  They implement the standard high level mouse API,
     and don't work together with this low level function.

     Returns 0 if a system cursor is being displayed after the function
     returns, or -1 otherwise.

See also:
*Note show_mouse::.
*Note set_mouse_cursor_bitmap::.
*Note select_mouse_cursor::.


File: allegro.info,  Node: freeze_mouse_flag,  Next: position_mouse,  Prev: show_os_cursor,  Up: Mouse

1.5.16 freeze_mouse_flag
------------------------

extern volatile int freeze_mouse_flag;
     If this flag is set, the mouse pointer won't be redrawn when the
     mouse moves.  This can avoid the need to hide the pointer every
     time you draw to the screen, as long as you make sure your drawing
     doesn't overlap with the current pointer position.

See also:
*Note show_mouse::.


File: allegro.info,  Node: position_mouse,  Next: position_mouse_z,  Prev: freeze_mouse_flag,  Up: Mouse

1.5.17 position_mouse
---------------------

void position_mouse(int x, int y);
     Moves the mouse to the specified screen position.  It is safe to
     call even when a mouse pointer is being displayed.

See also:
*Note install_mouse::.
*Note position_mouse_z::.
*Note set_mouse_range::.
*Note set_mouse_speed::.
*Note position_mouse_w::.


File: allegro.info,  Node: position_mouse_z,  Next: position_mouse_w,  Prev: position_mouse,  Up: Mouse

1.5.18 position_mouse_z
-----------------------

void position_mouse_z(int z);
     Sets the mouse wheel position variable to the specified value.

See also:
*Note install_mouse::.
*Note position_mouse::.
*Note position_mouse_w::.


File: allegro.info,  Node: position_mouse_w,  Next: set_mouse_range,  Prev: position_mouse_z,  Up: Mouse

1.5.19 position_mouse_w
-----------------------

void position_mouse_w(int w);
     Sets the horizontal mouse wheel position to the specified value.

See also:
*Note install_mouse::.
*Note position_mouse::.


File: allegro.info,  Node: set_mouse_range,  Next: set_mouse_speed,  Prev: position_mouse_w,  Up: Mouse

1.5.20 set_mouse_range
----------------------

void set_mouse_range(int x1, int y1, int x2, int y2);
     Sets the area of the screen within which the mouse can move.  Pass
     the top left corner and the bottom right corner (inclusive).  If
     you don't call this function the range defaults to (0, 0,
     SCREEN_W-1, SCREEN_H-1).

See also:
*Note install_mouse::.
*Note set_mouse_speed::.
*Note position_mouse::.


File: allegro.info,  Node: set_mouse_speed,  Next: set_mouse_sprite,  Prev: set_mouse_range,  Up: Mouse

1.5.21 set_mouse_speed
----------------------

void set_mouse_speed(int xspeed, int yspeed);
     Sets the mouse speed.  Larger values of xspeed and yspeed represent
     slower mouse movement: the default for both is 2.

See also:
*Note install_mouse::.
*Note set_mouse_range::.
*Note position_mouse::.


File: allegro.info,  Node: set_mouse_sprite,  Next: set_mouse_sprite_focus,  Prev: set_mouse_speed,  Up: Mouse

1.5.22 set_mouse_sprite
-----------------------

void set_mouse_sprite(BITMAP *sprite);
     You don't like Allegro's mouse pointer?  No problem.  Use this
     function to supply an alternative of your own.  If you change the
     pointer and then want to get Allegro's lovely arrow back again,
     call set_mouse_sprite(NULL).

     As a bonus, set_mouse_sprite(NULL) uses the current palette in
     choosing colors for the arrow.  So if your arrow mouse sprite looks
     ugly after changing the palette, call set_mouse_sprite(NULL).

See also:
*Note install_mouse::.
*Note show_mouse::.
*Note set_mouse_sprite_focus::.
*Note exmouse::.
*Note BITMAP::.


File: allegro.info,  Node: set_mouse_sprite_focus,  Next: get_mouse_mickeys,  Prev: set_mouse_sprite,  Up: Mouse

1.5.23 set_mouse_sprite_focus
-----------------------------

void set_mouse_sprite_focus(int x, int y);
     The mouse focus is the bit of the pointer that represents the
     actual mouse position, ie.  the (mouse_x, mouse_y) position.  By
     default this is the top left corner of the arrow, but if you are
     using a different mouse pointer you might need to alter it.

See also:
*Note set_mouse_sprite::.
*Note exmouse::.


File: allegro.info,  Node: get_mouse_mickeys,  Next: mouse_callback,  Prev: set_mouse_sprite_focus,  Up: Mouse

1.5.24 get_mouse_mickeys
------------------------

void get_mouse_mickeys(int *mickeyx, int *mickeyy);
     Measures how far the mouse has moved since the last call to this
     function.  The values of mickeyx and mickeyy will become negative
     if the mouse is moved left or up, respectively.  The mouse will
     continue to generate movement mickeys even when it reaches the edge
     of the screen, so this form of input can be useful for games that
     require an infinite range of mouse movement.

     Note that the infinite movement may not work in windowed mode,
     since under some platforms the mouse would leave the window, and
     may not work at all if the hardware cursor is in use.

See also:
*Note install_mouse::.
*Note exmouse::.


File: allegro.info,  Node: mouse_callback,  Next: mouse_on_screen,  Prev: get_mouse_mickeys,  Up: Mouse

1.5.25 mouse_callback
---------------------

extern void (*mouse_callback)(int flags);
     Called by the interrupt handler whenever the mouse moves or one of
     the buttons changes state.  This function must be in locked memory,
     and must execute _very_ quickly!  It is passed the event flags that
     triggered the call, which is a bitmask containing any of the values
     MOUSE_FLAG_MOVE, MOUSE_FLAG_LEFT_DOWN, MOUSE_FLAG_LEFT_UP,
     MOUSE_FLAG_RIGHT_DOWN, MOUSE_FLAG_RIGHT_UP, MOUSE_FLAG_MIDDLE_DOWN,
     MOUSE_FLAG_MIDDLE_UP, and MOUSE_FLAG_MOVE_Z. Note that even if the
     mouse has more than three buttons, only the first three can be
     trapped using a callback.

See also:
*Note install_mouse::.


File: allegro.info,  Node: mouse_on_screen,  Next: install_timer,  Prev: mouse_callback,  Up: Mouse

1.5.26 mouse_on_screen
----------------------

int mouse_on_screen();
     This function can be useful to prevent having two mouse pointers on
     the screen at the same time when running your program in windowed
     mode and drawing the mouse pointer yourself.  Other possible uses
     include the ability to pause your game when the mouse goes off of
     the window, or only scrolling the view when the pointer is near the
     edge of the window, but not while off of the window.

     Example :

          if (mouse_on_screen()) {draw_sprite(buffer , mouse_sprite , mouse_x , mouse_y);}

     Returns 0 if the mouse pointer is off of the screen, or non-zero
     otherwise.


File: allegro.info,  Node: Timer,  Next: Keyboard,  Prev: Mouse,  Up: API

1.6 Timer routines
==================

Allegro can set up several virtual timer functions, all going at
different speeds.

Under DOS it will constantly reprogram the clock to make sure they are
all called at the correct times.  Because they alter the low level timer
chip settings, these routines should not be used together with other DOS
timer functions like the DJGPP uclock() routine.  Moreover, the FPU
state is not preserved across Allegro interrupts so you ought not to use
floating point or MMX code inside timer interrupt handlers.

Under other platforms, they are usually implemented using threads, which
run parallel to the main thread.  Therefore timer callbacks on such
platforms will not block the main thread when called, so you may need to
use appropriate synchronisation devices (eg.  mutexes, semaphores, etc.)
when accessing data that is shared by a callback and the main thread.
(Currently Allegro does not provide such devices.)

* Menu:

* install_timer::
* remove_timer::
* install_int::
* install_int_ex::
* LOCK_VARIABLE::
* LOCK_FUNCTION::
* END_OF_FUNCTION::
* remove_int::
* install_param_int::
* install_param_int_ex::
* remove_param_int::
* retrace_count::
* rest::
* rest_callback::


File: allegro.info,  Node: install_timer,  Next: remove_timer,  Prev: mouse_on_screen,  Up: Timer

1.6.1 install_timer
-------------------

int install_timer();
     Installs the Allegro timer interrupt handler.  You must do this
     before installing any user timer routines, and also before
     displaying a mouse pointer, playing FLI animations or MIDI music,
     and using any of the GUI routines.

     Returns zero on success, or a negative number on failure (but you
     may decide not to check the return value as this function is very
     unlikely to fail).

See also:
*Note remove_timer::.
*Note install_int::.
*Note Available Allegro examples: Available.


File: allegro.info,  Node: remove_timer,  Next: install_int,  Prev: install_timer,  Up: Timer

1.6.2 remove_timer
------------------

void remove_timer();
     Removes the Allegro timer handler (and, under DOS, passes control
     of the clock back to the operating system).  You don't normally
     need to bother calling this, because allegro_exit() will do it for
     you.

See also:
*Note install_timer::.
*Note allegro_exit::.


File: allegro.info,  Node: install_int,  Next: install_int_ex,  Prev: remove_timer,  Up: Timer

1.6.3 install_int
-----------------

int install_int(void (*proc)(), int speed);
     Installs a user timer handler, with the speed given as the number
     of milliseconds between ticks.  This is the same thing as
     install_int_ex(proc, MSEC_TO_TIMER(speed)).  If you call this
     routine without having first installed the timer module,
     install_timer() will be called automatically.  Calling again this
     routine with the same timer handler as parameter allows you to
     adjust its speed.

     Returns zero on success, or a negative number if there is no room
     to add a new user timer.

See also:
*Note install_timer::.
*Note remove_int::.
*Note install_int_ex::.
*Note install_param_int::.
*Note exscn3d::.
*Note exswitch::.
*Note extimer::.
*Note exzbuf::.


File: allegro.info,  Node: install_int_ex,  Next: LOCK_VARIABLE,  Prev: install_int,  Up: Timer

1.6.4 install_int_ex
--------------------

int install_int_ex(void (*proc)(), int speed);
     Adds a function to the list of user timer handlers or, if it is
     already installed, retroactively adjusts its speed (i.e makes as
     though the speed change occurred precisely at the last tick).  The
     speed is given in hardware clock ticks, of which there are 1193181
     a second.  You can convert from other time formats to hardware
     clock ticks with the macros:

          SECS_TO_TIMER(secs)  - give the number of seconds between
                                 each tick
          MSEC_TO_TIMER(msec)  - give the number of milliseconds
                                 between ticks
          BPS_TO_TIMER(bps)    - give the number of ticks each second
          BPM_TO_TIMER(bpm)    - give the number of ticks per minute

     There can only be sixteen timers in use at a time, and some other
     parts of Allegro (the GUI code, the mouse pointer display routines,
     rest(), the FLI player, and the MIDI player) need to install
     handlers of their own, so you should avoid using too many at the
     same time.  If you call this routine without having first installed
     the timer module, install_timer() will be called automatically.

     Your function will be called by the Allegro interrupt handler and
     not directly by the processor, so it can be a normal C function and
     does not need a special wrapper.  You should be aware, however,
     that it will be called in an interrupt context, which imposes a lot
     of restrictions on what you can do in it.  It should not use large
     amounts of stack, it must not make any calls to the operating
     system, use C library functions, or contain any floating point
     code, and it must execute very quickly.  Don't try to do lots of
     complicated code in a timer handler: as a general rule you should
     just set some flags and respond to these later in your main control
     loop.

     In a DOS protected mode environment like DJGPP, memory is
     virtualised and can be swapped to disk.  Due to the non-reentrancy
     of DOS, if a disk swap occurs inside an interrupt handler the
     system will die a painful death, so you need to make sure you lock
     all the memory (both code and data) that is touched inside timer
     routines.  Allegro will lock everything it uses, but you are
     responsible for locking your handler functions.  The macros
     LOCK_VARIABLE (variable), END_OF_FUNCTION (function_name),
     END_OF_STATIC_FUNCTION (function_name), and LOCK_FUNCTION
     (function_name) can be used to simplify this task.  For example, if
     you want an interrupt handler that increments a counter variable,
     you should write:

          volatile int counter;

          void my_timer_handler()
          {
             counter++;
          }

          END_OF_FUNCTION(my_timer_handler)

     and in your initialisation code you should lock the memory:

          LOCK_VARIABLE(counter);
          LOCK_FUNCTION(my_timer_handler);

     Obviously this can get awkward if you use complicated data
     structures and call other functions from within your handler, so
     you should try to keep your interrupt routines as simple as
     possible.

     Returns zero on success, or a negative number if there is no room
     to add a new user timer.

See also:
*Note install_timer::.
*Note remove_int::.
*Note install_int::.
*Note install_param_int_ex::.
*Note excamera::.
*Note exsprite::.
*Note extimer::.
*Note exunicod::.
*Note exupdate::.


File: allegro.info,  Node: LOCK_VARIABLE,  Next: LOCK_FUNCTION,  Prev: install_int_ex,  Up: Timer

1.6.5 LOCK_VARIABLE
-------------------

Macro LOCK_VARIABLE(variable_name);
     Due to interrupts, you are required to lock all the memory used by
     your timer routines.  See the description of install_int_ex() for a
     more detailed explanation and usage example.

See also:
*Note install_int::.
*Note install_int_ex::.
*Note exscn3d::.
*Note exsprite::.
*Note exswitch::.
*Note extimer::.
*Note exupdate::.
*Note exzbuf::.


File: allegro.info,  Node: LOCK_FUNCTION,  Next: END_OF_FUNCTION,  Prev: LOCK_VARIABLE,  Up: Timer

1.6.6 LOCK_FUNCTION
-------------------

Macro LOCK_FUNCTION(function_name);
     Due to interrupts, you are required to lock all the memory used by
     your timer routines.  See the description of install_int_ex() for a
     more detailed explanation and usage example.

See also:
*Note install_int::.
*Note install_int_ex::.
*Note exkeys::.
*Note exscn3d::.
*Note exsprite::.
*Note exswitch::.
*Note extimer::.
*Note exupdate::.
*Note exzbuf::.


File: allegro.info,  Node: END_OF_FUNCTION,  Next: remove_int,  Prev: LOCK_FUNCTION,  Up: Timer

1.6.7 END_OF_FUNCTION
---------------------

Macro END_OF_FUNCTION(function_name);
     Due to interrupts, you are required to lock all the code used by
     your timer routines.  See the description of install_int_ex() for a
     more detailed explanation and usage example.

See also:
*Note install_int::.
*Note install_int_ex::.
*Note exkeys::.
*Note exscn3d::.
*Note exsprite::.
*Note exswitch::.
*Note extimer::.
*Note exupdate::.
*Note exzbuf::.


File: allegro.info,  Node: remove_int,  Next: install_param_int,  Prev: END_OF_FUNCTION,  Up: Timer

1.6.8 remove_int
----------------

void remove_int(void (*proc)());
     Removes a function from the list of user interrupt routines.  At
     program termination, allegro_exit() does this automatically.

See also:
*Note install_int::.
*Note install_int_ex::.
*Note remove_param_int::.


File: allegro.info,  Node: install_param_int,  Next: install_param_int_ex,  Prev: remove_int,  Up: Timer

1.6.9 install_param_int
-----------------------

int install_param_int(void (*proc)(void *), void *param, int speed);
     Like install_int(), but the callback routine will be passed a copy
     of the specified void pointer parameter.  To disable the handler,
     use remove_param_int() instead of remove_int().

See also:
*Note install_timer::.
*Note remove_param_int::.
*Note install_param_int_ex::.
*Note install_int::.


File: allegro.info,  Node: install_param_int_ex,  Next: remove_param_int,  Prev: install_param_int,  Up: Timer

1.6.10 install_param_int_ex
---------------------------

int install_param_int_ex(void (*proc)(void *), void *param, int speed);
     Like install_int_ex(), but the callback routine will be passed a
     copy of the specified void pointer parameter.  To disable the
     handler, use remove_param_int() instead of remove_int().

See also:
*Note install_timer::.
*Note remove_param_int::.
*Note install_param_int::.
*Note install_int_ex::.


File: allegro.info,  Node: remove_param_int,  Next: retrace_count,  Prev: install_param_int_ex,  Up: Timer

1.6.11 remove_param_int
-----------------------

void remove_param_int(void (*proc)(void *), void *param);
     Like remove_int(), but for use with timer callbacks that have
     parameter values.  If there is more than one copy of the same
     callback active at a time, it identifies which one to remove by
     checking the parameter value (so you can't have more than one copy
     of a handler using an identical parameter).

See also:
*Note install_param_int::.
*Note install_param_int_ex::.
*Note remove_int::.


File: allegro.info,  Node: retrace_count,  Next: rest,  Prev: remove_param_int,  Up: Timer

1.6.12 retrace_count
--------------------

extern volatile int retrace_count;
     If the retrace simulator is installed, this count is incremented on
     each vertical retrace; otherwise, if the refresh rate is known, the
     count is incremented at the same rate (ignoring retraces);
     otherwise, it is incremented 70 times a second.  This provides a
     way of controlling the speed of your program without installing
     user timer functions.

See also:
*Note ex3d::.
*Note exblend::.
*Note exdbuf::.
*Note exflip::.
*Note exlights::.


File: allegro.info,  Node: rest,  Next: rest_callback,  Prev: retrace_count,  Up: Timer

1.6.13 rest
-----------

void rest(unsigned int time);
     This function waits for the specified number of milliseconds.

     Passing 0 as parameter will not wait, but just yield.  This can be
     useful in order to "play nice" with other processes.  Other values
     will cause CPU time to be dropped on most platforms.  This will
     look better to users, and also does things like saving battery
     power and making fans less noisy.

     Note that calling this inside your active game loop is a bad idea,
     as you never know when the OS will give you the CPU back, so you
     could end up missing the vertical retrace and skipping frames.  On
     the other hand, on multitasking operating systems it is good form
     to give up the CPU for a while if you will not be using it.

See also:
*Note install_timer::.
*Note rest_callback::.
*Note vsync::.
*Note d_yield_proc::.
*Note Available Allegro examples: Available.


File: allegro.info,  Node: rest_callback,  Next: install_keyboard,  Prev: rest,  Up: Timer

1.6.14 rest_callback
--------------------

void rest_callback(long time, void (*callback)())
     Like rest(), but for non-zero values continually calls the
     specified function while it is waiting for the required time to
     elapse.  If the provided 'callback' parameter is NULL, this
     function does exactly the same thing as calling rest().

See also:
*Note install_timer::.
*Note rest::.


File: allegro.info,  Node: Keyboard,  Next: Joystick,  Prev: Timer,  Up: API

1.7 Keyboard routines
=====================

The Allegro keyboard handler provides both buffered input and a set of
flags storing the current state of each key.  Note that it is not
possible to correctly detect every combination of keys, due to the
design of the PC keyboard.  Up to two or three keys at a time will work
fine, but if you press more than that the extras are likely to be
ignored (exactly which combinations are possible seems to vary from one
keyboard to another).

On DOS, Allegro requires the user to specify the language of the
keyboard mapping because it is impossible to obtain this information
from the OS, otherwise the default US keyboard mapping will be used.
Allegro comes with a prepackaged 'keyboard.dat' file which you can put
along with your binary.  If this file is present, Allegro will be able
to extract the keyboard mapping information stored there.  However, the
end user still needs to select which keyboard mapping to use.  This can
be accomplished through the keyboard variable of the system section in a
standard 'allegro.cfg' configuration file.  Read chapter "Configuration
routines" for more information about this.

* Menu:

* install_keyboard::
* remove_keyboard::
* install_keyboard_hooks::
* poll_keyboard::
* keyboard_needs_poll::
* key::
* key_shifts::
* keypressed::
* readkey::
* ureadkey::
* scancode_to_ascii::
* scancode_to_name::
* simulate_keypress::
* simulate_ukeypress::
* keyboard_callback::
* keyboard_ucallback::
* keyboard_lowlevel_callback::
* set_leds::
* set_keyboard_rate::
* clear_keybuf::
* three_finger_flag::
* key_led_flag::


File: allegro.info,  Node: install_keyboard,  Next: remove_keyboard,  Prev: rest_callback,  Up: Keyboard

1.7.1 install_keyboard
----------------------

int install_keyboard();
     Installs the Allegro keyboard interrupt handler.  You must call
     this before using any of the keyboard input routines.  Once you
     have set up the Allegro handler, you can no longer use operating
     system calls or C library functions to access the keyboard.

     Note that on some platforms the keyboard won't work unless you have
     set a graphics mode, even if this function returns a success value
     before calling set_gfx_mode.  This can happen in environments with
     graphic windowed modes, since Allegro usually reads the keyboard
     through the graphical window (which appears after the set_gfx_mode
     call).  Example:

          allegro_init();
          install_timer();
          install_keyboard();
          /* We are not 100% sure we can read the keyboard yet! */
          if (set_gfx_mode(GFX_AUTODETECT, 640, 480, 0, 0) != 0)
             abort_on_error("Couldn't set graphic mode!");

          /* Now we are guaranteed to be able to read the keyboard. */
          readkey();

     Returns zero on success, or a negative number on failure (but you
     may decide not to check the return value as this function is very
     unlikely to fail).

See also:
*Note remove_keyboard::.
*Note poll_keyboard::.
*Note key::.
*Note keypressed::.
*Note readkey::.
*Note ureadkey::.
*Note keyboard_callback::.
*Note keyboard_ucallback::.
*Note keyboard_lowlevel_callback::.
*Note three_finger_flag::.
*Note key_led_flag::.
*Note set_leds::.
*Note set_keyboard_rate::.
*Note set_gfx_mode::.
*Note Standard config variables::.
*Note Available Allegro examples: Available.


File: allegro.info,  Node: remove_keyboard,  Next: install_keyboard_hooks,  Prev: install_keyboard,  Up: Keyboard

1.7.2 remove_keyboard
---------------------

void remove_keyboard();
     Removes the keyboard handler, returning control to the operating
     system.  You don't normally need to bother calling this, because
     allegro_exit() will do it for you.  However, you might want to call
     this during runtime if you want to change the keyboard mapping on
     those platforms were keyboard mappings are needed.  You would first
     modify the configuration variable holding the keyboard mapping and
     then reinstall the keyboard handler.  Example:

          remove_keyboard();
          /* Switch to Spanish keyboard mapping. */
          set_config_string("system", "keyboard", "es");
          install_keyboard();

See also:
*Note install_keyboard::.
*Note allegro_exit::.
*Note set_config_string::.


File: allegro.info,  Node: install_keyboard_hooks,  Next: poll_keyboard,  Prev: remove_keyboard,  Up: Keyboard

1.7.3 install_keyboard_hooks
----------------------------

void install_keyboard_hooks(int (*keypressed)(), int (*readkey)());
     You should only use this function if you *aren't* using the rest of
     the keyboard handler.  It should be called in the place of
     install_keyboard(), and lets you provide callback routines to
     detect and read keypresses, which will be used by the main
     keypressed() and readkey() functions.  This can be useful if you
     want to use Allegro's GUI code with a custom keyboard handler, as
     it provides a way for the GUI to get keyboard input from your own
     code, bypassing the normal Allegro input system.

See also:
*Note install_keyboard::.
*Note keypressed::.
*Note readkey::.


File: allegro.info,  Node: poll_keyboard,  Next: keyboard_needs_poll,  Prev: install_keyboard_hooks,  Up: Keyboard

1.7.4 poll_keyboard
-------------------

int poll_keyboard();
     Wherever possible, Allegro will read the keyboard input
     asynchronously (ie.  from inside an interrupt handler), but on some
     platforms that may not be possible, in which case you must call
     this routine at regular intervals to update the keyboard state
     variables.

     To help you test your keyboard polling code even if you are
     programming on a platform that doesn't require it, after the first
     time that you call this function Allegro will switch into polling
     mode, so from that point onwards you will have to call this routine
     in order to get any keyboard input at all, regardless of whether
     the current driver actually needs to be polled or not.

     The keypressed(), readkey(), and ureadkey() functions call
     poll_keyboard() automatically, so you only need to use this
     function when accessing the key[] array and key_shifts variable.

     Returns zero on success, or a negative number on failure (ie.  no
     keyboard driver installed).

See also:
*Note keyboard_needs_poll::.
*Note install_keyboard::.
*Note key::.
*Note key_shifts::.
*Note excamera::.
*Note exsample::.
*Note exstars::.


File: allegro.info,  Node: keyboard_needs_poll,  Next: key,  Prev: poll_keyboard,  Up: Keyboard

1.7.5 keyboard_needs_poll
-------------------------

int keyboard_needs_poll();
     Returns TRUE if the current keyboard driver is operating in polling
     mode.

See also:
*Note poll_keyboard::.
*Note install_keyboard::.
*Note key::.


File: allegro.info,  Node: key,  Next: key_shifts,  Prev: keyboard_needs_poll,  Up: Keyboard

1.7.6 key
---------

extern volatile char key[KEY_MAX];
     Array of flags indicating the state of each key, ordered by
     scancode.  Wherever possible these values will be updated
     asynchronously, but if keyboard_needs_poll() returns TRUE, you must
     manually call poll_keyboard() to update them with the current input
     state.  The scancodes are defined in allegro/keyboard.h as a series
     of KEY_* constants (and are also listed below).  For example, you
     could write:

          if (key[KEY_SPACE])
             printf("Space is pressed\n");

     Note that the array is supposed to represent which keys are
     physically held down and which keys are not, so it is semantically
     read-only.

     These are the keyboard scancodes:

          KEY_A ... KEY_Z,
          KEY_0 ... KEY_9,
          KEY_0_PAD ... KEY_9_PAD,
          KEY_F1 ... KEY_F12,

          KEY_ESC, KEY_TILDE, KEY_MINUS, KEY_EQUALS,
          KEY_BACKSPACE, KEY_TAB, KEY_OPENBRACE, KEY_CLOSEBRACE,
          KEY_ENTER, KEY_COLON, KEY_QUOTE, KEY_BACKSLASH,
          KEY_BACKSLASH2, KEY_COMMA, KEY_STOP, KEY_SLASH,
          KEY_SPACE,

          KEY_INSERT, KEY_DEL, KEY_HOME, KEY_END, KEY_PGUP,
          KEY_PGDN, KEY_LEFT, KEY_RIGHT, KEY_UP, KEY_DOWN,

          KEY_SLASH_PAD, KEY_ASTERISK, KEY_MINUS_PAD,
          KEY_PLUS_PAD, KEY_DEL_PAD, KEY_ENTER_PAD,

          KEY_PRTSCR, KEY_PAUSE,

          KEY_ABNT_C1, KEY_YEN, KEY_KANA, KEY_CONVERT, KEY_NOCONVERT,
          KEY_AT, KEY_CIRCUMFLEX, KEY_COLON2, KEY_KANJI,

          KEY_LSHIFT, KEY_RSHIFT,
          KEY_LCONTROL, KEY_RCONTROL,
          KEY_ALT, KEY_ALTGR,
          KEY_LWIN, KEY_RWIN, KEY_MENU,
          KEY_SCRLOCK, KEY_NUMLOCK, KEY_CAPSLOCK

          KEY_EQUALS_PAD, KEY_BACKQUOTE, KEY_SEMICOLON, KEY_COMMAND

     Finally, you may notice an 'odd' behaviour of the KEY_PAUSE key.
     This key only generates an interrupt when it is pressed, not when
     it is released.  For this reason, Allegro pretends the pause key is
     a 'state' key, which is the only way to make it usable.

See also:
*Note install_keyboard::.
*Note poll_keyboard::.
*Note key_shifts::.
*Note Available Allegro examples: Available.


File: allegro.info,  Node: key_shifts,  Next: keypressed,  Prev: key,  Up: Keyboard

1.7.7 key_shifts
----------------

extern volatile int key_shifts;
     Bitmask containing the current state of shift/ctrl/alt, the special
     Windows keys, and the accent escape characters.  Wherever possible
     this value will be updated asynchronously, but if
     keyboard_needs_poll() returns TRUE, you must manually call
     poll_keyboard() to update it with the current input state.  This
     can contain any of the flags:

          KB_SHIFT_FLAG
          KB_CTRL_FLAG
          KB_ALT_FLAG
          KB_LWIN_FLAG
          KB_RWIN_FLAG
          KB_MENU_FLAG
          KB_COMMAND_FLAG
          KB_SCROLOCK_FLAG
          KB_NUMLOCK_FLAG
          KB_CAPSLOCK_FLAG
          KB_INALTSEQ_FLAG
          KB_ACCENT1_FLAG
          KB_ACCENT2_FLAG
          KB_ACCENT3_FLAG
          KB_ACCENT4_FLAG

     Example:

          if (key[KEY_W]) {
             if (key_shifts & KB_SHIFT_FLAG) {
                /* User is pressing shift + W. */
             } else {
                /* Hmmm... lower case W then. */
             }
          }

See also:
*Note install_keyboard::.
*Note poll_keyboard::.
*Note key::.
*Note excamera::.
*Note exkeys::.


File: allegro.info,  Node: keypressed,  Next: readkey,  Prev: key_shifts,  Up: Keyboard

1.7.8 keypressed
----------------

int keypressed();
     Returns TRUE if there are keypresses waiting in the input buffer.
     You can use this to see if the next call to readkey() is going to
     block or to simply wait for the user to press a key while you still
     update the screen possibly drawing some animation.  Example:

          while (!keypressed()) {
             /* Show cool animated logo. */
          }
          /* So he skipped our title screen. */

See also:
*Note install_keyboard::.
*Note readkey::.
*Note ureadkey::.
*Note clear_keybuf::.
*Note simulate_keypress::.
*Note simulate_ukeypress::.
*Note Available Allegro examples: Available.


File: allegro.info,  Node: readkey,  Next: ureadkey,  Prev: keypressed,  Up: Keyboard

1.7.9 readkey
-------------

int readkey();
     Returns the next character from the keyboard buffer, in ASCII
     format.  If the buffer is empty, it waits until a key is pressed.
     You can see if there are queued keypresses with keypressed().

     The low byte of the return value contains the ASCII code of the
     key, and the high byte the scancode.  The scancode remains the same
     whatever the state of the shift, ctrl and alt keys, while the ASCII
     code is affected by shift and ctrl in the normal way (shift changes
     case, ctrl+letter gives the position of that letter in the
     alphabet, eg.  ctrl+A = 1, ctrl+B = 2, etc).  Pressing alt+key
     returns only the scancode, with a zero ASCII code in the low byte.
     For example:

          int val;
          ...
          val = readkey();
          if ((val & 0xff) == 'd')     /* by ASCII code */
             allegro_message("You pressed 'd'\n");

          if ((val >> 8) == KEY_SPACE) /* by scancode */
             allegro_message("You pressed Space\n");

          if ((val & 0xff) == 3)       /* ctrl+letter */
             allegro_message("You pressed Control+C\n");

          if (val == (KEY_X << 8))     /* alt+letter */
             allegro_message("You pressed Alt+X\n");

     This function cannot return character values greater than 255.  If
     you need to read Unicode input, use ureadkey() instead.

See also:
*Note install_keyboard::.
*Note ureadkey::.
*Note keypressed::.
*Note clear_keybuf::.
*Note simulate_keypress::.
*Note Available Allegro examples: Available.


File: allegro.info,  Node: ureadkey,  Next: scancode_to_ascii,  Prev: readkey,  Up: Keyboard

1.7.10 ureadkey
---------------

int ureadkey(int *scancode);
     Returns the next character from the keyboard buffer, in Unicode
     format.  If the buffer is empty, it waits until a key is pressed.
     You can see if there are queued keypresses with keypressed().  The
     return value contains the Unicode value of the key, and if not
     NULL, the pointer argument will be set to the scancode.  Unlike
     readkey(), this function is able to return character values greater
     than 255.  Example:

          int val, scancode;
          ...
          val = ureadkey(&scancode);
          if (val == 0x00F1)
             allegro_message("You pressed n with tilde\n");

          if (val == 0x00DF)
             allegro_message("You pressed sharp s\n");

     You should be able to find Unicode character maps at
     http://www.unicode.org/.  Remember that on DOS you must specify a
     custom keyboard map (like those found in 'keyboard.dat') usually
     with the help of a configuration file specifying the language
     mapping (keyboard variable in system section of 'allegro.cfg'), or
     you will get the default US keyboard mapping.

See also:
*Note install_keyboard::.
*Note readkey::.
*Note keypressed::.
*Note clear_keybuf::.
*Note simulate_ukeypress::.
*Note exkeys::.


File: allegro.info,  Node: scancode_to_ascii,  Next: scancode_to_name,  Prev: ureadkey,  Up: Keyboard

1.7.11 scancode_to_ascii
------------------------

int scancode_to_ascii(int scancode);
     Converts the given scancode to an ASCII character for that key
     (mangling Unicode values), returning the unshifted uncapslocked
     result of pressing the key, or zero if the key isn't a
     character-generating key or the lookup can't be done.  The lookup
     cannot be done for keys like the F1-F12 keys or the cursor keys,
     and some drivers will only return approximate values.  Generally,
     if you want to display the name of a key to the user, you should
     use the scancode_to_name function.

     Example:

          int ascii;
          ...
          ascii = scancode_to_ascii(scancode);
          allegro_message("You pressed '%c'\n", ascii);

See also:
*Note scancode_to_name::.


File: allegro.info,  Node: scancode_to_name,  Next: simulate_keypress,  Prev: scancode_to_ascii,  Up: Keyboard

1.7.12 scancode_to_name
-----------------------

const char *scancode_to_name(int scancode);
     This function returns a string pointer containing the name of they
     key with the given scancode.  This is useful if you e.g.  let the
     user choose a key for some action, and want to display something
     more meaningful than just the scancode.  Example:

          char const *keyname = scancode_to_name(scancode);
          allegro_message("You pressed the %s key.", keyname);

See also:
*Note scancode_to_ascii::.
*Note exkeys::.


File: allegro.info,  Node: simulate_keypress,  Next: simulate_ukeypress,  Prev: scancode_to_name,  Up: Keyboard

1.7.13 simulate_keypress
------------------------

void simulate_keypress(int key);
     Stuffs a key into the keyboard buffer, just as if the user had
     pressed it.  The parameter is in the same format returned by
     readkey().  Example:

          simulate_keypress(KEY_SPACE << 8);
          if (readkey() == (KEY_SPACE << 8))
             allegro_message("You simulated Alt+Space\n");

See also:
*Note install_keyboard::.
*Note simulate_ukeypress::.
*Note keypressed::.
*Note readkey::.


File: allegro.info,  Node: simulate_ukeypress,  Next: keyboard_callback,  Prev: simulate_keypress,  Up: Keyboard

1.7.14 simulate_ukeypress
-------------------------

void simulate_ukeypress(int key, int scancode);
     Stuffs a key into the keyboard buffer, just as if the user had
     pressed it.  The parameter is in the same format returned by
     ureadkey().  Example:

          /* We ignore the scancode simulation. */
          simulate_ukeypress(0x00DF, 0);
          if (ureadkey(&scancode) == 0x00DF)
             allegro_message("You simulated sharp s\n");

See also:
*Note install_keyboard::.
*Note simulate_keypress::.
*Note keypressed::.
*Note ureadkey::.


File: allegro.info,  Node: keyboard_callback,  Next: keyboard_ucallback,  Prev: simulate_ukeypress,  Up: Keyboard

1.7.15 keyboard_callback
------------------------

extern int (*keyboard_callback)(int key);
     If set, this function is called by the keyboard handler in response
     to every keypress.  It is passed a copy of the value that is about
     to be added into the input buffer, and can either return this value
     unchanged, return zero to cause the key to be ignored, or return a
     modified value to change what readkey() will later return.  This
     routine executes in an interrupt context, so it must be in locked
     memory.  Example:

          int enigma_scrambler(int key)
          {
             /* Add one to both the scancode and ascii values. */
             return (((key >> 8) + 1)
          }
          END_OF_FUNCTION(enigma_scrambler)

          ...

             install_timer();
             LOCK_FUNCTION(enigma_scrambler);
             install_keyboard();
             keyboard_callback = enigma_scrambler;

     Note that this callback will be ignored if you also set the unicode
     keyboard callback.

See also:
*Note install_keyboard::.
*Note readkey::.
*Note ureadkey::.
*Note keyboard_ucallback::.
*Note keyboard_lowlevel_callback::.


File: allegro.info,  Node: keyboard_ucallback,  Next: keyboard_lowlevel_callback,  Prev: keyboard_callback,  Up: Keyboard

1.7.16 keyboard_ucallback
-------------------------

extern int (*keyboard_ucallback)(int key, int *scancode);
     Unicode-aware version of keyboard_callback().  If set, this
     function is called by the keyboard handler in response to every
     keypress.  It is passed the character value and scancode that are
     about to be added into the input buffer, can modify the scancode
     value, and returns a new or modified key code.  If it both sets the
     scancode to zero and returns zero, the keypress will be ignored.
     This routine executes in an interrupt context, so it must be in
     locked memory.  Example:

          int silence_g_key(int key, int *scancode)
          {
             if (key == 'g') {
                *scancode = 0;
                return 0;
             }
             return key;
          } END_OF_FUNCTION(silence_g_key)

          ...

             install_timer();
             LOCK_FUNCTION(silence_g_key);
             install_keyboard();
             keyboard_ucallback = silence_g_key;

     Note that this keyboard callback has priority over the non unicode
     callback.  If you set both, only the unicode one will work.

See also:
*Note install_keyboard::.
*Note readkey::.
*Note ureadkey::.
*Note keyboard_callback::.
*Note keyboard_lowlevel_callback::.


File: allegro.info,  Node: keyboard_lowlevel_callback,  Next: set_leds,  Prev: keyboard_ucallback,  Up: Keyboard

1.7.17 keyboard_lowlevel_callback
---------------------------------

extern void (*keyboard_lowlevel_callback)(int scancode);
     If set, this function is called by the keyboard handler in response
     to every keyboard event, both presses (including keyboard repeat
     rate) and releases.  It will be passed a raw keyboard scancode byte
     (scancodes are 7 bits long), with the top bit (8th bit) clear if
     the key has been pressed or set if it was released.  This routine
     executes in an interrupt context, so it must be in locked memory.
     Example:

          volatile int key_down, key_up;

          void keypress_watcher(int scancode)
          {
             if (scancode & 0x80) {
                key_up = 1;
             } else {
                key_down = 1;
             }
          } END_OF_FUNCTION(keypress_watcher)

          ...

             install_timer();
             LOCK_FUNCTION(silence_g_key);
             LOCK_VARIABLE(key_down);
             LOCK_VARIABLE(key_up);
             install_keyboard();
             keyboard_lowlevel_callback = keypress_watcher;
             /* Disable keyboard repeat to get typewriter effect. */
             set_keyboard_rate(0, 0);

          ...

             while (game_loop) {
                if (key_down) {
                   key_down = 0;
                   /* Play sample of typewriter key press. */
                }
                if (key_up) {
                   key_up = 0;
                   /* Play sample of typewriter key release. */
                }
             }

See also:
*Note install_keyboard::.
*Note keyboard_callback::.
*Note keyboard_ucallback::.
*Note exkeys::.


File: allegro.info,  Node: set_leds,  Next: set_keyboard_rate,  Prev: keyboard_lowlevel_callback,  Up: Keyboard

1.7.18 set_leds
---------------

void set_leds(int leds);
     Overrides the state of the keyboard LED indicators.  The parameter
     is a bitmask containing any of the values KB_SCROLOCK_FLAG,
     KB_NUMLOCK_FLAG, and KB_CAPSLOCK_FLAG, or -1 to restore the default
     behavior.  Example:

          /* Cycle led indicators. */
          set_leds(KB_SCROLOCK_FLAG);
          rest(1000);
          set_leds(KB_CAPSLOCK_FLAG);
          rest(1000);
          set_leds(KB_NUMLOCK_FLAG);
          rest(1000);
          set_leds(-1);

     Note that the led behaviour cannot be guaranteed on some platforms,
     some leds might not react, or none at all.  Therefore you shouldn't
     rely only on them to communicate information to the user, just in
     case it doesn't get through.

See also:
*Note install_keyboard::.
*Note key_led_flag::.


File: allegro.info,  Node: set_keyboard_rate,  Next: clear_keybuf,  Prev: set_leds,  Up: Keyboard

1.7.19 set_keyboard_rate
------------------------

void set_keyboard_rate(int delay, int repeat);
     Sets the keyboard repeat rate.  Times are given in milliseconds.
     Passing zero times will disable the key repeat.

See also:
*Note install_keyboard::.
*Note readkey::.
*Note ureadkey::.


File: allegro.info,  Node: clear_keybuf,  Next: three_finger_flag,  Prev: set_keyboard_rate,  Up: Keyboard

1.7.20 clear_keybuf
-------------------

void clear_keybuf();
     Empties the keyboard buffer.  Usually you want to use this in your
     program before reading keys to avoid previously buffered keys to be
     returned by calls to readkey() or ureadkey().

See also:
*Note install_keyboard::.
*Note keypressed::.
*Note readkey::.
*Note ureadkey::.
*Note Available Allegro examples: Available.


File: allegro.info,  Node: three_finger_flag,  Next: key_led_flag,  Prev: clear_keybuf,  Up: Keyboard

1.7.21 three_finger_flag
------------------------

extern int three_finger_flag;
     The DJGPP keyboard handler provides an 'emergency exit' sequence
     which you can use to kill off your program.  If you are running
     under DOS this is the three finger salute, ctrl+alt+del.  Most
     multitasking OS's will trap this combination before it reaches the
     Allegro handler, in which case you can use the alternative
     ctrl+alt+end.  If you want to disable this behaviour in release
     versions of your program, set this flag to FALSE.

See also:
*Note install_keyboard::.


File: allegro.info,  Node: key_led_flag,  Next: install_joystick,  Prev: three_finger_flag,  Up: Keyboard

1.7.22 key_led_flag
-------------------

extern int key_led_flag;
     By default, the capslock, numlock, and scroll-lock keys toggle the
     keyboard LED indicators when they are pressed.  If you are using
     these keys for input in your game (eg.  capslock to fire) this may
     not be desirable, so you can clear this flag to prevent the LED's
     being updated.

See also:
*Note install_keyboard::.
*Note set_leds::.


File: allegro.info,  Node: Joystick,  Next: Graphics,  Prev: Keyboard,  Up: API

1.8 Joystick routines
=====================

Unlike keyboard or mouse input, which are usually read through hardware
interrupts by Allegro, joystick input functions have to be polled
because there are no hardware interrupts for them on most platforms.
This doesn't mean that you have to poll the joysticks on each line of
code you want to read their values, but you should make sure to poll
them at least once per frame in your game loop.  Otherwise you face the
possibility of reading stale incorrect data.

* Menu:

* install_joystick::
* remove_joystick::
* poll_joystick::
* num_joysticks::
* joy::
* calibrate_joystick_name::
* calibrate_joystick::
* save_joystick_data::
* load_joystick_data::
* initialise_joystick::


File: allegro.info,  Node: install_joystick,  Next: remove_joystick,  Prev: key_led_flag,  Up: Joystick

1.8.1 install_joystick
----------------------

int install_joystick(int type);
     Installs Allegro's joystick handler, and calibrates the centre
     position values.  The type parameter should usually be
     JOY_TYPE_AUTODETECT, or see the platform specific documentation for
     a list of the available drivers.  You must call this routine before
     using any other joystick functions, and you should make sure that
     all joysticks are in the middle position at the time.  Example:

          textout_centre_ex(screen, font,
                            "Center the joystick and press a key",
                            SCREEN_W/2, SCREEN_H/2, red_color, -1);
          readkey();
          if (install_joystick(JOY_TYPE_AUTODETECT) != 0)
             abort_on_error("Error initialising joystick!");

     Returns zero on success.  As soon as you have installed the
     joystick module, you will be able to read the button state and
     digital (on/off toggle) direction information, which may be enough
     for some games.  If you want to get full analogue input, though,
     you need to use the calibrate_joystick() functions to measure the
     exact range of the inputs: see below.

See also:
*Note remove_joystick::.
*Note num_joysticks::.
*Note load_joystick_data::.
*Note calibrate_joystick::.
*Note calibrate_joystick_name::.
*Note poll_joystick::.
*Note Standard config variables::.
*Note JOY_TYPE_*/DOS::.
*Note JOY_TYPE_*/Windows::.
*Note JOY_TYPE_*/Linux::.
*Note exjoy::.


File: allegro.info,  Node: remove_joystick,  Next: poll_joystick,  Prev: install_joystick,  Up: Joystick

1.8.2 remove_joystick
---------------------

void remove_joystick();
     Removes the joystick handler.  You don't normally need to bother
     calling this, because allegro_exit() will do it for you.

See also:
*Note install_joystick::.
*Note allegro_exit::.


File: allegro.info,  Node: poll_joystick,  Next: num_joysticks,  Prev: remove_joystick,  Up: Joystick

1.8.3 poll_joystick
-------------------

int poll_joystick();
     The joystick handler is not interrupt driven, so you need to call
     this function every now and again to update the global position
     values.  Example:

          do {
             /* Get joystick input */
             poll_joystick();

             /* Process input for the first joystick */
             if (joy[0].button[0].b)
                first_button_pressed();

             if (joy[0].button[1].b)
                second_button_pressed();
             ...
          } while(!done);

     Returns zero on success or a negative number on failure (usually
     because no joystick driver was installed).

See also:
*Note install_joystick::.
*Note joy::.
*Note num_joysticks::.
*Note exjoy::.


File: allegro.info,  Node: num_joysticks,  Next: joy,  Prev: poll_joystick,  Up: Joystick

1.8.4 num_joysticks
-------------------

extern int num_joysticks;
     Global variable containing the number of active joystick devices.
     The current drivers support a maximum of eight controllers.

See also:
*Note install_joystick::.
*Note joy::.
*Note exjoy::.


File: allegro.info,  Node: joy,  Next: calibrate_joystick_name,  Prev: num_joysticks,  Up: Joystick

1.8.5 joy
---------

extern JOYSTICK_INFO joy[n];
     Global array of joystick state information, which is updated by the
     poll_joystick() function.  Only the first num_joysticks elements
     will contain meaningful information.  The JOYSTICK_INFO structure
     is defined as:

          typedef struct JOYSTICK_INFO
          {
             int flags;                       - status flags for this
                                                joystick
             int num_sticks;                  - how many stick inputs?
             int num_buttons;                 - how many buttons?
             JOYSTICK_STICK_INFO stick[n];    - stick state information
             JOYSTICK_BUTTON_INFO button[n];  - button state information
          } JOYSTICK_INFO;

     The button status is stored in the structure:

          typedef struct JOYSTICK_BUTTON_INFO
          {
             int b;                           - boolean on/off flag
             char *name;                      - description of this
                                                button
          } JOYSTICK_BUTTON_INFO;

     You may wish to display the button names as part of an input
     configuration screen to let the user choose what game function will
     be performed by each button, but in simpler situations you can
     safely assume that the first two elements in the button array will
     always be the main trigger controls.

     Each joystick will provide one or more stick inputs, of varying
     types.  These can be digital controls which snap to specific
     positions (eg.  a gamepad controller, the coolie hat on a
     Flightstick Pro or Wingman Extreme, or a normal joystick which
     hasn't yet been calibrated), or they can be full analogue inputs
     with a smooth range of motion.  Sticks may also have different
     numbers of axes, for example a normal directional control has two,
     but the Flightstick Pro throttle is only a single axis, and it is
     possible that the system could be extended in the future to support
     full 3d controllers.  A stick input is described by the structure:

          typedef struct JOYSTICK_STICK_INFO
          {
             int flags;                       - status flags for this
                                                input
             int num_axis;                    - how many axes do we
                                                have? (note the misspelling)
             JOYSTICK_AXIS_INFO axis[n];      - axis state information
             char *name;                      - description of this
                                                input
          } JOYSTICK_STICK_INFO;

     A single joystick may provide several different stick inputs, but
     you can safely assume that the first element in the stick array
     will always be the main directional controller.

     Information about each of the stick axis is stored in the
     substructure:

          typedef struct JOYSTICK_AXIS_INFO
          {
             int pos;                         - analogue axis position
             int d1, d2;                      - digital axis position
             char *name;                      - description of this axis
          } JOYSTICK_AXIS_INFO;

     This provides both analogue input in the pos field (ranging from
     -128 to 128 or from 0 to 255, depending on the type of the
     control), and digital values in the d1 and d2 fields.  For example,
     when describing the X-axis position, the pos field will hold the
     horizontal position of the joystick, d1 will be set if it is moved
     left, and d2 will be set if it is moved right.  Allegro will fill
     in all these values regardless of whether it is using a digital or
     analogue joystick, emulating the pos field for digital inputs by
     snapping it to the min, middle, and maximum positions, and
     emulating the d1 and d2 values for an analogue stick by comparing
     the current position with the centre point.

     The joystick flags field may contain any combination of the bit
     flags:

     JOYFLAG_DIGITAL
     This control is currently providing digital input.

     JOYFLAG_ANALOGUE
     This control is currently providing analogue input.

     JOYFLAG_CALIB_DIGITAL
     This control will be capable of providing digital input once it has
     been calibrated, but is not doing this at the moment.

     JOYFLAG_CALIB_ANALOGUE
     This control will be capable of providing analogue input once it
     has been calibrated, but is not doing this at the moment.

     JOYFLAG_CALIBRATE
     Indicates that this control needs to be calibrated.  Many devices
     require multiple calibration steps, so you should call the
     calibrate_joystick() function from a loop until this flag is
     cleared.

     JOYFLAG_SIGNED
     Indicates that the analogue axis position is in signed format,
     ranging from -128 to 128.  This is the case for all 2d directional
     controls.

     JOYFLAG_UNSIGNED
     Indicates that the analogue axis position is in unsigned format,
     ranging from 0 to 255.  This is the case for all 1d throttle
     controls.

     Note for people who spell funny: in case you don't like having to
     type "analogue", there are some #define aliases in
     allegro/joystick.h that will allow you to write "analog" instead.

See also:
*Note install_joystick::.
*Note poll_joystick::.
*Note num_joysticks::.
*Note calibrate_joystick::.
*Note calibrate_joystick_name::.
*Note exjoy::.
*Note JOYSTICK_INFO::.


File: allegro.info,  Node: calibrate_joystick_name,  Next: calibrate_joystick,  Prev: joy,  Up: Joystick

1.8.6 calibrate_joystick_name
-----------------------------

const char *calibrate_joystick_name(int n);
     Pass the number of the joystick you want to calibrate as the
     parameter.

     Returns a text description for the next type of calibration that
     will be done on the specified joystick, or NULL if no more
     calibration is required.

See also:
*Note install_joystick::.
*Note calibrate_joystick::.
*Note joy::.
*Note num_joysticks::.
*Note exjoy::.


File: allegro.info,  Node: calibrate_joystick,  Next: save_joystick_data,  Prev: calibrate_joystick_name,  Up: Joystick

1.8.7 calibrate_joystick
------------------------

int calibrate_joystick(int n);
     Most joysticks need to be calibrated before they can provide full
     analogue input.  This function performs the next operation in the
     calibration series for the specified stick, assuming that the
     joystick has been positioned in the manner described by a previous
     call to calibrate_joystick_name(), returning zero on success.  For
     example, a simple routine to fully calibrate all the joysticks
     might look like:

          int i;

          for (i=0; i<;num_joysticks; i++) {
             while (joy[i].flags & JOYFLAG_CALIBRATE) {
                char *msg = calibrate_joystick_name(i);
                textprintf_ex(..., "%s, and press a key\n", msg);
                readkey();
                if (calibrate_joystick(i) != 0) {
                   textprintf_ex(..., "oops!\n");
                   readkey();
                   exit(1);
                }
             }
          }

     Returns zero on success, non-zero if the calibration could not be
     performed successfully.

See also:
*Note install_joystick::.
*Note calibrate_joystick_name::.
*Note joy::.
*Note num_joysticks::.
*Note exjoy::.


File: allegro.info,  Node: save_joystick_data,  Next: load_joystick_data,  Prev: calibrate_joystick,  Up: Joystick

1.8.8 save_joystick_data
------------------------

int save_joystick_data(const char *filename);
     After all the headache of calibrating the joystick, you may not
     want to make your poor users repeat the process every time they run
     your program.  Call this function to save the joystick calibration
     data into the specified configuration file, from which it can later
     be read by load_joystick_data().  Pass a NULL filename to write the
     data to the currently selected configuration file.

     Returns zero on success, non-zero if the data could not be saved.

See also:
*Note load_joystick_data::.
*Note set_config_file::.


File: allegro.info,  Node: load_joystick_data,  Next: initialise_joystick,  Prev: save_joystick_data,  Up: Joystick

1.8.9 load_joystick_data
------------------------

int load_joystick_data(const char *filename);
     Restores calibration data previously stored by save_joystick_data()
     or the setup utility.  This sets up all aspects of the joystick
     code: you don't even need to call install_joystick() if you are
     using this function.  Pass a NULL filename to read the data from
     the currently selected configuration file.

     Returns zero on success: if it fails the joystick state is
     undefined and you must reinitialise it from scratch.

See also:
*Note install_joystick::.
*Note save_joystick_data::.
*Note set_config_file::.


File: allegro.info,  Node: initialise_joystick,  Next: set_color_depth,  Prev: load_joystick_data,  Up: Joystick

1.8.10 initialise_joystick
--------------------------

int initialise_joystick();
     Deprecated.  Use install_joystick() instead.

See also:
*Note install_joystick::.


File: allegro.info,  Node: Graphics,  Next: Bitmap,  Prev: Joystick,  Up: API

1.9 Graphics modes
==================

Graphics modes are the common denominator for most Allegro programs.
While it is possible to write platform specific programs using Allegro
which don't set a graphic mode through the routines provided in this
chapter, these are not very common.

The first thing to note is that due to the wide range of supported
platforms, a graphic mode is the only way to safely communicate with the
user.  When Allegro was a DOS only library (versions 3.x and previous),
it was frequent for programmers to use functions from the C standard
library to communicate with the user, like calling printf() before
setting a graphic mode or maybe scanf() to read the user's input.
However, what would happen for such a game running under Windows where
there is no default console output or it may be hidden from the user?
Even if the game compiled successfully, it would be unplayable,
especially if there was vital information for the user in those text
only messages.

Allegro provides the allegro_message() function to deal with this
problem, but this is not a very user friendly method of communicating
with the user and its main purpose is displaying small error like
messages when no graphic mode is available.  Therefore, the first thing
your Allegro program should do is set a graphic mode, and from there on,
use Allegro's text output routines to display messages to the user, just
like 'allegro/examples/exhello.c' does.

Setting a graphic mode involves deciding how to allocate the memory of
the video card for your program.  On some platforms this means creating
a virtual screen bigger than the physical resolution to do hardware
scrolling or page flipping.  Virtual screens can cause a lot of
confusion, but they are really quite simple.  Warning: patronising
explanation coming up, so you may wish to skip the rest of this
paragraph.  Think of video memory as a rectangular piece of paper which
is being viewed through a small hole (your monitor) in a bit of
cardboard.  Since the paper is bigger than the hole you can only see
part of it at any one time, but by sliding the cardboard around you can
alter which portion of the image is visible.  You could just leave the
hole in one position and ignore the parts of video memory that aren't
visible, but you can get all sorts of useful effects by sliding the
screen window around, or by drawing images in a hidden part of video
memory and then flipping across to display them.

For example, you could select a 640x480 mode in which the monitor acts
as a window onto a 1024x1024 virtual screen, and then move the visible
screen around in this larger area (hardware scrolling).  Initially, with
the visible screen positioned at the top left corner of video memory,
this setup would look like:

     (0,0)------------(640,0)----(1024,0)
       |                  |           |
       |  visible screen  |           |
       |                  |           |
     (0,480)----------(640,480)       |
       |                              |
       |   the rest of video memory   |
       |                              |
     (0,1024)--------------------(1024,1024)

With a virtual screen bigger than the visible screen you can perform
smooth CPU inexpensive scrolling: you draw your graphics once, and then
only tell the video card to show a different portion of the screen.
However, virtual screens are not supported on all platforms, and on some
they might be emulated through software, losing any performance.  On top
of that, many video cards only allow horizontal scrolling in steps of 32
bytes.  This is not a problem if your game runs in 24 or 32 bit, but it
tends to mean jerky scrolling for other color depths.

The other reason you could use virtual screens for is page flipping.
This means showing one portion of the virtual screen while your program
draws to the hidden one.  When you finish, you show the part you have
been drawing to and repeat the process with the area now hidden.  The
result is a perfectly smooth screen update without flickering or other
graphical artifacts.

Scrolling manually to one part of the video memory is one non portable
way to accomplish this.  The portable way is to use functions like
create_system_bitmap(), create_video_bitmap(), show_video_bitmap(), etc.
These functions divide the memory of the video card in areas and switch
between them, a feature supported on all platforms and video cards
(given that they have enough memory for the screen resolutions you asked
for).

The last thing you need to know about setting a graphic mode are
drivers.  Each platform has a number of graphic drivers which support a
different range of hardware or behave in different ways.  To avoid
cluttering your own code with #ifdefs and dealing with drivers added
after you release your program, Allegro provides several so called magic
drivers.  These magic drivers don't really exists, they wrap around a
specific kind of functionality.

The magic drivers you can use are:

   * GFX_AUTODETECT:
     Allegro will try to set the specified resolution with the current
     color depth in fullscreen mode.  Failing that, it will try to
     repeat the same operation in windowed mode.  If the call to
     set_gfx_mode() succeeds, you are guaranteed to have set the
     specified resolution in the current color depth, but you don't know
     if the program is running fullscreen or windowed.
   * GFX_AUTODETECT_FULLSCREEN:
     Allegro will try to set the specified resolution with the current
     color depth in fullscreen mode.  If that is not possible,
     set_gfx_mode() will fail.
   * GFX_AUTODETECT_WINDOWED:
     Allegro will try to set the specified resolution with the current
     color depth in a windowed mode.  If that is not possible,
     set_gfx_mode() will fail.  When it comes to windowed modes, the
     'specified resolution' actually means the graphic area your program
     can draw on, without including window decorations (if any).  Note
     that in windowed modes running with a color depth other than the
     desktop may result in non optimal performance due to internal color
     conversions in the graphic driver.  Use desktop_color_depth() to
     your advantage in these situations.
   * GFX_SAFE:
     Using this driver Allegro guarantees that a graphic mode will
     always be set correctly.  It will try to select the resolution that
     you request, and if that fails, it will fall back upon whatever
     mode is known to be reliable on the current platform (this is
     320x200 VGA mode under DOS, a 640x480 resolution under Windows, the
     actual framebuffer's resolution under Linux if it's supported,
     etc).  If it absolutely cannot set any graphics mode at all, it
     will return negative as usual, meaning that there's no possible
     video output on the machine, and that you should abort your program
     immediately, possibly after notifying this to the user with
     allegro_message.

     This fake driver is useful for situations where you just want to
     get into some kind of workable display mode, and can't be bothered
     with trying multiple different resolutions and doing all the error
     checking yourself.  Note however, that after a successful call to
     set_gfx_mode with this driver, you cannot make any assumptions
     about the width, height or color depth of the screen: your code
     will have to deal with this little detail.
   * GFX_TEXT:
     Closes any previously opened graphics mode, making you unable to
     use the global variable 'screen', and in those environments that
     have text modes, sets one previously used or the closest match to
     that (usually 80x25).  With this driver the size parameters of
     set_gfx_mode don't mean anything, so you can leave them all to zero
     or any other number you prefer.

* Menu:

* set_color_depth::
* get_color_depth::
* request_refresh_rate::
* get_refresh_rate::
* get_gfx_mode_list::
* destroy_gfx_mode_list::
* set_gfx_mode::
* set_display_switch_mode::
* set_display_switch_callback::
* remove_display_switch_callback::
* get_display_switch_mode::
* is_windowed_mode::
* get_gfx_mode_type::
* get_gfx_mode::
* gfx_capabilities::
* enable_triple_buffer::
* scroll_screen::
* request_scroll::
* poll_scroll::
* show_video_bitmap::
* request_video_bitmap::
* vsync::


File: allegro.info,  Node: set_color_depth,  Next: get_color_depth,  Prev: initialise_joystick,  Up: Graphics

1.9.1 set_color_depth
---------------------

void set_color_depth(int depth);
     Sets the pixel format to be used by subsequent calls to
     set_gfx_mode() and create_bitmap().  Valid depths are 8 (the
     default), 15, 16, 24, and 32 bits.  Example:

          set_color_depth(32);
          if (set_gfx_mode(GFX_AUTODETECT, 640, 480, 0, 0) != 0) {
             abort_on_error("Couldn't set a 32 bit color resolution");
          }

     Note that the screen color depth won't change until the next
     successful call to set_gfx_mode().

See also:
*Note get_color_depth::.
*Note set_gfx_mode::.
*Note set_color_conversion::.
*Note makecol::.
*Note getr::.
*Note desktop_color_depth::.
*Note Available Allegro examples: Available.


File: allegro.info,  Node: get_color_depth,  Next: request_refresh_rate,  Prev: set_color_depth,  Up: Graphics

1.9.2 get_color_depth
---------------------

int get_color_depth(void);
     Returns the current pixel format.  This can be very useful to know
     in order to write generic functions which select a different code
     path internally depending on the color depth being used.

     Note that the function returns whatever value you may have set
     previously with set_color_depth(), which can be different from the
     current color depth of the screen global variable.  If you really
     need to know the color depth of the screen, use
     bitmap_color_depth().

See also:
*Note set_color_depth::.
*Note bitmap_color_depth::.
*Note exrgbhsv::.


File: allegro.info,  Node: request_refresh_rate,  Next: get_refresh_rate,  Prev: get_color_depth,  Up: Graphics

1.9.3 request_refresh_rate
--------------------------

void request_refresh_rate(int rate);
     Requests that the next call to set_gfx_mode() try to use the
     specified refresh rate, if possible.  Not all drivers are able to
     control this at all, and even when they can, not all rates will be
     possible on all hardware, so the actual settings may differ from
     what you requested.  After you call set_gfx_mode(), you can use
     get_refresh_rate() to find out what was actually selected.  At the
     moment only the DOS VESA 3.0, X DGA 2.0 and some Windows DirectX
     drivers support this function.  The speed is specified in Hz, eg.
     60, 70.  To return to the normal default selection, pass a rate
     value of zero.  Example:

          request_refresh_rate(60);
          if (set_gfx_mode(GFX_AUTODETECT, 640, 480, 0, 0) != 0)
             abort_on_error("Couldn't set graphic mode!");
          if (get_refresh_rate() != 60)
             abort_on_error("Couldn't set refresh rate to 60Hz!");

See also:
*Note set_gfx_mode::.
*Note get_refresh_rate::.


File: allegro.info,  Node: get_refresh_rate,  Next: get_gfx_mode_list,  Prev: request_refresh_rate,  Up: Graphics

1.9.4 get_refresh_rate
----------------------

int get_refresh_rate(void);
     Returns the current refresh rate, if known (not all drivers are
     able to report this information).  Returns zero if the actual rate
     is unknown.

See also:
*Note request_refresh_rate::.


File: allegro.info,  Node: get_gfx_mode_list,  Next: destroy_gfx_mode_list,  Prev: get_refresh_rate,  Up: Graphics

1.9.5 get_gfx_mode_list
-----------------------

GFX_MODE_LIST *get_gfx_mode_list(int card);
     Attempts to create a list of all the supported video modes for a
     certain graphics driver, made up from the GFX_MODE_LIST structure,
     which has the following definition:

          typedef struct GFX_MODE_LIST
          {
             int num_modes;
             GFX_MODE *mode;
          } GFX_MODE_LIST;

     The mode entry points to the actual list of video modes.

          typedef struct GFX_MODE
          {
             int width, height, bpp;
          } GFX_MODE;

     This list of video modes is terminated with an { 0, 0, 0 } entry.

     Note that the card parameter must refer to a _real_ driver.  This
     function fails if you pass GFX_SAFE, GFX_AUTODETECT, or any other
     "magic" driver.

     Returns a pointer to a list structure of the type GFX_MODE_LIST or
     NULL if the request could not be satisfied.

See also:
*Note destroy_gfx_mode_list::.
*Note set_gfx_mode::.
*Note set_color_depth::.
*Note GFX_MODE_LIST::.


File: allegro.info,  Node: destroy_gfx_mode_list,  Next: set_gfx_mode,  Prev: get_gfx_mode_list,  Up: Graphics

1.9.6 destroy_gfx_mode_list
---------------------------

void destroy_gfx_mode_list(GFX_MODE_LIST *mode_list);
     Removes the mode list created by get_gfx_mode_list() from memory.
     Use this once you are done with the generated mode list to avoid
     memory leaks in your program.

See also:
*Note get_gfx_mode_list::.
*Note set_gfx_mode::.
*Note set_color_depth::.
*Note GFX_MODE_LIST::.


File: allegro.info,  Node: set_gfx_mode,  Next: set_display_switch_mode,  Prev: destroy_gfx_mode_list,  Up: Graphics

1.9.7 set_gfx_mode
------------------

int set_gfx_mode(int card, int w, int h, int v_w, int v_h);
     Switches into graphics mode.  The card parameter should usually be
     one of the Allegro magic drivers (read introduction of chapter
     "Graphics modes") or see the platform specific documentation for a
     list of the available drivers.  The w and h parameters specify what
     screen resolution you want.  The color depth of the graphic mode
     has to be specified before calling this function with
     set_color_depth().

     The v_w and v_h parameters specify the minimum virtual screen size,
     in case you need a large virtual screen for hardware scrolling or
     page flipping.  You should set them to zero if you don't care about
     the virtual screen size.

     When you call set_gfx_mode(), the v_w and v_h parameters represent
     the minimum size of virtual screen that is acceptable for your
     program.  The range of possible sizes is usually very restricted,
     and Allegro may end up creating a virtual screen much larger than
     the one you request.  Allowed sizes are driver dependent and some
     drivers do not allow virtual screens that are larger than the
     visible screen at all: don't assume that whatever you pass will
     always work.

     In mode-X the virtual width can be any multiple of eight greater
     than or equal to the physical screen width, and the virtual height
     will be set accordingly (the VGA has 256k of vram, so the virtual
     height will be 256*1024/virtual_width).

     Currently, using a big virtual screen for page flipping is
     considered bad practice.  There are platforms which don't support
     virtual screens bigger than the physical screen but can create
     different video pages to flip back and forth.  This means that, if
     you want page flipping and aren't going to use hardware scrolling,
     you should call set_gfx_mode() with (0,0) as the virtual screen
     size and later create the different video pages with
     create_video_bitmap().  Otherwise your program will be limited to
     the platforms supporting hardware scrolling.

     After you select a graphics mode, the physical and virtual screen
     sizes can be checked with the macros SCREEN_W, SCREEN_H, VIRTUAL_W,
     and VIRTUAL_H.

     Returns zero on success.  On failure returns a negative number and
     stores a description of the problem in allegro_error.

See also:
*Note set_color_depth::.
*Note request_refresh_rate::.
*Note screen::.
*Note gfx_capabilities::.
*Note allegro_error::.
*Note Standard config variables::.
*Note GFX_*/DOS::.
*Note GFX_*/Windows::.
*Note GFX_*/X::.
*Note GFX_*/Linux::.
*Note GFX_*/BeOS::.
*Note GFX_*/MacOSX::.
*Note create_video_bitmap::.
*Note get_desktop_resolution::.
*Note SCREEN_W::.
*Note SCREEN_H: SCREEN_W.
*Note VIRTUAL_W::.
*Note VIRTUAL_H: VIRTUAL_W.
*Note Available Allegro examples: Available.


File: allegro.info,  Node: set_display_switch_mode,  Next: set_display_switch_callback,  Prev: set_gfx_mode,  Up: Graphics

1.9.8 set_display_switch_mode
-----------------------------

int set_display_switch_mode(int mode);
     Sets how the program should handle being switched into the
     background, if the user tabs away from it.  Not all of the possible
     modes will be supported by every graphics driver on every platform.
     The available modes are:

        * SWITCH_NONE
          Disables switching.  This is the default in single-tasking
          systems like DOS. It may be supported on other platforms, but
          you should use it with caution, because your users won't be
          impressed if they want to switch away from your program, but
          you don't let them!
        * SWITCH_PAUSE
          Pauses the program whenever it is in the background.
          Execution will be resumed as soon as the user switches back to
          it.  This is the default in most fullscreen multitasking
          environments, for example the Linux console, but not under
          Windows.
        * SWITCH_AMNESIA
          Like SWITCH_PAUSE, but this mode doesn't bother to remember
          the contents of video memory, so the screen, and any video
          bitmaps that you have created, will be erased after the user
          switches away and then back to your program.  This is not a
          terribly useful mode to have, but it is the default for the
          fullscreen drivers under Windows because DirectDraw is too
          dumb to implement anything better.
        * SWITCH_BACKGROUND
          The program will carry on running in the background, with the
          screen bitmap temporarily being pointed at a memory buffer for
          the fullscreen drivers.  You must take special care when using
          this mode, because bad things will happen if the screen bitmap
          gets changed around when your program isn't expecting it (see
          below).
        * SWITCH_BACKAMNESIA
          Like SWITCH_BACKGROUND, but this mode doesn't bother to
          remember the contents of video memory (see SWITCH_AMNESIA). It
          is again the only mode supported by the fullscreen drivers
          under Windows that lets the program keep running in the
          background.

     Note that you should be very careful when you are using graphics
     routines in the switching context: you must always call
     acquire_screen() before the start of any drawing code onto the
     screen and not release it until you are completely finished,
     because the automatic locking mechanism may not be good enough to
     work when the program runs in the background or has just been
     raised in the foreground.

     Returns zero on success, invalidating at the same time all
     callbacks previously registered with set_display_switch_callback().
     Returns -1 if the requested mode is not currently possible.

See also:
*Note set_display_switch_callback::.
*Note get_display_switch_mode::.
*Note exmidi::.
*Note exsample::.
*Note exstream::.
*Note exswitch::.


File: allegro.info,  Node: set_display_switch_callback,  Next: remove_display_switch_callback,  Prev: set_display_switch_mode,  Up: Graphics

1.9.9 set_display_switch_callback
---------------------------------

int set_display_switch_callback(int dir, void (*cb)());
     Installs a notification callback for the switching mode that was
     previously selected by calling set_display_switch_mode().  The
     direction parameter can either be SWITCH_IN or SWITCH_OUT,
     depending whether you want to be notified about switches away from
     your program or back to your program.  You can sometimes install
     callbacks for both directions at the same time, but not every
     platform supports this.  You can install several switch callbacks,
     but no more than eight on any platform.

     Returns zero on success, decreasing the number of empty callback
     slots by one.  Returns -1 if the request is impossible for the
     current platform or you have reached the maximum number of allowed
     callbacks.

See also:
*Note remove_display_switch_callback::.
*Note set_display_switch_mode::.
*Note exswitch::.


File: allegro.info,  Node: remove_display_switch_callback,  Next: get_display_switch_mode,  Prev: set_display_switch_callback,  Up: Graphics

1.9.10 remove_display_switch_callback
-------------------------------------

void remove_display_switch_callback(void (*cb)());
     Removes a notification callback that was previously installed by
     calling set_display_switch_callback().  All the callbacks will
     automatically be removed when you call set_display_switch_mode().
     You can safely call this function even if the callback you want to
     remove is not installed.

See also:
*Note set_display_switch_callback::.


File: allegro.info,  Node: get_display_switch_mode,  Next: is_windowed_mode,  Prev: remove_display_switch_callback,  Up: Graphics

1.9.11 get_display_switch_mode
------------------------------

int get_display_switch_mode();
     Returns the current display switching mode, in the same format
     passed to set_display_switch_mode().

See also:
*Note set_display_switch_mode::.
*Note exswitch::.


File: allegro.info,  Node: is_windowed_mode,  Next: get_gfx_mode_type,  Prev: get_display_switch_mode,  Up: Graphics

1.9.12 is_windowed_mode
-----------------------

int is_windowed_mode(void);
     This function can be used to detect whether or not set_gfx_mode()
     selected a windowed mode.  Example:

          if (set_gfx_mode(GFX_AUTODETECT, 640, 480, 0, 0) != 0)
             abort_on_error("Couldn't set graphic mode!");
          if (is_windowed_mode()) {
             /* Windowed mode stuff. */
          } else {
             /* Fullscreen mode stuff. */
          }

     Returns true if the current graphics mode is a windowed mode, or
     zero if it is a fullscreen mode.  You should not call this function
     if you are not in graphics mode.

See also:
*Note set_gfx_mode::.


File: allegro.info,  Node: get_gfx_mode_type,  Next: get_gfx_mode,  Prev: is_windowed_mode,  Up: Graphics

1.9.13 get_gfx_mode_type
------------------------

int get_gfx_mode_type(int graphics_card);
     This function lets you determine the types of operating modes that
     a specific graphics card driver operates in.  It will tell you
     whether it is a windowed, fullscreen, definitely windowed or
     fullscreen, and/or a magic driver.

     The value returned is a bitfield consisting of these fields:
     GFX_TYPE_UNKNOWN
     GFX_TYPE_WINDOWED
     GFX_TYPE_FULLSCREEN
     GFX_TYPE_DEFINITE
     GFX_TYPE_MAGIC

     The return value will only be equivalent to GFX_TYPE_UNKNOWN when
     it is a driver unrecognized on that platform, or it is a bogus
     value.  Test for the other types by using a bitwise AND. If the
     driver is windowed or fullscreen, it will also have the definite
     flag set.  For example,

          int gfx_type = get_gfx_mode_type(GFX_AUTODETECT_WINDOWED);

     gfx_type would have the GFX_TYPE_WINDOWED, GFX_TYPE_DEFINITE, and
     GFX_TYPE_MAGIC flags set.

     Allegro needs to be initialized first.

     Example:

          /* Accept the use of only windowed drivers in our selection dialog */
          int accept_windowed(int card , int w , int h , int color_depth)
          {
             if (get_gfx_mode_type(card) & GFX_TYPE_WINDOWED)
                return 0;
             return 1;
          }

          /* In main: */
          gfx_mode_select_filter(&card, &w, &h, &color_depth, accept_windowed);

     Returns a bitfield describing the graphics mode type.

See also:
*Note gfx_mode_select_filter::.
*Note get_gfx_mode::.
*Note set_gfx_mode::.
*Note is_windowed_mode::.


File: allegro.info,  Node: get_gfx_mode,  Next: gfx_capabilities,  Prev: get_gfx_mode_type,  Up: Graphics

1.9.14 get_gfx_mode
-------------------

int get_gfx_mode();
     This function will let you determine which graphics driver is
     currently set by allegro.  If no graphics driver is set, it will
     return GFX_NONE.

     Returns the id of the current graphics driver if there is one, or
     GFX_NONE if none is set.

See also:
*Note set_gfx_mode::.
*Note is_windowed_mode::.


File: allegro.info,  Node: gfx_capabilities,  Next: enable_triple_buffer,  Prev: get_gfx_mode,  Up: Graphics

1.9.15 gfx_capabilities
-----------------------

extern int gfx_capabilities;
     Bitfield describing the capabilities of the current graphics driver
     and video hardware.  This may contain combination any of the flags:

     GFX_CAN_SCROLL:
     Indicates that the scroll_screen() function may be used with this
     driver.

     GFX_CAN_TRIPLE_BUFFER:
     Indicates that the request_scroll() and poll_scroll() functions may
     be used with this driver.  If this flag is not set, it is possible
     that the enable_triple_buffer() function may be able to activate
     it.

     GFX_HW_CURSOR:
     Indicates that a hardware mouse cursor is in use.  When this flag
     is set, it is safe to draw onto the screen without hiding the mouse
     pointer first.  Note that not every cursor graphic can be
     implemented in hardware: in particular VBE/AF only supports 2-color
     images up to 32x32 in size, where the second color is an exact
     inverse of the first.  This means that Allegro may need to switch
     between hardware and software cursors at any point during the
     execution of your program, so you should not assume that this flag
     will remain constant for long periods of time.  It only tells you
     whether a hardware cursor is in use at the current time, and may
     change whenever you hide/redisplay the pointer.

     GFX_SYSTEM_CURSOR
     Indicates that the mouse cursor is the default system cursor, not
     Allegro's custom cursor.

     GFX_HW_HLINE:
     Indicates that the normal opaque version of the hline() function is
     implemented using a hardware accelerator.  This will improve the
     performance not only of hline() itself, but also of many other
     functions that use it as a workhorse, for example circlefill(),
     triangle(), and floodfill().

     GFX_HW_HLINE_XOR:
     Indicates that the XOR version of the hline() function, and any
     other functions that use it as a workhorse, are implemented using a
     hardware accelerator.

     GFX_HW_HLINE_SOLID_PATTERN:
     Indicates that the solid and masked pattern modes of the hline()
     function, and any other functions that use it as a workhorse, are
     implemented using a hardware accelerator (see note below).

     GFX_HW_HLINE_COPY_PATTERN:
     Indicates that the copy pattern mode of the hline() function, and
     any other functions that use it as a workhorse, are implemented
     using a hardware accelerator (see note below).

     GFX_HW_FILL:
     Indicates that the opaque version of the rectfill() function, the
     clear_bitmap() routine, and clear_to_color(), are implemented using
     a hardware accelerator.

     GFX_HW_FILL_XOR:
     Indicates that the XOR version of the rectfill() function is
     implemented using a hardware accelerator.

     GFX_HW_FILL_SOLID_PATTERN:
     Indicates that the solid and masked pattern modes of the rectfill()
     function are implemented using a hardware accelerator (see note
     below).

     GFX_HW_FILL_COPY_PATTERN:
     Indicates that the copy pattern mode of the rectfill() function is
     implemented using a hardware accelerator (see note below).

     GFX_HW_LINE:
     Indicates that the opaque mode line() and vline() functions are
     implemented using a hardware accelerator.

     GFX_HW_LINE_XOR:
     Indicates that the XOR version of the line() and vline() functions
     are implemented using a hardware accelerator.

     GFX_HW_TRIANGLE:
     Indicates that the opaque mode triangle() function is implemented
     using a hardware accelerator.

     GFX_HW_TRIANGLE_XOR:
     Indicates that the XOR version of the triangle() function is
     implemented using a hardware accelerator.

     GFX_HW_GLYPH:
     Indicates that monochrome character expansion (for text drawing) is
     implemented using a hardware accelerator.

     GFX_HW_VRAM_BLIT:
     Indicates that blitting from one part of the screen to another is
     implemented using a hardware accelerator.  If this flag is set,
     blitting within the video memory will almost certainly be the
     fastest possible way to display an image, so it may be worth
     storing some of your more frequently used graphics in an offscreen
     portion of the video memory.

     GFX_HW_VRAM_BLIT_MASKED:
     Indicates that the masked_blit() routine is capable of a hardware
     accelerated copy from one part of video memory to another, and that
     draw_sprite() will use a hardware copy when given a sub-bitmap of
     the screen or a video memory bitmap as the source image.  If this
     flag is set, copying within the video memory will almost certainly
     be the fastest possible way to display an image, so it may be worth
     storing some of your more frequently used sprites in an offscreen
     portion of the video memory.

     Warning: if this flag is not set, masked_blit() and draw_sprite()
     will not work correctly when used with a video memory source image!
     You must only try to use these functions to copy within the video
     memory if they are supported in hardware.

     GFX_HW_MEM_BLIT:
     Indicates that blitting from a memory bitmap onto the screen is
     being accelerated in hardware.

     GFX_HW_MEM_BLIT_MASKED:
     Indicates that the masked_blit() and draw_sprite() functions are
     being accelerated in hardware when the source image is a memory
     bitmap and the destination is the physical screen.

     GFX_HW_SYS_TO_VRAM_BLIT:
     Indicates that blitting from a system bitmap onto the screen is
     being accelerated in hardware.  Note that some acceleration may be
     present even if this flag is not set, because system bitmaps can
     benefit from normal memory to screen blitting as well.  This flag
     will only be set if system bitmaps have further acceleration above
     and beyond what is provided by GFX_HW_MEM_BLIT.

     GFX_HW_SYS_TO_VRAM_BLIT_MASKED:
     Indicates that the masked_blit() and draw_sprite() functions are
     being accelerated in hardware when the source image is a system
     bitmap and the destination is the physical screen.  Note that some
     acceleration may be present even if this flag is not set, because
     system bitmaps can benefit from normal memory to screen blitting as
     well.  This flag will only be set if system bitmaps have further
     acceleration above and beyond what is provided by
     GFX_HW_MEM_BLIT_MASKED.

     GFX_HW_VRAM_STRETCH_BLIT:
     Indicates that stretched blitting of video bitmaps onto the screen
     is implemented using hardware acceleration.

     GFX_HW_SYS_STRETCH_BLIT:
     Indicates that stretched blitting of system bitmaps onto the screen
     is implemented using hardware acceleration.

     GFX_HW_VRAM_STRETCH_BLIT_MASKED:
     Indicates that masked stretched blitting (including stretch_sprite)
     of video bitmaps onto the screen is implemented using hardware
     acceleration.  NOTE: some display drivers may show artifacts when
     this function is used.  If the image does not look correct try
     updating your video drivers.

     GFX_HW_SYS_STRETCH_BLIT_MASKED:
     Indicates that masked stretched blitting (including stretch_sprite)
     of system bitmaps onto the screen is implemented using hardware
     acceleration.  NOTE: some display drivers may show artefact's when
     this function is used.  If the image does not look correct try
     updating your video drivers.

     Note: even if the capabilities information says that patterned
     drawing is supported by the hardware, it will not be possible for
     every size of pattern.  VBE/AF only supports patterns up to 8x8 in
     size, so Allegro will fall back on the original non-accelerated
     drawing routines whenever you use a pattern larger than this.

     Note2: these hardware acceleration features will only take effect
     when you are drawing directly onto the screen bitmap, a video
     memory bitmap, or a sub-bitmap thereof.  Accelerated hardware is
     most useful in a page flipping or triple buffering setup, and is
     unlikely to make any difference to the classic "draw onto a memory
     bitmap, then blit to the screen" system.

See also:
*Note screen::.
*Note create_video_bitmap::.
*Note scroll_screen::.
*Note request_scroll::.
*Note show_mouse::.
*Note enable_triple_buffer::.
*Note ex3buf::.
*Note exaccel::.
*Note exsyscur::.
*Note exupdate::.


File: allegro.info,  Node: enable_triple_buffer,  Next: scroll_screen,  Prev: gfx_capabilities,  Up: Graphics

1.9.16 enable_triple_buffer
---------------------------

int enable_triple_buffer();
     If the GFX_CAN_TRIPLE_BUFFER bit of the gfx_capabilities field is
     not set, you can attempt to enable it by calling this function.  In
     particular if you are running in mode-X in a clean DOS environment,
     this routine will enable the timer retrace simulator, which will
     activate the triple buffering functions.

     Returns zero if triple buffering is enabled, -1 otherwise.

See also:
*Note gfx_capabilities::.
*Note request_scroll::.
*Note request_video_bitmap::.
*Note ex3buf::.
*Note exupdate::.


File: allegro.info,  Node: scroll_screen,  Next: request_scroll,  Prev: enable_triple_buffer,  Up: Graphics

1.9.17 scroll_screen
--------------------

int scroll_screen(int x, int y);
     Attempts to scroll the hardware screen to display a different part
     of the virtual screen (initially it will be positioned at 0, 0,
     which is the top left corner).  You can use this to move the screen
     display around in a large virtual screen space, or to page flip
     back and forth between two non-overlapping areas of the virtual
     screen.  Note that to draw outside the original position in the
     screen bitmap you will have to alter the clipping rectangle with
     set_clip_rect().

     Mode-X scrolling is reliable and will work on any card, other
     drivers may not work or not work reliably.  See the
     platform-specific section of the docs for more information.

     Allegro will handle any necessary vertical retrace synchronisation
     when scrolling the screen, so you don't need to call vsync() before
     it.  This means that scroll_screen() has the same time delay
     effects as vsync().

     Returns zero on success.  Returns non-zero if the graphics driver
     can't handle hardware scrolling or the virtual screen is not large
     enough.

See also:
*Note set_gfx_mode::.
*Note show_video_bitmap::.
*Note request_scroll::.
*Note request_video_bitmap::.
*Note exscroll::.


File: allegro.info,  Node: request_scroll,  Next: poll_scroll,  Prev: scroll_screen,  Up: Graphics

1.9.18 request_scroll
---------------------

int request_scroll(int x, int y);
     This function is used for triple buffering.  It requests a hardware
     scroll to the specified position, but returns immediately rather
     than waiting for a retrace.  The scroll will then take place during
     the next vertical retrace, but you can carry on running other code
     in the meantime and use the poll_scroll() routine to detect when
     the flip has actually taken place.

     Triple buffering is only possible with certain drivers: you can
     look at the GFX_CAN_TRIPLE_BUFFER bit in the gfx_capabilities flag
     to see if it will work with the current driver.

     This function returns zero on success, non-zero otherwise.

See also:
*Note poll_scroll::.
*Note request_video_bitmap::.
*Note gfx_capabilities::.
*Note scroll_screen::.


File: allegro.info,  Node: poll_scroll,  Next: show_video_bitmap,  Prev: request_scroll,  Up: Graphics

1.9.19 poll_scroll
------------------

int poll_scroll();
     This function is used for triple buffering.  It checks the status
     of a hardware scroll previously initiated by the request_scroll()
     routine.

     Returns non-zero if it is still waiting to take place, and zero if
     the requested scroll has already happened.

See also:
*Note request_scroll::.
*Note request_video_bitmap::.
*Note ex3buf::.
*Note exupdate::.


File: allegro.info,  Node: show_video_bitmap,  Next: request_video_bitmap,  Prev: poll_scroll,  Up: Graphics

1.9.20 show_video_bitmap
------------------------

int show_video_bitmap(BITMAP *bitmap);
     Attempts to page flip the hardware screen to display the specified
     video bitmap object, which must be the same size as the physical
     screen, and should have been obtained by calling the
     create_video_bitmap() function.

     Allegro will handle any necessary vertical retrace synchronisation
     when page flipping, so you don't need to call vsync() before it.
     This means that show_video_bitmap() has the same time delay effects
     as vsync() by default.  This can be adjusted with the
     "disable_vsync" config key in the [graphics] section of
     allegro.cfg.  Example:

          int current_page;
          BITMAP *video_page[2];
          ...
          /* Create pages for page flipping */
          video_page[0] = create_video_bitmap(SCREEN_W, SCREEN_H);
          video_page[1] = create_video_bitmap(SCREEN_W, SCREEN_H);
          current_page = 0;
          ...
          /* draw the screen and flip pages */
          draw_screen(video_page[current_page]);
          show_video_bitmap(video_page[current_page]);
          current_page = (current_page+1)%2;
          ...

     Returns zero on success and non-zero on failure.

See also:
*Note scroll_screen::.
*Note create_video_bitmap::.
*Note Standard config variables::.
*Note exaccel::.
*Note exflip::.
*Note exupdate::.
*Note BITMAP::.


File: allegro.info,  Node: request_video_bitmap,  Next: vsync,  Prev: show_video_bitmap,  Up: Graphics

1.9.21 request_video_bitmap
---------------------------

int request_video_bitmap(BITMAP *bitmap);
     This function is used for triple buffering.  It requests a page
     flip to display the specified video bitmap object, but returns
     immediately rather than waiting for a retrace.  The flip will then
     take place during the next vertical retrace, but you can carry on
     running other code in the meantime and use the poll_scroll()
     routine to detect when the flip has actually taken place.  Triple
     buffering is only possible on certain hardware: see the comments
     about request_scroll().  Example:

          int current_page;
          BITMAP *video_page[3];
          ...
          /* Create pages for page flipping */
          video_page[0] = create_video_bitmap(SCREEN_W, SCREEN_H);
          video_page[1] = create_video_bitmap(SCREEN_W, SCREEN_H);
          video_page[2] = create_video_bitmap(SCREEN_W, SCREEN_H);
          current_page = 0;
          ...
          /* draw the screen and flip pages */
          draw_screen(video_page[current_page]);
          do {
          } while (poll_scroll());
          request_video_bitmap(video_page[current_page]);
          current_page = (current_page+1)%3;
          ...

     Returns zero on success and non-zero on failure.

See also:
*Note poll_scroll::.
*Note request_scroll::.
*Note gfx_capabilities::.
*Note create_video_bitmap::.
*Note scroll_screen::.
*Note ex3buf::.
*Note exupdate::.
*Note BITMAP::.


File: allegro.info,  Node: vsync,  Next: screen,  Prev: request_video_bitmap,  Up: Graphics

1.9.22 vsync
------------

void vsync();
     Waits for a vertical retrace to begin.  The retrace happens when
     the electron beam in your monitor has reached the bottom of the
     screen and is moving back to the top ready for another scan.
     During this short period the graphics card isn't sending any data
     to the monitor, so you can do things to it that aren't possible at
     other times, such as altering the palette without causing
     flickering (snow).  Allegro will automatically wait for a retrace
     before altering the palette or doing any hardware scrolling,
     though, so you don't normally need to bother with this function.

See also:
*Note set_palette::.
*Note scroll_screen::.
*Note Available Allegro examples: Available.


File: allegro.info,  Node: Bitmap,  Next: Loading,  Prev: Graphics,  Up: API

1.10 Bitmap objects
===================

Once you have selected a graphics mode, you can draw things onto the
display via the 'screen' bitmap.  All the Allegro graphics routines draw
onto BITMAP structures, which are areas of memory containing rectangular
images, stored as packed byte arrays (in 8-bit modes one byte per pixel,
in 15- and 16-bit modes two bytes per pixel, in 24-bit modes 3 bytes per
pixel and in 32-bit modes 4 bytes per pixel).  You can create and
manipulate bitmaps in system RAM, or you can write to the special
'screen' bitmap which represents the video memory in your graphics card.

Read chapter "Direct access to video memory" for information on how to
get direct access to the image memory in a bitmap.

Allegro supports several different types of bitmaps:

   * The 'screen' bitmap, which represents the hardware video memory.
     Ultimately you have to draw onto this in order for your image to be
     visible.  It is destroyed by any subsequent calls to
     set_gfx_mode(), so you should never attempt to destroy it yourself.
   * Memory bitmaps, which are located in system RAM and can be used to
     store graphics or as temporary drawing spaces for double buffered
     systems.  These can be obtained by calling create_bitmap(),
     load_pcx(), or by loading a grabber datafile.
   * Sub-bitmaps.  These share image memory with a parent bitmap (which
     can be the screen, a video or system bitmap, a memory bitmap, or
     another sub-bitmap), so drawing onto them will also change their
     parent.  They can be of any size and located anywhere within the
     parent bitmap, and can have their own clipping rectangles, so they
     are a useful way of dividing a bitmap into several smaller units,
     eg.  splitting a large virtual screen into multiple sections (see
     examples/exscroll.c).

     Warning: Make sure not to destroy a bitmap before all of its
     sub-bitmaps, otherwise bad things will happen when you try to
     access one of these sub-bitmaps.
   * Video memory bitmaps.  These are created by the
     create_video_bitmap() function, and are usually implemented as
     sub-bitmaps of the screen object.  They must be destroyed by
     destroy_bitmap() before any subsequent calls to set_gfx_mode().
   * System bitmaps.  These are created by the create_system_bitmap()
     function, and are a sort of halfway house between memory and video
     bitmaps.  They live in system memory, so you aren't limited by the
     amount of video ram in your card, but they are stored in a
     platform-specific format that may enable better hardware
     acceleration than is possible with a normal memory bitmap (see the
     GFX_HW_SYS_TO_VRAM_BLIT and GFX_HW_SYS_TO_VRAM_BLIT_MASKED flags in
     gfx_capabilities).  System bitmaps must be accessed in the same way
     as video bitmaps, using the bank switch functions and bmp_write*()
     macros.  Not every platform implements this type of bitmap: if they
     aren't available, create_system_bitmap() will function identically
     to create_bitmap().  They must be destroyed by destroy_bitmap()
     before any subsequent calls to set_gfx_mode().

* Menu:

* screen::
* SCREEN_W::
* VIRTUAL_W::
* create_bitmap::
* create_bitmap_ex::
* create_sub_bitmap::
* create_video_bitmap::
* create_system_bitmap::
* destroy_bitmap::
* lock_bitmap::
* bitmap_color_depth::
* bitmap_mask_color::
* is_same_bitmap::
* is_planar_bitmap::
* is_linear_bitmap::
* is_memory_bitmap::
* is_screen_bitmap::
* is_video_bitmap::
* is_system_bitmap::
* is_sub_bitmap::
* acquire_bitmap::
* release_bitmap::
* acquire_screen::
* release_screen::
* set_clip_rect::
* get_clip_rect::
* add_clip_rect::
* set_clip_state::
* get_clip_state::
* is_inside_bitmap::


File: allegro.info,  Node: screen,  Next: SCREEN_W,  Prev: vsync,  Up: Bitmap

1.10.1 screen
-------------

extern BITMAP *screen;
     Global pointer to a bitmap, sized VIRTUAL_W x VIRTUAL_H. This is
     created by set_gfx_mode(), and represents the hardware video
     memory.  Only a part of this bitmap will actually be visible, sized
     SCREEN_W x SCREEN_H. Normally this is the top left corner of the
     larger virtual screen, so you can ignore the extra invisible
     virtual size of the bitmap if you aren't interested in hardware
     scrolling or page flipping.  To move the visible window to other
     parts of the screen bitmap, call scroll_screen().  Initially the
     clipping rectangle will be limited to the physical screen size, so
     if you want to draw onto a larger virtual screen space outside this
     rectangle, you will need to adjust the clipping.

     For example, to draw a pixel onto the screen you would write:

          putpixel(screen, x, y, color);

     Or to implement a double-buffered system:

          /* Make a bitmap in RAM. */
          BITMAP *bmp = create_bitmap(320, 200);
          /* Clean the memory bitmap. */
          clear_bitmap(bmp);
          /* Draw onto the memory bitmap. */
          putpixel(bmp, x, y, color);
          /* Copy it to the screen. */
          blit(bmp, screen, 0, 0, 0, 0, 320, 200);

     Warning: be very careful when using this pointer at the same time
     as any bitmaps created by the create_video_bitmap() function (see
     the description of this function for more detailed information).
     And never try to destroy it with destroy_bitmap().

See also:
*Note set_gfx_mode::.
*Note is_screen_bitmap::.
*Note create_video_bitmap::.
*Note scroll_screen::.
*Note Available Allegro examples: Available.
*Note BITMAP::.


File: allegro.info,  Node: SCREEN_W,  Next: VIRTUAL_W,  Prev: screen,  Up: Bitmap

1.10.2 SCREEN_W
---------------

#define SCREEN_W;
#define SCREEN_H;
     Global defines that return the width and height of the screen, or
     zero if the screen has not been initialised yet.  Example:

          char buf[100];
          ...
          uszprintf(buf, sizeof(buf),
                    "The screen size is %d x %d pixels",
                    SCREEN_W, SCREEN_H);

See also:
*Note screen::.
*Note set_gfx_mode::.
*Note VIRTUAL_W::.
*Note VIRTUAL_H: VIRTUAL_W.
*Note Available Allegro examples: Available.


File: allegro.info,  Node: VIRTUAL_W,  Next: create_bitmap,  Prev: SCREEN_W,  Up: Bitmap

1.10.3 VIRTUAL_W
----------------

#define VIRTUAL_W;
#define VIRTUAL_H;
     Global defines that return the width and height of the virtual
     screen, or zero if the screen has not been initialised yet.
     Example:

          char buf[100];
          ...
          uszprintf(buf, sizeof(buf),
                    "The virtual screen size is %d x %d pixels",
                    SCREEN_W, SCREEN_H);

See also:
*Note screen::.
*Note set_gfx_mode::.
*Note SCREEN_W::.
*Note SCREEN_H: SCREEN_W.


File: allegro.info,  Node: create_bitmap,  Next: create_bitmap_ex,  Prev: VIRTUAL_W,  Up: Bitmap

1.10.4 create_bitmap
--------------------

BITMAP *create_bitmap(int width, int height);
     Creates a memory bitmap sized width by height.  The bitmap will
     have clipping turned on, and the clipping rectangle set to the full
     size of the bitmap.  The image memory will not be cleared, so it
     will probably contain garbage: you should clear the bitmap before
     using it.  This routine always uses the global pixel format, as
     specified by calling set_color_depth().  The minimum height of the
     BITMAP must be 1 and width can't be negative.  Example:

          /* Create a 10 pixel tall bitmap, as wide as the screen. */
          BITMAP *bmp = create_bitmap(SCREEN_W, 10);
          if (!bmp)
             abort_on_error("Couldn't create bitmap!");
          /* Use the bitmap. */
          ...
          /* Destroy it when we don't need it any more. */
          destroy_bitmap(bmp);

     Returns a pointer to the created bitmap, or NULL if the bitmap
     could not be created.  Remember to free this bitmap later to avoid
     memory leaks.

See also:
*Note create_bitmap_ex::.
*Note create_sub_bitmap::.
*Note create_video_bitmap::.
*Note create_system_bitmap::.
*Note destroy_bitmap::.
*Note set_color_depth::.
*Note is_memory_bitmap::.
*Note clear_bitmap::.
*Note clear_to_color::.
*Note Available Allegro examples: Available.
*Note BITMAP::.


File: allegro.info,  Node: create_bitmap_ex,  Next: create_sub_bitmap,  Prev: create_bitmap,  Up: Bitmap

1.10.5 create_bitmap_ex
-----------------------

BITMAP *create_bitmap_ex(int color_depth, int width, int height);
     Creates a bitmap in a specific color depth (8, 15, 16, 24 or 32
     bits per pixel).  Example:

          /* Create screen sized bitmap in 32 bits per pixel. */
          BITMAP *bmp = create_bitmap_ex(32, SCREEN_W, SCREEN_H);
          if (!bmp)
             abort_on_error("Couldn't create bitmap!");
          /* Use the bitmap. */
          ...
          /* Destroy it when we don't need it any more. */
          destroy_bitmap(bmp);

     Returns a pointer to the created bitmap, or NULL if the bitmap
     could not be created.  Remember to free this bitmap later to avoid
     memory leaks.

See also:
*Note create_bitmap::.
*Note create_sub_bitmap::.
*Note create_video_bitmap::.
*Note create_system_bitmap::.
*Note destroy_bitmap::.
*Note is_memory_bitmap::.
*Note clear_bitmap::.
*Note clear_to_color::.
*Note ex12bit::.
*Note exlights::.
*Note exrgbhsv::.
*Note extrans::.
*Note BITMAP::.


File: allegro.info,  Node: create_sub_bitmap,  Next: create_video_bitmap,  Prev: create_bitmap_ex,  Up: Bitmap

1.10.6 create_sub_bitmap
------------------------

BITMAP *create_sub_bitmap(BITMAP *parent, int x, y, width, height);
     Creates a sub-bitmap, ie.  a bitmap sharing drawing memory with a
     pre-existing bitmap, but possibly with a different size and
     clipping settings.  When creating a sub-bitmap of the mode-X
     screen, the x position must be a multiple of four.  The sub-bitmap
     width and height can extend beyond the right and bottom edges of
     the parent (they will be clipped), but the origin point must lie
     within the parent region.

     Returns a pointer to the created sub bitmap, or NULL if the sub
     bitmap could not be created.  Remember to free the sub bitmap
     before freeing the parent bitmap to avoid memory leaks and
     potential crashes accessing memory which has been freed.

See also:
*Note create_bitmap::.
*Note create_bitmap_ex::.
*Note destroy_bitmap::.
*Note is_sub_bitmap::.
*Note clear_bitmap::.
*Note clear_to_color::.
*Note expat::.
*Note exscroll::.
*Note exswitch::.
*Note BITMAP::.


File: allegro.info,  Node: create_video_bitmap,  Next: create_system_bitmap,  Prev: create_sub_bitmap,  Up: Bitmap

1.10.7 create_video_bitmap
--------------------------

BITMAP *create_video_bitmap(int width, int height);
     Allocates a video memory bitmap of the specified size.  This can be
     used to allocate offscreen video memory for storing source graphics
     ready for a hardware accelerated blitting operation, or to create
     multiple video memory pages which can then be displayed by calling
     show_video_bitmap().  Read the introduction of this chapter for a
     comparison with other types of bitmaps and other specific details.

     Warning: video memory bitmaps are usually allocated from the same
     space as the screen bitmap, so they may overlap with it; it is
     therefore not a good idea to use the global screen at the same time
     as any surfaces returned by this function.

     Returns a pointer to the bitmap on success, or NULL if you have run
     out of video ram.  Remember to destroy this bitmap before any
     subsequent call to set_gfx_mode().

See also:
*Note create_bitmap::.
*Note create_bitmap_ex::.
*Note create_system_bitmap::.
*Note create_sub_bitmap::.
*Note destroy_bitmap::.
*Note screen::.
*Note show_video_bitmap::.
*Note gfx_capabilities::.
*Note is_video_bitmap::.
*Note clear_bitmap::.
*Note clear_to_color::.
*Note ex3buf::.
*Note exaccel::.
*Note exflip::.
*Note exupdate::.
*Note BITMAP::.


File: allegro.info,  Node: create_system_bitmap,  Next: destroy_bitmap,  Prev: create_video_bitmap,  Up: Bitmap

1.10.8 create_system_bitmap
---------------------------

BITMAP *create_system_bitmap(int width, int height);
     Allocates a system memory bitmap of the specified size.  Read the
     introduction of this chapter for a comparison with other types of
     bitmaps and other specific details.

     Returns a pointer to the bitmap on success, NULL otherwise.
     Remember to destroy this bitmap before any subsequent call to
     set_gfx_mode().

See also:
*Note create_bitmap::.
*Note create_bitmap_ex::.
*Note create_video_bitmap::.
*Note create_sub_bitmap::.
*Note destroy_bitmap::.
*Note is_system_bitmap::.
*Note clear_bitmap::.
*Note clear_to_color::.
*Note exupdate::.
*Note BITMAP::.


File: allegro.info,  Node: destroy_bitmap,  Next: lock_bitmap,  Prev: create_system_bitmap,  Up: Bitmap

1.10.9 destroy_bitmap
---------------------

void destroy_bitmap(BITMAP *bitmap);
     Destroys a memory bitmap, sub-bitmap, video memory bitmap, or
     system bitmap when you are finished with it.  If you pass a NULL
     pointer this function won't do anything.  See above for the
     restrictions as to when you are allowed to destroy the various
     types of bitmaps.

     The bitmap must not have a mouse cursor shown on it at the time it
     is destroyed.

See also:
*Note create_bitmap::.
*Note load_bitmap::.
*Note show_mouse::.
*Note Available Allegro examples: Available.
*Note BITMAP::.


File: allegro.info,  Node: lock_bitmap,  Next: bitmap_color_depth,  Prev: destroy_bitmap,  Up: Bitmap

1.10.10 lock_bitmap
-------------------

void lock_bitmap(BITMAP *bitmap);
     Under DOS, locks all the memory used by a bitmap.  You don't
     normally need to call this function unless you are doing very weird
     things in your program.

*Note BITMAP::.


File: allegro.info,  Node: bitmap_color_depth,  Next: bitmap_mask_color,  Prev: lock_bitmap,  Up: Bitmap

1.10.11 bitmap_color_depth
--------------------------

int bitmap_color_depth(BITMAP *bmp);
     Returns the color depth of the specified bitmap (8, 15, 16, 24, or
     32).  Example:

          switch (bitmap_color_depth(screen)) {
             case 8:
                /* Access screen using optimized 8-bit code. */
                break;
             default:
                /* Use generic slow functions. */
                break;
          }

See also:
*Note set_color_depth::.
*Note bitmap_mask_color::.
*Note ex3d::.
*Note exlights::.
*Note exscn3d::.
*Note exswitch::.
*Note extrans::.
*Note exupdate::.
*Note exzbuf::.
*Note BITMAP::.


File: allegro.info,  Node: bitmap_mask_color,  Next: is_same_bitmap,  Prev: bitmap_color_depth,  Up: Bitmap

1.10.12 bitmap_mask_color
-------------------------

int bitmap_mask_color(BITMAP *bmp);
     Returns the mask color for the specified bitmap (the value which is
     skipped when drawing sprites).  For 256-color bitmaps this is zero,
     and for truecolor bitmaps it is bright pink (maximum red and blue,
     zero green).  A frequent use of this function is to clear a bitmap
     with the mask color so you can later use this bitmap with
     masked_blit() or draw_sprite() after drawing other stuff on it.
     Example:

          /* Replace mask color with another color. */
          for (y = 0; y h; y++)
             for (x = 0; x w; x++)
                if (getpixel(bmp, x, y) == bitmap_mask_color(bmp))
                   putpixel(bmp, x, y, another_color);

See also:
*Note MASK_COLOR_8::.
*Note set_color_depth::.
*Note bitmap_color_depth::.
*Note ex3d::.
*Note exmouse::.
*Note expat::.
*Note BITMAP::.


File: allegro.info,  Node: is_same_bitmap,  Next: is_planar_bitmap,  Prev: bitmap_mask_color,  Up: Bitmap

1.10.13 is_same_bitmap
----------------------

int is_same_bitmap(BITMAP *bmp1, BITMAP *bmp2);
     Returns TRUE if the two bitmaps describe the same drawing surface,
     ie.  the pointers are equal, one is a sub-bitmap of the other, or
     they are both sub-bitmaps of a common parent.

See also:
*Note create_sub_bitmap::.
*Note BITMAP::.


File: allegro.info,  Node: is_planar_bitmap,  Next: is_linear_bitmap,  Prev: is_same_bitmap,  Up: Bitmap

1.10.14 is_planar_bitmap
------------------------

int is_planar_bitmap(BITMAP *bmp);
     Returns TRUE if bmp is a planar (mode-X or Xtended mode) screen
     bitmap.

See also:
*Note is_linear_bitmap::.
*Note is_memory_bitmap::.
*Note BITMAP::.


File: allegro.info,  Node: is_linear_bitmap,  Next: is_memory_bitmap,  Prev: is_planar_bitmap,  Up: Bitmap

1.10.15 is_linear_bitmap
------------------------

int is_linear_bitmap(BITMAP *bmp);
     Returns TRUE if bmp is a linear bitmap, i.e.  a bitmap that can be
     accessed linearly within each scanline (for example a memory
     bitmap, the DOS VGA or SVGA screen, Windows bitmaps, etc).  Linear
     bitmaps can be used with the _putpixel(), _getpixel(),
     bmp_write_line(), and bmp_read_line() functions.

     Historically there were only linear and planar bitmaps for Allegro,
     so is_linear_bitmap() is actually an alias for !is_planar_bitmap().

See also:
*Note is_planar_bitmap::.
*Note is_memory_bitmap::.
*Note BITMAP::.


File: allegro.info,  Node: is_memory_bitmap,  Next: is_screen_bitmap,  Prev: is_linear_bitmap,  Up: Bitmap

1.10.16 is_memory_bitmap
------------------------

int is_memory_bitmap(BITMAP *bmp);
     Returns TRUE if bmp is a memory bitmap, ie.  it was created by
     calling create_bitmap() or loaded from a grabber datafile or image
     file.  Memory bitmaps can be accessed directly via the line
     pointers in the bitmap structure, eg.  bmp->line[y][x] = color.

See also:
*Note is_linear_bitmap::.
*Note is_planar_bitmap::.
*Note BITMAP::.


File: allegro.info,  Node: is_screen_bitmap,  Next: is_video_bitmap,  Prev: is_memory_bitmap,  Up: Bitmap

1.10.17 is_screen_bitmap
------------------------

int is_screen_bitmap(BITMAP *bmp);
     Returns TRUE if bmp is the screen bitmap, or a sub-bitmap of the
     screen.

See also:
*Note screen::.
*Note create_sub_bitmap::.
*Note BITMAP::.


File: allegro.info,  Node: is_video_bitmap,  Next: is_system_bitmap,  Prev: is_screen_bitmap,  Up: Bitmap

1.10.18 is_video_bitmap
-----------------------

int is_video_bitmap(BITMAP *bmp);
     Returns TRUE if bmp is the screen bitmap, a video memory bitmap, or
     a sub-bitmap of either.

See also:
*Note screen::.
*Note create_video_bitmap::.
*Note create_sub_bitmap::.
*Note BITMAP::.


File: allegro.info,  Node: is_system_bitmap,  Next: is_sub_bitmap,  Prev: is_video_bitmap,  Up: Bitmap

1.10.19 is_system_bitmap
------------------------

int is_system_bitmap(BITMAP *bmp);
     Returns TRUE if bmp is a system bitmap object, or a sub-bitmap of
     one.

See also:
*Note create_system_bitmap::.
*Note create_sub_bitmap::.
*Note BITMAP::.


File: allegro.info,  Node: is_sub_bitmap,  Next: acquire_bitmap,  Prev: is_system_bitmap,  Up: Bitmap

1.10.20 is_sub_bitmap
---------------------

int is_sub_bitmap(BITMAP *bmp);
     Returns TRUE if bmp is a sub-bitmap.

See also:
*Note create_sub_bitmap::.
*Note BITMAP::.


File: allegro.info,  Node: acquire_bitmap,  Next: release_bitmap,  Prev: is_sub_bitmap,  Up: Bitmap

1.10.21 acquire_bitmap
----------------------

void acquire_bitmap(BITMAP *bmp);
     Acquires the specified video bitmap prior to drawing onto it.  You
     never need to call the function explicitly as it is low level, and
     will only give you a speed up if you know what you are doing.
     Using it wrongly may cause slowdown, or even lock up your program.

     Note: You do never need to use acquire_bitmap on a memory bitmap,
     i.e.  a normal bitmap created with create_bitmap.  It will simply
     do nothing in that case.

     It still can be useful, because e.g.  under the current DirectDraw
     driver of Allegro, most drawing functions need to lock a video
     bitmap before drawing to it.  But doing this is very slow, so you
     will get much better performance if you acquire the screen just
     once at the start of your main redraw function, then call multiple
     drawing operations which need the bitmap locked, and only release
     it when done.

     Multiple acquire calls may be nested, but you must make sure to
     match up the acquire_bitmap and release_bitmap calls.  Be warned
     that DirectX and X11 programs activate a mutex lock whenever a
     surface is locked, which prevents them from getting any input
     messages, so you must be sure to release all your bitmaps before
     using any timer, keyboard, or other non-graphics routines!

     Note that if you are using hardware accelerated VRAM->VRAM
     functions, you should not call acquire_bitmap().  Such functions
     need an unlocked target bitmap under DirectX, so there is now just
     the opposite case from before - if the bitmap is already locked
     with acquire_bitmap, the drawing operation has to unlock it.

     Note: For backwards compatibility, the unlocking behavior of such
     functions is permanent.  That is, if you call acquire_bitmap first,
     then call e.g.  an accelerated blit, the DirectX bitmap will be
     unlocked internally (it won't affect the nesting counter of
     acquire/release calls).

     There is no clear cross-platform way in this Allegro version to
     know which drawing operations need a locked/unlocked state.  For
     example a normal rectfill most probably is accelerated under
     DirectX, and therefore needs the screen unlocked, but an XOR
     rectfill, or one with blending activated, most probably is not, and
     therefore locks the screen.  And while the DirectX driver will do
     automatic unlocking, there is no such thing under X11, where the
     function is used to synchronize X11 calls from different threads.
     Your best bet is to never use acquire_bitmap - changes are you are
     doing something in the wrong way if you think you need it.

     Warning: This function can be very dangerous to use, since the
     whole program may get locked while the bitmap is locked.  So the
     lock should only be held for a short time, and you should not call
     anything but drawing operations onto the locked video bitmap while
     a lock is in place.  Especially don't call things like show_mouse
     (or scare_mouse which calls that) or readkey, since it will most
     likely deadlock your entire program.

See also:
*Note release_bitmap::.
*Note acquire_screen::.
*Note release_screen::.
*Note ex3buf::.
*Note exaccel::.
*Note expat::.
*Note exquat::.
*Note exscroll::.
*Note exswitch::.
*Note exupdate::.
*Note BITMAP::.


File: allegro.info,  Node: release_bitmap,  Next: acquire_screen,  Prev: acquire_bitmap,  Up: Bitmap

1.10.22 release_bitmap
----------------------

void release_bitmap(BITMAP *bmp);
     Releases a bitmap that was previously locked by calling
     acquire_bitmap().  If the bitmap was locked multiple times, you
     must release it the same number of times before it will truly be
     unlocked.

See also:
*Note acquire_bitmap::.
*Note acquire_screen::.
*Note release_screen::.
*Note ex3buf::.
*Note exaccel::.
*Note expat::.
*Note exquat::.
*Note exscroll::.
*Note exswitch::.
*Note exupdate::.
*Note BITMAP::.


File: allegro.info,  Node: acquire_screen,  Next: release_screen,  Prev: release_bitmap,  Up: Bitmap

1.10.23 acquire_screen
----------------------

void acquire_screen();
     Shortcut version of acquire_bitmap(screen);

See also:
*Note acquire_bitmap::.
*Note release_bitmap::.
*Note release_screen::.
*Note Available Allegro examples: Available.


File: allegro.info,  Node: release_screen,  Next: set_clip_rect,  Prev: acquire_screen,  Up: Bitmap

1.10.24 release_screen
----------------------

void release_screen();
     Shortcut version of release_bitmap(screen);

See also:
*Note acquire_bitmap::.
*Note release_bitmap::.
*Note acquire_screen::.
*Note Available Allegro examples: Available.


File: allegro.info,  Node: set_clip_rect,  Next: get_clip_rect,  Prev: release_screen,  Up: Bitmap

1.10.25 set_clip_rect
---------------------

void set_clip_rect(BITMAP *bitmap, int x1, int y1, int x2, int y2);
     Each bitmap has an associated clipping rectangle, which is the area
     of the image that it is OK to draw onto.  Nothing will be drawn to
     positions outside this space.  This function sets the clipping
     rectangle for the specified bitmap.  Pass the coordinates of the
     top-left and bottom-right corners of the clipping rectangle in this
     order; these are both inclusive, i.e.  set_clip_rect(bitmap, 16,
     16, 32, 32) will allow drawing to (16, 16) and (32, 32), but not to
     (15, 15) and (33, 33).

     Drawing operations will be performed (at least partially) on the
     bitmap as long as the first coordinates of its clipping rectangle
     are not greater than the second coordinates and its intersection
     with the actual image is non-empty.  If either condition is not
     fulfilled, drawing will be turned off for the bitmap, e.g.

          set_clip_rect(bmp, 0, 0, -1, -1); /* disable drawing on bmp */

     Note that passing "out-of-bitmap" coordinates is allowed, but they
     are likely to be altered (and so the coordinates returned by
     get_clip_rect() will be different).  However, such modifications
     are guaranteed to preserve the external effect of the clipping
     rectangle, that is not to modify the actual area of the image that
     it is OK to draw onto.

See also:
*Note get_clip_rect::.
*Note add_clip_rect::.
*Note set_clip_state::.
*Note get_clip_state::.
*Note ex12bit::.
*Note excamera::.
*Note BITMAP::.


File: allegro.info,  Node: get_clip_rect,  Next: add_clip_rect,  Prev: set_clip_rect,  Up: Bitmap

1.10.26 get_clip_rect
---------------------

void get_clip_rect(BITMAP *bitmap, int *x1, int *y1, int *x2, int *y2);
     Returns the clipping rectangle for the specified bitmap.

See also:
*Note set_clip_rect::.
*Note add_clip_rect::.
*Note set_clip_state::.
*Note get_clip_state::.
*Note BITMAP::.


File: allegro.info,  Node: add_clip_rect,  Next: set_clip_state,  Prev: get_clip_rect,  Up: Bitmap

1.10.27 add_clip_rect
---------------------

void add_clip_rect(BITMAP *bitmap, int x1, int y1, int x2, int y2);
     Sets the clipping rectangle of the specified bitmap as the
     intersection of its current clipping rectangle and the rectangle
     described by the four coordinates.

See also:
*Note set_clip_rect::.
*Note get_clip_rect::.
*Note set_clip_state::.
*Note get_clip_state::.
*Note BITMAP::.


File: allegro.info,  Node: set_clip_state,  Next: get_clip_state,  Prev: add_clip_rect,  Up: Bitmap

1.10.28 set_clip_state
----------------------

void set_clip_state(BITMAP *bitmap, int state)
     Turns on (if state is non-zero) or off (if state is zero) clipping
     for the specified bitmap.  Turning clipping off may slightly speed
     up some drawing operations (usually a negligible difference,
     although every little helps) but will result in your program dying
     a horrible death if you try to draw beyond the edges of the bitmap.

See also:
*Note set_clip_rect::.
*Note get_clip_rect::.
*Note add_clip_rect::.
*Note get_clip_state::.
*Note BITMAP::.


File: allegro.info,  Node: get_clip_state,  Next: is_inside_bitmap,  Prev: set_clip_state,  Up: Bitmap

1.10.29 get_clip_state
----------------------

int get_clip_state(BITMAP *bitmap)
     Returns non-zero if clipping is turned on for the specified bitmap
     and zero otherwise.

See also:
*Note set_clip_rect::.
*Note get_clip_rect::.
*Note add_clip_rect::.
*Note set_clip_state::.
*Note BITMAP::.


File: allegro.info,  Node: is_inside_bitmap,  Next: load_bitmap,  Prev: get_clip_state,  Up: Bitmap

1.10.30 is_inside_bitmap
------------------------

int is_inside_bitmap(BITMAP *bmp, int x, int y, int clip);
     Returns non-zero if point (x, y) lies inside the bitmap.  If 'clip'
     is non-zero, the function compares the coordinates with the
     clipping rectangle, that is it returns non-zero if the point lies
     inside the clipping rectangle or if clipping is disabled for the
     bitmap.  If 'clip' is zero, the function compares the coordinates
     with the actual dimensions of the bitmap.

See also:
*Note set_clip_rect::.
*Note set_clip_state::.
*Note getpixel::.
*Note BITMAP::.


File: allegro.info,  Node: Loading,  Next: Palette,  Prev: Bitmap,  Up: API

1.11 Loading image files
========================

Warning: when using truecolor images, you should always set the graphics
mode before loading any bitmap data!  Otherwise the pixel format (RGB or
BGR) will not be known, so the file may be converted wrongly.

* Menu:

* load_bitmap::
* load_bmp::
* load_bmp_pf::
* load_lbm::
* load_pcx::
* load_pcx_pf::
* load_tga::
* load_tga_pf::
* save_bitmap::
* save_bmp::
* save_bmp_pf::
* save_pcx::
* save_pcx_pf::
* save_tga::
* save_tga_pf::
* register_bitmap_file_type::
* set_color_conversion::
* get_color_conversion::


File: allegro.info,  Node: load_bitmap,  Next: load_bmp,  Prev: is_inside_bitmap,  Up: Loading

1.11.1 load_bitmap
------------------

BITMAP *load_bitmap(const char *filename, RGB *pal);
     Loads a bitmap from a file.  The palette data will be stored in the
     second parameter, which should be an array of 256 RGB structures.
     At present this function supports BMP, LBM, PCX, and TGA files,
     determining the type from the file extension.

     If the file contains a truecolor image, you must set the video mode
     or call set_color_conversion() before loading it.  In this case, if
     the destination color depth is 8-bit, the palette will be generated
     by calling generate_optimized_palette() on the bitmap; otherwise,
     the returned palette will be generated by calling
     generate_332_palette().

     The pal argument may be NULL. In this case, the palette data are
     simply not returned.  Additionally, if the file is a truecolor
     image and the destination color depth is 8-bit, the color
     conversion process will use the current palette instead of
     generating an optimized one.

     Example:

          BITMAP *bmp;
          PALETTE palette;
          ...
          bmp = load_bitmap("image.pcx", palette);
          if (!bmp)
             abort_on_error("Couldn't load image.pcx!");
          ...
          destroy_bitmap(bmp);

     Returns a pointer to the bitmap or NULL on error.  Remember that
     you are responsible for destroying the bitmap when you are finished
     with it to avoid memory leaks.

See also:
*Note load_bmp::.
*Note load_lbm::.
*Note load_pcx::.
*Note load_tga::.
*Note destroy_bitmap::.
*Note save_bitmap::.
*Note register_bitmap_file_type::.
*Note set_color_depth::.
*Note set_color_conversion::.
*Note generate_optimized_palette::.
*Note generate_332_palette::.
*Note Available Allegro examples: Available.
*Note BITMAP::.
*Note RGB::.


File: allegro.info,  Node: load_bmp,  Next: load_bmp_pf,  Prev: load_bitmap,  Up: Loading

1.11.2 load_bmp
---------------

BITMAP *load_bmp(const char *filename, RGB *pal);
     Loads an 8-bit, 16-bit, 24-bit or 32-bit Windows or OS/2 BMP file.

     Returns a pointer to the bitmap or NULL on error.  Remember that
     you are responsible for destroying the bitmap when you are finished
     with it to avoid memory leaks.

See also:
*Note load_bitmap::.
*Note load_bmp_pf::.
*Note BITMAP::.
*Note RGB::.


File: allegro.info,  Node: load_bmp_pf,  Next: load_lbm,  Prev: load_bmp,  Up: Loading

1.11.3 load_bmp_pf
------------------

BITMAP *load_bmp_pf(PACKFILE *f, RGB *pal);
     A version of load_bmp() which reads from a packfile.  Example:

          PACKFILE *packfile;
          BITMAP *bmp;

          packfile = pack_fopen("mybitmap.bmp", F_READ);
          if (!packfile)
             abort_on_error("Couldn't open mybitmap.bmp");

          bmp = load_bmp_pf(packfile, pal);
          if (!bmp)
             abort_on_error("Error loading mybitmap.bmp");

     Returns a pointer to the bitmap or NULL on error.  Remember that
     you are responsible for destroying the bitmap when you are finished
     with it to avoid memory leaks.

See also:
*Note load_bmp::.
*Note expackf::.
*Note BITMAP::.
*Note RGB::.
*Note PACKFILE::.


File: allegro.info,  Node: load_lbm,  Next: load_pcx,  Prev: load_bmp_pf,  Up: Loading

1.11.4 load_lbm
---------------

BITMAP *load_lbm(const char *filename, RGB *pal);
     Loads a 256-color IFF ILBM/PBM file.

     Returns a pointer to the bitmap or NULL on error.  Remember that
     you are responsible for destroying the bitmap when you are finished
     with it to avoid memory leaks.

See also:
*Note load_bitmap::.
*Note BITMAP::.
*Note RGB::.


File: allegro.info,  Node: load_pcx,  Next: load_pcx_pf,  Prev: load_lbm,  Up: Loading

1.11.5 load_pcx
---------------

BITMAP *load_pcx(const char *filename, RGB *pal);
     Loads a 256-color or 24-bit truecolor PCX file.

     Returns a pointer to the bitmap or NULL on error.  Remember that
     you are responsible for destroying the bitmap when you are finished
     with it to avoid memory leaks.

See also:
*Note load_bitmap::.
*Note expackf::.
*Note exscale::.
*Note BITMAP::.
*Note RGB::.


File: allegro.info,  Node: load_pcx_pf,  Next: load_tga,  Prev: load_pcx,  Up: Loading

1.11.6 load_pcx_pf
------------------

BITMAP *load_pcx_pf(PACKFILE *f, RGB *pal);
     A version of load_pcx() which reads from a packfile.  Example:

          PACKFILE *packfile;
          BITMAP *bmp;

          packfile = pack_fopen("mybitmap.pcx", F_READ);
          if (!packfile)
             abort_on_error("Couldn't open mybitmap.pcx");

          bmp = load_bmp_pf(packfile, pal);
          if (!bmp)
             abort_on_error("Error loading mybitmap.pcx");

     Returns a pointer to the bitmap or NULL on error.  Remember that
     you are responsible for destroying the bitmap when you are finished
     with it to avoid memory leaks.

See also:
*Note load_pcx::.
*Note expackf::.
*Note BITMAP::.
*Note RGB::.
*Note PACKFILE::.


File: allegro.info,  Node: load_tga,  Next: load_tga_pf,  Prev: load_pcx_pf,  Up: Loading

1.11.7 load_tga
---------------

BITMAP *load_tga(const char *filename, RGB *pal);
     Loads a 256-color, 15-bit hicolor, 24-bit truecolor, or 32-bit
     truecolor+alpha TGA file.

     Returns a pointer to the bitmap or NULL on error.  Remember that
     you are responsible for destroying the bitmap when you are finished
     with it to avoid memory leaks.

See also:
*Note load_bitmap::.
*Note BITMAP::.
*Note RGB::.


File: allegro.info,  Node: load_tga_pf,  Next: save_bitmap,  Prev: load_tga,  Up: Loading

1.11.8 load_tga_pf
------------------

BITMAP *load_tga_pf(PACKFILE *f, RGB *pal);
     A version of load_tga() which reads from a packfile.  Example:

          PACKFILE *packfile;
          BITMAP *bmp;

          packfile = pack_fopen("mybitmap.tga", F_READ);
          if (!packfile)
             abort_on_error("Couldn't open mybitmap.tga");

          bmp = load_bmp_pf(packfile, pal);
          if (!bmp)
             abort_on_error("Error loading mybitmap.tga");

     Returns a pointer to the bitmap or NULL on error.  Remember that
     you are responsible for destroying the bitmap when you are finished
     with it to avoid memory leaks.

See also:
*Note load_tga::.
*Note expackf::.
*Note BITMAP::.
*Note RGB::.
*Note PACKFILE::.


File: allegro.info,  Node: save_bitmap,  Next: save_bmp,  Prev: load_tga_pf,  Up: Loading

1.11.9 save_bitmap
------------------

int save_bitmap(const char *filename, BITMAP *bmp, const RGB *pal);
     Writes a bitmap into a file, using the specified palette, which
     should be an array of 256 RGB structures.  The output format is
     determined from the filename extension: at present this function
     supports BMP, PCX and TGA formats.

     Two things to watch out for: on some video cards it may be faster
     to copy the screen to a memory bitmap and save the latter, and if
     you use this to dump the screen into a file you may end up with an
     image much larger than you were expecting, because Allegro often
     creates virtual screens larger than the visible screen.  You can
     get around this by using a sub-bitmap to specify which part of the
     screen to save, eg:

          BITMAP *bmp;
          PALETTE pal;
          ...
          get_palette(pal);
          bmp = create_sub_bitmap(screen, 0, 0, SCREEN_W, SCREEN_H);
          save_bitmap("dump.pcx", bmp, pal);
          destroy_bitmap(bmp);

     Returns non-zero on error.

See also:
*Note save_bmp::.
*Note save_pcx::.
*Note save_tga::.
*Note load_bitmap::.
*Note register_bitmap_file_type::.
*Note BITMAP::.
*Note RGB::.


File: allegro.info,  Node: save_bmp,  Next: save_bmp_pf,  Prev: save_bitmap,  Up: Loading

1.11.10 save_bmp
----------------

int save_bmp(const char *filename, BITMAP *bmp, const RGB *pal);
     Writes a bitmap into a 256-color or 24-bit truecolor BMP file.

     Returns non-zero on error.

See also:
*Note save_bitmap::.
*Note BITMAP::.
*Note RGB::.


File: allegro.info,  Node: save_bmp_pf,  Next: save_pcx,  Prev: save_bmp,  Up: Loading

1.11.11 save_bmp_pf
-------------------

int save_bmp_pf(PACKFILE *f, BITMAP *bmp, RGB *pal);
     A version of save_bmp which writes to a packfile.

See also:
*Note save_bmp::.
*Note expackf::.
*Note BITMAP::.
*Note RGB::.
*Note PACKFILE::.


File: allegro.info,  Node: save_pcx,  Next: save_pcx_pf,  Prev: save_bmp_pf,  Up: Loading

1.11.12 save_pcx
----------------

int save_pcx(const char *filename, BITMAP *bmp, const RGB *pal);
     Writes a bitmap into a 256-color or 24-bit truecolor PCX file.

     Returns non-zero on error.

See also:
*Note save_bitmap::.
*Note BITMAP::.
*Note RGB::.


File: allegro.info,  Node: save_pcx_pf,  Next: save_tga,  Prev: save_pcx,  Up: Loading

1.11.13 save_pcx_pf
-------------------

int save_pcx_pf(PACKFILE *f, BITMAP *bmp, RGB *pal);
     A version of save_pcx which writes to a packfile.

See also:
*Note save_pcx::.
*Note BITMAP::.
*Note RGB::.
*Note PACKFILE::.


File: allegro.info,  Node: save_tga,  Next: save_tga_pf,  Prev: save_pcx_pf,  Up: Loading

1.11.14 save_tga
----------------

int save_tga(const char *filename, BITMAP *bmp, const RGB *pal);
     Writes a bitmap into a 256-color, 15-bit hicolor, 24-bit truecolor,
     or 32-bit truecolor+alpha TGA file.

     Returns non-zero on error.

See also:
*Note save_bitmap::.
*Note BITMAP::.
*Note RGB::.


File: allegro.info,  Node: save_tga_pf,  Next: register_bitmap_file_type,  Prev: save_tga,  Up: Loading

1.11.15 save_tga_pf
-------------------

int save_tga_pf(PACKFILE *f, BITMAP *bmp, RGB *pal);
     A version of save_tga which writes to a packfile.

See also:
*Note save_tga::.
*Note expackf::.
*Note BITMAP::.
*Note RGB::.
*Note PACKFILE::.


File: allegro.info,  Node: register_bitmap_file_type,  Next: set_color_conversion,  Prev: save_tga_pf,  Up: Loading

1.11.16 register_bitmap_file_type
---------------------------------

void register_bitmap_file_type(const char *ext, BITMAP *(*load)(const char *filename, RGB *pal), int (*save)(const char *filename, BITMAP *bmp, const RGB *pal));
     Informs the load_bitmap() and save_bitmap() functions of a new file
     type, providing routines to read and write images in this format
     (either function may be NULL). The functions you supply must follow
     the same prototype as load_bitmap() and save_bitmap().  Example:

          BITMAP *load_dump(const char *filename, RGB *pal)
          {
             ...
          }

          int save_dump(const char *filename, BITMAP *bmp, const RGB *pal)
          {
             ...
          }

             register_bitmap_file_type("dump", load_dump, save_dump);

See also:
*Note load_bitmap::.
*Note save_bitmap::.
*Note BITMAP::.
*Note RGB::.


File: allegro.info,  Node: set_color_conversion,  Next: get_color_conversion,  Prev: register_bitmap_file_type,  Up: Loading

1.11.17 set_color_conversion
----------------------------

void set_color_conversion(int mode);
     Specifies how to convert images between the various color depths
     when reading graphics from external bitmap files or datafiles.  The
     mode is a bitmask specifying which types of conversion are allowed.
     If the appropriate bit is set, data will be converted into the
     current pixel format (selected by calling the set_color_depth()
     function), otherwise it will be left in the same format as the disk
     file, leaving you to convert it manually before the graphic can be
     displayed.  The default mode is total conversion, so that all
     images will be loaded in the appropriate format for the current
     video mode.  Valid bit flags are:

          COLORCONV_NONE                // disable all format
                                        // conversions
          COLORCONV_8_TO_15             // expand 8-bit to 15-bit
          COLORCONV_8_TO_16             // expand 8-bit to 16-bit
          COLORCONV_8_TO_24             // expand 8-bit to 24-bit
          COLORCONV_8_TO_32             // expand 8-bit to 32-bit
          COLORCONV_15_TO_8             // reduce 15-bit to 8-bit
          COLORCONV_15_TO_16            // expand 15-bit to 16-bit
          COLORCONV_15_TO_24            // expand 15-bit to 24-bit
          COLORCONV_15_TO_32            // expand 15-bit to 32-bit
          COLORCONV_16_TO_8             // reduce 16-bit to 8-bit
          COLORCONV_16_TO_15            // reduce 16-bit to 15-bit
          COLORCONV_16_TO_24            // expand 16-bit to 24-bit
          COLORCONV_16_TO_32            // expand 16-bit to 32-bit
          COLORCONV_24_TO_8             // reduce 24-bit to 8-bit
          COLORCONV_24_TO_15            // reduce 24-bit to 15-bit
          COLORCONV_24_TO_16            // reduce 24-bit to 16-bit
          COLORCONV_24_TO_32            // expand 24-bit to 32-bit
          COLORCONV_32_TO_8             // reduce 32-bit RGB to 8-bit
          COLORCONV_32_TO_15            // reduce 32-bit RGB to 15-bit
          COLORCONV_32_TO_16            // reduce 32-bit RGB to 16-bit
          COLORCONV_32_TO_24            // reduce 32-bit RGB to 24-bit
          COLORCONV_32A_TO_8            // reduce 32-bit RGBA to 8-bit
          COLORCONV_32A_TO_15           // reduce 32-bit RGBA to 15-bit
          COLORCONV_32A_TO_16           // reduce 32-bit RGBA to 16-bit
          COLORCONV_32A_TO_24           // reduce 32-bit RGBA to 24-bit
          COLORCONV_DITHER_PAL          // dither when reducing to 8-bit
          COLORCONV_DITHER_HI           // dither when reducing to
                                        // hicolor
          COLORCONV_KEEP_TRANS          // keep original transparency

     For convenience, the following macros can be used to select common
     combinations of these flags:

          COLORCONV_EXPAND_256          // expand 256-color to hi/truecolor
          COLORCONV_REDUCE_TO_256       // reduce hi/truecolor to 256-color
          COLORCONV_EXPAND_15_TO_16     // expand 15-bit hicolor to 16-bit
          COLORCONV_REDUCE_16_TO_15     // reduce 16-bit hicolor to 15-bit
          COLORCONV_EXPAND_HI_TO_TRUE   // expand 15/16-bit to 24/32-bit
          COLORCONV_REDUCE_TRUE_TO_HI   // reduce 24/32-bit to 15/16-bit
          COLORCONV_24_EQUALS_32        // convert between 24- and 32-bit
          COLORCONV_TOTAL               // everything to current format
          COLORCONV_PARTIAL             // convert 15 <-> 16-bit and
                                        // 24 <-> 32-bit
          COLORCONV_MOST                // all but hi/truecolor <-> 256
          COLORCONV_DITHER              // dither during all color reductions
          COLORCONV_KEEP_ALPHA          // convert everything to current format
                                        // unless it would lose alpha information

     If you enable the COLORCONV_DITHER flag, dithering will be
     performed whenever truecolor graphics are converted into a hicolor
     or paletted format, including by the blit() function, and any
     automatic conversions that take place while reading graphics from
     disk.  This can produce much better looking results, but is
     obviously slower than a direct conversion.

     If you intend using converted bitmaps with functions like
     masked_blit() or draw_sprite(), you should specify the
     COLORCONV_KEEP_TRANS flag.  It will ensure that the masked areas in
     the bitmap before and after the conversion stay exactly the same,
     by mapping transparent colors to each other and adjusting colors
     which would be converted to the transparent color otherwise.  It
     affects every blit() operation between distinct pixel formats and
     every automatic conversion.

See also:
*Note set_color_depth::.
*Note load_bitmap::.
*Note load_datafile::.
*Note fixup_datafile::.
*Note makecol15_dither::.
*Note get_color_conversion::.
*Note exalpha::.
*Note exblend::.
*Note exdata::.
*Note exexedat::.
*Note exlights::.
*Note exrotscl::.
*Note exxfade::.


File: allegro.info,  Node: get_color_conversion,  Next: set_color,  Prev: set_color_conversion,  Up: Loading

1.11.18 get_color_conversion
----------------------------

int get_color_conversion();
     Returns the current color conversion mode.

See also:
*Note set_color_conversion::.


File: allegro.info,  Node: Palette,  Next: Truecolor,  Prev: Loading,  Up: API

1.12 Palette routines
=====================

All the Allegro drawing functions use integer parameters to represent
colors.  In truecolor resolutions these numbers encode the color
directly as a collection of red, green, and blue bits, but in a regular
256-color mode the values are treated as indexes into the current
palette, which is a table listing the red, green and blue intensities
for each of the 256 possible colors.

Palette entries are stored in an RGB structure, which contains red,
green and blue intensities in the VGA hardware format, ranging from
0-63, and is defined as:

     typedef struct RGB
     {
        unsigned char r, g, b;
     } RGB;

It contains an additional field for the purpose of padding but you
should not usually care about it.  For example:

     RGB black = { 0,  0,  0  };
     RGB white = { 63, 63, 63 };
     RGB green = { 0,  63, 0  };
     RGB grey  = { 32, 32, 32 };

The type PALETTE is defined to be an array of PAL_SIZE RGB structures,
where PAL_SIZE is a preprocessor constant equal to 256.

You may notice that a lot of the code in Allegro spells 'palette' as
'pallete'.  This is because the headers from my old Mark Williams
compiler on the Atari spelt it with two l's, so that is what I'm used
to.  Allegro will happily accept either spelling, due to some #defines
in allegro/alcompat.h (which can be turned off by defining the
ALLEGRO_NO_COMPATIBILITY symbol before including Allegro headers).

* Menu:

* set_color::
* _set_color::
* set_palette::
* set_palette_range::
* get_color::
* get_palette::
* get_palette_range::
* fade_interpolate::
* fade_from_range::
* fade_in_range::
* fade_out_range::
* fade_from::
* fade_in::
* fade_out::
* select_palette::
* unselect_palette::
* generate_332_palette::
* generate_optimized_palette::
* default_palette::
* black_palette::
* desktop_palette::


File: allegro.info,  Node: set_color,  Next: _set_color,  Prev: get_color_conversion,  Up: Palette

1.12.1 set_color
----------------

void set_color(int index, const RGB *p);
     Sets the specified palette entry to the specified RGB triplet.
     Unlike the other palette functions this doesn't do any retrace
     synchronisation, so you should call vsync() before it to prevent
     snow problems.  Example:

          RGB rgb;
          ...
          vsync();
          set_color(192, &rgb);

See also:
*Note set_palette::.
*Note get_color::.
*Note _set_color::.
*Note ex12bit::.
*Note exrgbhsv::.
*Note exscroll::.
*Note RGB::.


File: allegro.info,  Node: _set_color,  Next: set_palette,  Prev: set_color,  Up: Palette

1.12.2 _set_color
-----------------

void _set_color(int index, const RGB *p);
     This is an inline version of set_color(), intended for use in the
     vertical retrace simulator callback function (retrace_proc, which
     is now deprecated).

     If you really must use _set_color from retrace_proc, note that it
     should only be used under DOS, in VGA mode 13h and mode-X. Some
     SVGA chipsets aren't VGA compatible (set_color() and set_palette()
     will use VESA calls on these cards, but _set_color() doesn't know
     about that).

See also:
*Note set_color::.
*Note set_gfx_mode::.
*Note ex3buf::.
*Note RGB::.


File: allegro.info,  Node: set_palette,  Next: set_palette_range,  Prev: _set_color,  Up: Palette

1.12.3 set_palette
------------------

void set_palette(const PALETTE p);
     Sets the entire palette of 256 colors.  You should provide an array
     of 256 RGB structures.  Unlike set_color(), there is no need to
     call vsync() before this function.  Example:

          BITMAP *bmp;
          PALETTE palette;
          ...
          bmp = load_bitmap(filename, palette);
          if (!bmp)
             abort_on_error("Couldn't load bitmap!");
          set_palette(palette);

See also:
*Note set_gfx_mode::.
*Note set_palette_range::.
*Note set_color::.
*Note get_palette::.
*Note select_palette::.
*Note palette_color::.
*Note Available Allegro examples: Available.
*Note PALETTE::.


File: allegro.info,  Node: set_palette_range,  Next: get_color,  Prev: set_palette,  Up: Palette

1.12.4 set_palette_range
------------------------

void set_palette_range(const PALETTE p, int from, int to, int vsync);
     Sets the palette entries between from and to (inclusive: pass 0 and
     255 to set the entire palette).  If vsync is set it waits for the
     vertical retrace, otherwise it sets the colors immediately.
     Example:

          PALETTE palette;
          ...
          /* Modify the first 16 entries. */
          change_first_16_colors(palette);
          /* Now update them waiting for vsync. */
          set_palette_range(palette, 0, 15, 1);

See also:
*Note set_palette::.
*Note get_palette_range::.
*Note exzbuf::.
*Note PALETTE::.


File: allegro.info,  Node: get_color,  Next: get_palette,  Prev: set_palette_range,  Up: Palette

1.12.5 get_color
----------------

void get_color(int index, RGB *p);
     Retrieves the specified palette entry.  Example:

          RGB color;
          ...
          get_color(11, &color);

See also:
*Note get_palette::.
*Note set_color::.
*Note RGB::.


File: allegro.info,  Node: get_palette,  Next: get_palette_range,  Prev: get_color,  Up: Palette

1.12.6 get_palette
------------------

void get_palette(PALETTE p);
     Retrieves the entire palette of 256 colors.  You should provide an
     array of 256 RGB structures to store it in.  Example:

          PALETTE pal;
          ...
          get_palette(pal);

See also:
*Note get_palette_range::.
*Note get_color::.
*Note set_palette::.
*Note PALETTE::.


File: allegro.info,  Node: get_palette_range,  Next: fade_interpolate,  Prev: get_palette,  Up: Palette

1.12.7 get_palette_range
------------------------

void get_palette_range(PALETTE p, int from, int to);
     Retrieves the palette entries between from and to (inclusive: pass
     0 and 255 to get the entire palette).

See also:
*Note get_palette::.
*Note set_palette_range::.
*Note PALETTE::.


File: allegro.info,  Node: fade_interpolate,  Next: fade_from_range,  Prev: get_palette_range,  Up: Palette

1.12.8 fade_interpolate
-----------------------

void fade_interpolate(const PALETTE source, const PALETTE dest, PALETTE output, int pos, int from, int to);
     Calculates a temporary palette part way between source and dest,
     returning it in the output parameter.  The position between the two
     extremes is specified by the pos value: 0 returns an exact copy of
     source, 64 returns dest, 32 returns a palette half way between the
     two, etc.  This routine only affects colors between from and to
     (inclusive: pass 0 and 255 to interpolate the entire palette).

See also:
*Note fade_in::.
*Note fade_out::.
*Note fade_from::.
*Note PALETTE::.


File: allegro.info,  Node: fade_from_range,  Next: fade_in_range,  Prev: fade_interpolate,  Up: Palette

1.12.9 fade_from_range
----------------------

void fade_from_range(const PALETTE source, const PALETTE dest, int speed, int from, int to);
     Gradually fades a part of the palette from the source palette to
     the dest palette.  The speed is from 1 (the slowest) up to 64
     (instantaneous).  This routine only affects colors between from and
     to (inclusive: pass 0 and 255 to fade the entire palette).

     Note that this function will block your game while the fade is in
     effect, and it won't work right visually if you are not in an 8 bit
     color depth resolution.

See also:
*Note fade_from::.
*Note PALETTE::.


File: allegro.info,  Node: fade_in_range,  Next: fade_out_range,  Prev: fade_from_range,  Up: Palette

1.12.10 fade_in_range
---------------------

void fade_in_range(const PALETTE p, int speed, int from, int to);
     Gradually fades a part of the palette from a black screen to the
     specified palette.  The speed is from 1 (the slowest) up to 64
     (instantaneous).  This routine only affects colors between from and
     to (inclusive: pass 0 and 255 to fade the entire palette).

     Note that this function will block your game while the fade is in
     effect, and it won't work right visually if you are not in an 8 bit
     color depth resolution.

See also:
*Note fade_in::.
*Note PALETTE::.


File: allegro.info,  Node: fade_out_range,  Next: fade_from,  Prev: fade_in_range,  Up: Palette

1.12.11 fade_out_range
----------------------

void fade_out_range(int speed, int from, int to);
     Gradually fades a part of the palette from the current palette to a
     black screen.  The speed is from 1 (the slowest) up to 64
     (instantaneous).  This routine only affects colors between from and
     to (inclusive: pass 0 and 255 to fade the entire palette).

     Note that this function will block your game while the fade is in
     effect, and it won't work right visually if you are not in an 8 bit
     color depth resolution.

See also:
*Note fade_out::.


File: allegro.info,  Node: fade_from,  Next: fade_in,  Prev: fade_out_range,  Up: Palette

1.12.12 fade_from
-----------------

void fade_from(const PALETTE source, const PALETTE dest, int speed);
     Fades gradually from the source palette to the dest palette.  The
     speed is from 1 (the slowest) up to 64 (instantaneous).

     Note that this function will block your game while the fade is in
     effect, and it won't work right visually if you are not in an 8 bit
     color depth resolution.

See also:
*Note fade_in::.
*Note fade_out::.
*Note fade_interpolate::.
*Note fade_from_range::.
*Note PALETTE::.


File: allegro.info,  Node: fade_in,  Next: fade_out,  Prev: fade_from,  Up: Palette

1.12.13 fade_in
---------------

void fade_in(const PALETTE p, int speed);
     Fades gradually from a black screen to the specified palette.  The
     speed is from 1 (the slowest) up to 64 (instantaneous).

     Note that this function will block your game while the fade is in
     effect, and it won't work right visually if you are not in an 8 bit
     color depth resolution.

See also:
*Note fade_out::.
*Note fade_from::.
*Note fade_interpolate::.
*Note fade_in_range::.
*Note PALETTE::.


File: allegro.info,  Node: fade_out,  Next: select_palette,  Prev: fade_in,  Up: Palette

1.12.14 fade_out
----------------

void fade_out(int speed);
     Fades gradually from the current palette to a black screen.  The
     speed is from 1 (the slowest) up to 64 (instantaneous).

     Note that this function will block your game while the fade is in
     effect, and it won't work right visually if you are not in an 8 bit
     color depth resolution.

See also:
*Note fade_in::.
*Note fade_from::.
*Note fade_interpolate::.
*Note fade_in_range::.
*Note ex12bit::.


File: allegro.info,  Node: select_palette,  Next: unselect_palette,  Prev: fade_out,  Up: Palette

1.12.15 select_palette
----------------------

void select_palette(const PALETTE p);
     Ugly hack for use in various dodgy situations where you need to
     convert between paletted and truecolor image formats.  Sets the
     internal palette table in the same way as the set_palette()
     function, so the conversion will use the specified palette, but
     without affecting the display hardware in any way.  The previous
     palette settings are stored in an internal buffer, and can be
     restored by calling unselect_palette().  If you call
     select_palette() again, however, the internal buffer will be
     overwritten.

See also:
*Note set_palette::.
*Note unselect_palette::.
*Note exlights::.
*Note PALETTE::.


File: allegro.info,  Node: unselect_palette,  Next: generate_332_palette,  Prev: select_palette,  Up: Palette

1.12.16 unselect_palette
------------------------

void unselect_palette();
     Restores the palette tables that were in use before the last call
     to select_palette().

See also:
*Note select_palette::.


File: allegro.info,  Node: generate_332_palette,  Next: generate_optimized_palette,  Prev: unselect_palette,  Up: Palette

1.12.17 generate_332_palette
----------------------------

void generate_332_palette(PALETTE pal);
     Constructs a fake truecolor palette, using three bits for red and
     green and two for the blue.  The load_bitmap() function fills the
     palette parameter with this if the file does not contain a palette
     itself (ie.  you are reading a truecolor bitmap).

See also:
*Note generate_optimized_palette::.
*Note set_color_depth::.
*Note excolmap::.
*Note exrgbhsv::.
*Note extruec::.
*Note exupdate::.
*Note PALETTE::.


File: allegro.info,  Node: generate_optimized_palette,  Next: default_palette,  Prev: generate_332_palette,  Up: Palette

1.12.18 generate_optimized_palette
----------------------------------

int generate_optimized_palette(BITMAP *bmp, PALETTE pal, const char rsvd[PAL_SIZE]);
     Generates a 256-color palette suitable for making a reduced color
     version of the specified truecolor image.  The rsvd parameter
     points to a table indicating which colors it is allowed to modify:
     zero for free colors which may be set to whatever the optimiser
     likes, negative values for reserved colors which cannot be used,
     and positive values for fixed palette entries that must not be
     changed, but can be used in the optimisation.

     Returns the number of different colors recognised in the provided
     bitmap, zero if the bitmap is not a truecolor image or there wasn't
     enough memory to perform the operation, and negative if there was
     any internal error in the color reduction code.

See also:
*Note generate_332_palette::.
*Note set_color_depth::.
*Note BITMAP::.
*Note PALETTE::.


File: allegro.info,  Node: default_palette,  Next: black_palette,  Prev: generate_optimized_palette,  Up: Palette

1.12.19 default_palette
-----------------------

extern PALETTE default_palette;
     The default IBM BIOS palette.  This will be automatically selected
     whenever you set a new graphics mode.  The palette contains 16
     basic colors plus many gradients between them.  If you want to see
     the values, you can write a small Allegro program which saves a
     screenshot with this palette, or open the grabber tool provided
     with Allegro and create a new palette object, which will use this
     palette by default.

See also:
*Note black_palette::.
*Note desktop_palette::.
*Note exjoy::.
*Note PALETTE::.


File: allegro.info,  Node: black_palette,  Next: desktop_palette,  Prev: default_palette,  Up: Palette

1.12.20 black_palette
---------------------

extern PALETTE black_palette;
     A palette containing solid black colors, used by the fade routines.

See also:
*Note default_palette::.
*Note desktop_palette::.
*Note expal::.
*Note PALETTE::.


File: allegro.info,  Node: desktop_palette,  Next: makecol8,  Prev: black_palette,  Up: Palette

1.12.21 desktop_palette
-----------------------

extern PALETTE desktop_palette;
     The palette used by the Atari ST low resolution desktop.  I'm not
     quite sure why this is still here, except that the grabber and test
     programs use it.  It is probably the only Atari legacy code left in
     Allegro, and it would be a shame to remove it :-)

     The contents of this palette are 16 colors repeated 16 times.
     Color entry zero is equal to color entry 16, which is equal to
     color entry 24, etc.

          Index      Color       RGB values
            0     White          63  63  63
            1     Red            63   0   0
            2     Green           0  63   0
            3     Yellow         63  63   0
            4     Blue            0   0  63
            5     Pink           63   0  63
            6     Cyan            0  63  63
            7     Grey           16  16  16
            8     Light grey     31  31  31
            9     Light red      63  31  31
           10     Light green    31  63  31
           11     Light yellow   63  63  31
           12     Light blue     31  31  63
           13     Light pink     63  31  63
           14     Light cyan     31  63  63
           15     Black           0   0   0

See also:
*Note default_palette::.
*Note black_palette::.
*Note Available Allegro examples: Available.
*Note PALETTE::.


File: allegro.info,  Node: Truecolor,  Next: Drawing,  Prev: Palette,  Up: API

1.13 Truecolor pixel formats
============================

In a truecolor video mode the red, green, and blue components for each
pixel are packed directly into the color value, rather than using a
palette lookup table.  In a 15-bit mode there are 5 bits for each color,
in 16-bit modes there are 5 bits each of red and blue and six bits of
green, and both 24 and 32-bit modes use 8 bits for each color (the
32-bit pixels simply have an extra padding byte to align the data
nicely).  The layout of these components can vary depending on your
hardware, but will generally either be RGB or BGR. Since the layout is
not known until you select the video mode you will be using, you must
call set_gfx_mode() before using any of the following routines!

* Menu:

* makecol8::
* makeacol32::
* makecol::
* makecol_depth::
* makeacol::
* makecol15_dither::
* getr8::
* geta32::
* getr::
* getr_depth::
* palette_color::
* MASK_COLOR_8::


File: allegro.info,  Node: makecol8,  Next: makeacol32,  Prev: desktop_palette,  Up: Truecolor

1.13.1 makecol8
---------------

int makecol8(int r, int g, int b);
int makecol15(int r, int g, int b);
int makecol16(int r, int g, int b);
int makecol24(int r, int g, int b);
int makecol32(int r, int g, int b);
     These functions convert colors from a hardware independent form
     (red, green, and blue values ranging 0-255) into various display
     dependent pixel formats.  Converting to 15, 16, 24, or 32-bit
     formats only takes a few shifts, so it is fairly efficient.
     Converting to an 8-bit color involves searching the palette to find
     the closest match, which is quite slow unless you have set up an
     RGB mapping table (see below).  Example:

          /* 16 bit color version of green. */
          int green_color = makecol16(0, 255, 0);

     Returns the requested RGB triplet in the specified color depth.

See also:
*Note makeacol32::.
*Note makecol::.
*Note makecol_depth::.
*Note makecol15_dither::.
*Note rgb_map::.
*Note bestfit_color::.
*Note set_color_depth::.
*Note exrgbhsv::.


File: allegro.info,  Node: makeacol32,  Next: makecol,  Prev: makecol8,  Up: Truecolor

1.13.2 makeacol32
-----------------

int makeacol32(int r, int g, int b, int a);
     Converts an RGBA color into a 32-bit display pixel format, which
     includes an alpha (transparency) value.  There are no versions of
     this routine for other color depths, because only the 32-bit format
     has enough room to store a proper alpha channel.  You should only
     use RGBA format colors as the input to draw_trans_sprite() or
     draw_trans_rle_sprite() after calling set_alpha_blender(), rather
     than drawing them directly to the screen.

See also:
*Note makeacol::.
*Note set_alpha_blender::.
*Note set_write_alpha_blender::.


File: allegro.info,  Node: makecol,  Next: makecol_depth,  Prev: makeacol32,  Up: Truecolor

1.13.3 makecol
--------------

int makecol(int r, int g, int b);
     Converts colors from a hardware independent format (red, green, and
     blue values ranging 0-255) to the pixel format required by the
     current video mode, calling the preceding 8, 15, 16, 24, or 32-bit
     makecol functions as appropriate.  Example:

          /* Regardless of color depth, this will look green. */
          int green_color = makecol(0, 255, 0);

     Returns the requested RGB triplet in the current color depth.

See also:
*Note makeacol::.
*Note makecol8::.
*Note makecol_depth::.
*Note makecol15_dither::.
*Note rgb_map::.
*Note set_color_depth::.
*Note Available Allegro examples: Available.


File: allegro.info,  Node: makecol_depth,  Next: makeacol,  Prev: makecol,  Up: Truecolor

1.13.4 makecol_depth
--------------------

int makecol_depth(int color_depth, int r, int g, int b);
     Converts colors from a hardware independent format (red, green, and
     blue values ranging 0-255) to the pixel format required by the
     specified color depth.  Example:

          /* Compose the green color for 15 bit color depth. */
          int green_15bit = makecol_depth(15, 0, 255, 0);

     Returns the requested RGB triplet in the specified color depth.

See also:
*Note makeacol::.
*Note makecol::.
*Note makecol8::.
*Note makecol15_dither::.
*Note rgb_map::.
*Note set_color_depth::.


File: allegro.info,  Node: makeacol,  Next: makecol15_dither,  Prev: makecol_depth,  Up: Truecolor

1.13.5 makeacol
---------------

int makeacol(int r, int g, int b, int a);
int makeacol_depth(int color_depth, int r, int g, int b, int a);
     Convert RGBA colors into display dependent pixel formats.  In
     anything less than a 32-bit mode, these are the same as calling
     makecol() or makecol_depth(), but by using these routines it is
     possible to create 32-bit color values that contain a true 8 bit
     alpha channel along with the red, green, and blue components.  You
     should only use RGBA format colors as the input to
     draw_trans_sprite() or draw_trans_rle_sprite() after calling
     set_alpha_blender(), rather than drawing them directly to the
     screen.

     Returns the requested RGBA quadruplet.

See also:
*Note makecol::.
*Note makecol_depth::.
*Note set_alpha_blender::.
*Note set_write_alpha_blender::.
*Note exrotscl::.


File: allegro.info,  Node: makecol15_dither,  Next: getr8,  Prev: makeacol,  Up: Truecolor

1.13.6 makecol15_dither
-----------------------

int makecol15_dither(int r, int g, int b, int x, int y);
int makecol16_dither(int r, int g, int b, int x, int y);
     Given both a color value and a pixel coordinate, calculate a
     dithered 15 or 16-bit RGB value.  This can produce better results
     when reducing images from truecolor to hicolor.  In addition to
     calling these functions directly, hicolor dithering can be
     automatically enabled when loading graphics by calling the
     set_color_conversion() function, for example
     set_color_conversion(COLORCONV_REDUCE_TRUE_TO_HI |
     COLORCONV_DITHER).

     Example:

          int pixel1, pixel2;

          /* The following two color values MAY be different. */
          pixel1 = makecol16_dither(255, 192, 64, 0, 0);
          pixel2 = makecol16_dither(255, 192, 64, 1, 0);

     Returns the RGB value dithered for the specified coordinate.

See also:
*Note makecol::.
*Note makecol8::.
*Note set_color_conversion::.


File: allegro.info,  Node: getr8,  Next: geta32,  Prev: makecol15_dither,  Up: Truecolor

1.13.7 getr8
------------

int getr8(int c);
int getg8(int c);
int getb8(int c);
int getr15(int c);
int getg15(int c);
int getb15(int c);
int getr16(int c);
int getg16(int c);
int getb16(int c);
int getr24(int c);
int getg24(int c);
int getb24(int c);
int getr32(int c);
int getg32(int c);
int getb32(int c);
     Given a color in a display dependent format, these functions
     extract one of the red, green, or blue components (ranging 0-255).
     Example:

          int r, g, b, color_value;

          color_value = _getpixel15(screen, 100, 100);
          r = getr15(color_value);
          g = getg15(color_value);
          b = getb15(color_value);

See also:
*Note geta32::.
*Note getr::.
*Note getr_depth::.
*Note makecol::.
*Note set_color_depth::.


File: allegro.info,  Node: geta32,  Next: getr,  Prev: getr8,  Up: Truecolor

1.13.8 geta32
-------------

int geta32(int c);
     Given a color in a 32-bit pixel format, this function extracts the
     alpha component (ranging 0-255).

See also:
*Note getr8::.


File: allegro.info,  Node: getr,  Next: getr_depth,  Prev: geta32,  Up: Truecolor

1.13.9 getr
-----------

int getr(int c);
int getg(int c);
int getb(int c);
int geta(int c);
     Given a color in the format being used by the current video mode,
     these functions extract one of the red, green, blue, or alpha
     components (ranging 0-255), calling the preceding 8, 15, 16, 24, or
     32-bit get functions as appropriate.  The alpha part is only
     meaningful for 32-bit pixels.  Example:

          int r, g, b, color_value;

          color_value = getpixel(screen, 100, 100);
          r = getr(color_value);
          g = getg(color_value);
          b = getb(color_value);

See also:
*Note getr8::.
*Note getr_depth::.
*Note makecol::.
*Note set_color_depth::.
*Note exalpha::.


File: allegro.info,  Node: getr_depth,  Next: palette_color,  Prev: getr,  Up: Truecolor

1.13.10 getr_depth
------------------

int getr_depth(int color_depth, int c);
int getg_depth(int color_depth, int c);
int getb_depth(int color_depth, int c);
int geta_depth(int color_depth, int c);
     Given a color in the format being used by the specified color
     depth, these functions extract one of the red, green, blue, or
     alpha components (ranging 0-255).  The alpha part is only
     meaningful for 32-bit pixels.  Example:

          int r, g, b, color_value, bpp;

          bpp = bitmap_color_depth(bitmap);
          color_value = getpixel(bitmap, 100, 100);
          r = getr_depth(bpp, color_value);
          g = getg_depth(bpp, color_value);
          b = getb_depth(bpp, color_value);

See also:
*Note getr::.
*Note getr8::.
*Note geta32::.
*Note makecol::.
*Note set_color_depth::.
*Note exlights::.


File: allegro.info,  Node: palette_color,  Next: MASK_COLOR_8,  Prev: getr_depth,  Up: Truecolor

1.13.11 palette_color
---------------------

extern int palette_color[256];
     Table mapping palette index colors (0-255) into whatever pixel
     format is being used by the current display mode.  In a 256-color
     mode this just maps onto the array index.  In truecolor modes it
     looks up the specified entry in the current palette, and converts
     that RGB value into the appropriate packed pixel format.  Example:

          set_color_depth(32);
          ...
          set_palette(desktop_palette);
          /* Put a pixel with the color 2 (green) of the palette */
          putpixel(screen, 100, 100, palette_color[2]);

See also:
*Note set_palette::.
*Note makecol::.
*Note set_color_depth::.
*Note Available Allegro examples: Available.


File: allegro.info,  Node: MASK_COLOR_8,  Next: clear_bitmap,  Prev: palette_color,  Up: Truecolor

1.13.12 MASK_COLOR_8
--------------------

#define MASK_COLOR_8 0
#define MASK_COLOR_15 (5.5.5 pink)
#define MASK_COLOR_16 (5.6.5 pink)
#define MASK_COLOR_24 (8.8.8 pink)
#define MASK_COLOR_32 (8.8.8 pink)
     Constants representing the colors used to mask transparent sprite
     pixels for each color depth.  In 256-color resolutions this is
     zero, and in truecolor modes it is bright pink (maximum red and
     blue, zero green).

See also:
*Note bitmap_mask_color::.
*Note makecol::.
*Note draw_sprite::.
*Note masked_blit::.


File: allegro.info,  Node: Drawing,  Next: Blitting,  Prev: Truecolor,  Up: API

1.14 Drawing primitives
=======================

Except for _putpixel(), all these routines are affected by the current
drawing mode and the clipping rectangle of the destination bitmap.
Unless specified otherwise, all coordinates for drawing operations are
inclusive, and they, as well as lengths, are specified in pixel units.

* Menu:

* clear_bitmap::
* clear_to_color::
* putpixel::
* _putpixel::
* getpixel::
* _getpixel::
* vline::
* hline::
* do_line::
* line::
* fastline::
* triangle::
* polygon::
* rect::
* rectfill::
* do_circle::
* circle::
* circlefill::
* do_ellipse::
* ellipse::
* ellipsefill::
* do_arc::
* arc::
* calc_spline::
* spline::
* floodfill::


File: allegro.info,  Node: clear_bitmap,  Next: clear_to_color,  Prev: MASK_COLOR_8,  Up: Drawing

1.14.1 clear_bitmap
-------------------

void clear_bitmap(BITMAP *bitmap);
     Clears the bitmap to color 0.

See also:
*Note clear_to_color::.
*Note Available Allegro examples: Available.
*Note BITMAP::.


File: allegro.info,  Node: clear_to_color,  Next: putpixel,  Prev: clear_bitmap,  Up: Drawing

1.14.2 clear_to_color
---------------------

void clear_to_color(BITMAP *bitmap, int color);
     Clears the bitmap to the specified color.  Example:

          /* Clear the screen to red. */
          clear_to_color(bmp, makecol(255, 0, 0));

See also:
*Note clear_bitmap::.
*Note makecol::.
*Note Available Allegro examples: Available.
*Note BITMAP::.


File: allegro.info,  Node: putpixel,  Next: _putpixel,  Prev: clear_to_color,  Up: Drawing

1.14.3 putpixel
---------------

void putpixel(BITMAP *bmp, int x, int y, int color);
     Writes a pixel to the specified position in the bitmap, using the
     current drawing mode and the bitmap's clipping rectangle.  Example:

          putpixel(screen, 10, 30, some_color);

See also:
*Note getpixel::.
*Note _putpixel::.
*Note drawing_mode::.
*Note makecol::.
*Note ex12bit::.
*Note exalpha::.
*Note exflame::.
*Note exjoy::.
*Note exstars::.
*Note exswitch::.
*Note BITMAP::.


File: allegro.info,  Node: _putpixel,  Next: getpixel,  Prev: putpixel,  Up: Drawing

1.14.4 _putpixel
----------------

void _putpixel(BITMAP *bmp, int x, int y, int color);
void _putpixel15(BITMAP *bmp, int x, int y, int color);
void _putpixel16(BITMAP *bmp, int x, int y, int color);
void _putpixel24(BITMAP *bmp, int x, int y, int color);
void _putpixel32(BITMAP *bmp, int x, int y, int color);
     Like the regular putpixel(), but much faster because they are
     implemented as an inline assembler functions for specific color
     depths.  These won't work in mode-X graphics modes, don't perform
     any clipping (they will crash if you try to draw outside the
     bitmap!), and ignore the drawing mode.

See also:
*Note putpixel::.
*Note makecol::.
*Note BITMAP::.


File: allegro.info,  Node: getpixel,  Next: _getpixel,  Prev: _putpixel,  Up: Drawing

1.14.5 getpixel
---------------

int getpixel(BITMAP *bmp, int x, int y);
     Reads a pixel from point (x, y) in the bitmap.

     Returns -1 if the point lies outside the bitmap (ignoring the
     clipping rectangle), otherwise the value of the pixel in the color
     format of the bitmap.

     Warning: -1 is also a valid value for pixels contained in 32-bit
     bitmaps with alpha channel (when R,G,B,A are all equal to 255) so
     you can't use the test against -1 as a predicate for such bitmaps.
     In this cases, the only reliable predicate is is_inside_bitmap().

     To extract the individual color components, use the getr() / getg()
     / getb() / geta() family of functions.

See also:
*Note putpixel::.
*Note _getpixel::.
*Note is_inside_bitmap::.
*Note getr::.
*Note getg: getr.
*Note getb: getr.
*Note geta: getr.
*Note Truecolor pixel formats: Truecolor.
*Note Palette routines: Palette.
*Note ex12bit::.
*Note exalpha::.
*Note exflame::.
*Note exlights::.
*Note BITMAP::.


File: allegro.info,  Node: _getpixel,  Next: vline,  Prev: getpixel,  Up: Drawing

1.14.6 _getpixel
----------------

int _getpixel(BITMAP *bmp, int x, int y);
int _getpixel15(BITMAP *bmp, int x, int y);
int _getpixel16(BITMAP *bmp, int x, int y);
int _getpixel24(BITMAP *bmp, int x, int y);
int _getpixel32(BITMAP *bmp, int x, int y);
     Faster inline versions of getpixel() for specific color depths.
     These won't work in mode-X, and don't do any clipping, so you must
     make sure the point lies inside the bitmap.

     Returns the value of the pixel in the color format you specified.

See also:
*Note getpixel::.
*Note BITMAP::.


File: allegro.info,  Node: vline,  Next: hline,  Prev: _getpixel,  Up: Drawing

1.14.7 vline
------------

void vline(BITMAP *bmp, int x, int y1, int y2, int color);
     Draws a vertical line onto the bitmap, from point (x, y1) to (x,
     y2).

     Note: vline() is implemented as an alias to another function.  See
     ALLEGRO_NO_VHLINE_ALIAS in the 'Differences between platforms'
     section for details.

See also:
*Note hline::.
*Note line::.
*Note drawing_mode::.
*Note makecol::.
*Note Differences between platforms: Differences.
*Note exrgbhsv::.
*Note exscroll::.
*Note extruec::.
*Note BITMAP::.


File: allegro.info,  Node: hline,  Next: do_line,  Prev: vline,  Up: Drawing

1.14.8 hline
------------

void hline(BITMAP *bmp, int x1, int y, int x2, int color);
     Draws a horizontal line onto the bitmap, from point (x1, y) to (x2,
     y).

     Note: hline() is implemented as an alias to another function.  See
     ALLEGRO_NO_VHLINE_ALIAS in the 'Differences between platforms'
     section for details.

See also:
*Note vline::.
*Note line::.
*Note drawing_mode::.
*Note makecol::.
*Note Differences between platforms: Differences.
*Note exsprite::.
*Note BITMAP::.


File: allegro.info,  Node: do_line,  Next: line,  Prev: hline,  Up: Drawing

1.14.9 do_line
--------------

void do_line(BITMAP *bmp, int x1, y1, x2, y2, int d, void (*proc)(BITMAP *bmp, int x, int y, int d));
     Calculates all the points along a line from point (x1, y1) to (x2,
     y2), calling the supplied function for each one.  This will be
     passed a copy of the bmp parameter, the x and y position, and a
     copy of the d parameter, so it is suitable for use with putpixel().
     Example:

          void draw_dust_particle(BITMAP *bmp, int x, int y, int d)
          {
             ...
          }

             do_line(screen, 0, 0, SCREEN_W-1, SCREEN_H-2,
                     dust_strength, draw_dust_particle);

See also:
*Note do_circle::.
*Note do_ellipse::.
*Note do_arc::.
*Note line::.
*Note BITMAP::.


File: allegro.info,  Node: line,  Next: fastline,  Prev: do_line,  Up: Drawing

1.14.10 line
------------

void line(BITMAP *bmp, int x1, int y1, int x2, int y2, int color);
     Draws a line onto the bitmap, from point (x1, y1) to (x2, y2).

See also:
*Note fastline::.
*Note hline::.
*Note vline::.
*Note do_line::.
*Note drawing_mode::.
*Note makecol::.
*Note Available Allegro examples: Available.
*Note BITMAP::.


File: allegro.info,  Node: fastline,  Next: triangle,  Prev: line,  Up: Drawing

1.14.11 fastline
----------------

void fastline(BITMAP *bmp, int x1, int y1, int x2, int y2, int color);
     Faster version of the previous function.  Note that pixel
     correctness is not guaranteed for this function.

See also:
*Note line::.
*Note hline::.
*Note vline::.
*Note do_line::.
*Note drawing_mode::.
*Note makecol::.
*Note Available Allegro examples: Available.
*Note BITMAP::.


File: allegro.info,  Node: triangle,  Next: polygon,  Prev: fastline,  Up: Drawing

1.14.12 triangle
----------------

void triangle(BITMAP *bmp, int x1, y1, x2, y2, x3, y3, int color);
     Draws a filled triangle between the three points.

See also:
*Note polygon::.
*Note triangle3d::.
*Note drawing_mode::.
*Note makecol::.
*Note ex3buf::.
*Note exstars::.
*Note exupdate::.
*Note BITMAP::.


File: allegro.info,  Node: polygon,  Next: rect,  Prev: triangle,  Up: Drawing

1.14.13 polygon
---------------

void polygon(BITMAP *bmp, int vertices, const int *points, int color);
     Draws a filled polygon with an arbitrary number of corners.  Pass
     the number of vertices and an array containing a series of x, y
     points (a total of vertices*2 values).  Example:

          int points[12] = { 50, 50,   100, 100,  100, 150,
                             50, 200,  0,   150,  0,   100 };
          ...
          clear_to_color(screen, makecol(255, 255, 255));
          polygon(screen, 6, points, makecol(0, 0, 0));

See also:
*Note triangle::.
*Note polygon3d::.
*Note drawing_mode::.
*Note makecol::.
*Note excamera::.
*Note BITMAP::.


File: allegro.info,  Node: rect,  Next: rectfill,  Prev: polygon,  Up: Drawing

1.14.14 rect
------------

void rect(BITMAP *bmp, int x1, int y1, int x2, int y2, int color);
     Draws an outline rectangle with the two points as its opposite
     corners.

See also:
*Note rectfill::.
*Note drawing_mode::.
*Note makecol::.
*Note ex3d::.
*Note excamera::.
*Note BITMAP::.


File: allegro.info,  Node: rectfill,  Next: do_circle,  Prev: rect,  Up: Drawing

1.14.15 rectfill
----------------

void rectfill(BITMAP *bmp, int x1, int y1, int x2, int y2, int color);
     Draws a solid, filled rectangle with the two points as its opposite
     corners.

See also:
*Note rect::.
*Note clear_bitmap::.
*Note drawing_mode::.
*Note makecol::.
*Note exalpha::.
*Note excolmap::.
*Note exkeys::.
*Note exmidi::.
*Note expat::.
*Note exscroll::.
*Note exsprite::.
*Note exstars::.
*Note exswitch::.
*Note extrans::.
*Note BITMAP::.


File: allegro.info,  Node: do_circle,  Next: circle,  Prev: rectfill,  Up: Drawing

1.14.16 do_circle
-----------------

void do_circle(BITMAP *bmp, int x, int y, int radius, int d, void (*proc)(BITMAP *bmp, int x, int y, int d));
     Calculates all the points in a circle around point (x, y) with
     radius r, calling the supplied function for each one.  This will be
     passed a copy of the bmp parameter, the x and y position, and a
     copy of the d parameter, so it is suitable for use with putpixel().
     Example:

          void draw_explosion_ring(BITMAP *bmp, int x, int y, int d)
          {
             ...
          }

             do_circle(screen, SCREEN_W/2, SCREEN_H/2,
                       SCREEN_H/16, flame_color,
                       draw_explosion_ring);

See also:
*Note do_ellipse::.
*Note do_arc::.
*Note do_line::.
*Note circle::.
*Note circlefill::.
*Note BITMAP::.


File: allegro.info,  Node: circle,  Next: circlefill,  Prev: do_circle,  Up: Drawing

1.14.17 circle
--------------

void circle(BITMAP *bmp, int x, int y, int radius, int color);
     Draws a circle with the specified centre and radius.

See also:
*Note ellipse::.
*Note arc::.
*Note circlefill::.
*Note do_circle::.
*Note drawing_mode::.
*Note makecol::.
*Note ex12bit::.
*Note exblend::.
*Note excustom::.
*Note exjoy::.
*Note exmem::.
*Note exmouse::.
*Note exquat::.
*Note exsprite::.
*Note BITMAP::.


File: allegro.info,  Node: circlefill,  Next: do_ellipse,  Prev: circle,  Up: Drawing

1.14.18 circlefill
------------------

void circlefill(BITMAP *bmp, int x, int y, int radius, int color);
     Draws a filled circle with the specified centre and radius.

See also:
*Note ellipsefill::.
*Note circle::.
*Note do_circle::.
*Note drawing_mode::.
*Note makecol::.
*Note excolmap::.
*Note excustom::.
*Note exdbuf::.
*Note exflip::.
*Note exlights::.
*Note expal::.
*Note exspline::.
*Note extrans::.
*Note BITMAP::.


File: allegro.info,  Node: do_ellipse,  Next: ellipse,  Prev: circlefill,  Up: Drawing

1.14.19 do_ellipse
------------------

void do_ellipse(BITMAP *bmp, int x, int y, int rx, ry, int d, void (*proc)(BITMAP *bmp, int x, int y, int d));
     Calculates all the points in an ellipse around point (x, y) with
     radius rx and ry, calling the supplied function for each one.  This
     will be passed a copy of the bmp parameter, the x and y position,
     and a copy of the d parameter, so it is suitable for use with
     putpixel().  Example:

          void draw_explosion_ring(BITMAP *bmp, int x, int y, int d)
          {
             ...
          }

             do_ellipse(screen, SCREEN_W/2, SCREEN_H/2,
                       SCREEN_H/16, SCREEN_H/32, flame_color,
                       draw_explosion_ring);

See also:
*Note do_circle::.
*Note do_arc::.
*Note do_line::.
*Note ellipse::.
*Note ellipsefill::.
*Note BITMAP::.


File: allegro.info,  Node: ellipse,  Next: ellipsefill,  Prev: do_ellipse,  Up: Drawing

1.14.20 ellipse
---------------

void ellipse(BITMAP *bmp, int x, int y, int rx, int ry, int color);
     Draws an ellipse with the specified centre and radius.

See also:
*Note circle::.
*Note arc::.
*Note ellipsefill::.
*Note do_ellipse::.
*Note drawing_mode::.
*Note makecol::.
*Note BITMAP::.


File: allegro.info,  Node: ellipsefill,  Next: do_arc,  Prev: ellipse,  Up: Drawing

1.14.21 ellipsefill
-------------------

void ellipsefill(BITMAP *bmp, int x, int y, int rx, int ry, int color);
     Draws a filled ellipse with the specified centre and radius.

See also:
*Note circlefill::.
*Note ellipse::.
*Note do_ellipse::.
*Note drawing_mode::.
*Note makecol::.
*Note ex12bit::.
*Note BITMAP::.


File: allegro.info,  Node: do_arc,  Next: arc,  Prev: ellipsefill,  Up: Drawing

1.14.22 do_arc
--------------

void do_arc(BITMAP *bmp, int x, int y, fixed a1, fixed a2, int r, int d, void (*proc)(BITMAP *bmp, int x, int y, int d));
     Calculates all the points in a circular arc around point (x, y)
     with radius r, calling the supplied function for each one.  This
     will be passed a copy of the bmp parameter, the x and y position,
     and a copy of the d parameter, so it is suitable for use with
     putpixel().  The arc will be plotted in an anticlockwise direction
     starting from the angle a1 and ending when it reaches a2.  These
     values are specified in 16.16 fixed point format, with 256 equal to
     a full circle, 64 a right angle, etc.  Zero is to the right of the
     centre point, and larger values rotate anticlockwise from there.
     Example:

          void draw_explosion_ring(BITMAP *bmp, int x, int y, int d)
          {
             ...
          }
             do_arc(screen, SCREEN_W/2, SCREEN_H/2,
                 itofix(-21), itofix(43), 50, flame_color,
                 draw_explosion_ring);

See also:
*Note do_circle::.
*Note do_ellipse::.
*Note do_line::.
*Note arc::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: arc,  Next: calc_spline,  Prev: do_arc,  Up: Drawing

1.14.23 arc
-----------

void arc(BITMAP *bmp, int x, y, fixed ang1, ang2, int r, int color);
     Draws a circular arc with centre x, y and radius r, in an
     anticlockwise direction starting from the angle a1 and ending when
     it reaches a2.  These values are specified in 16.16 fixed point
     format, with 256 equal to a full circle, 64 a right angle, etc.
     Zero is to the right of the centre point, and larger values rotate
     anticlockwise from there.  Example:

          /* Draw a black arc from 4 to 1 o'clock. */
          arc(screen, SCREEN_W/2, SCREEN_H/2,
              itofix(-21), itofix(43), 50, makecol(0, 0, 0));

See also:
*Note circle::.
*Note ellipse::.
*Note drawing_mode::.
*Note makecol::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: calc_spline,  Next: spline,  Prev: arc,  Up: Drawing

1.14.24 calc_spline
-------------------

void calc_spline(const int points[8], int npts, int *x, int *y);
     Calculates a series of npts values along a Bezier spline, storing
     them in the output x and y arrays.  The Bezier curve is specified
     by the four x/y control points in the points array: points[0] and
     points[1] contain the coordinates of the first control point,
     points[2] and points[3] are the second point, etc.  Control points
     0 and 3 are the ends of the spline, and points 1 and 2 are guides.
     The curve probably won't pass through points 1 and 2, but they
     affect the shape of the curve between points 0 and 3 (the lines
     p0-p1 and p2-p3 are tangents to the spline).  The easiest way to
     think of it is that the curve starts at p0, heading in the
     direction of p1, but curves round so that it arrives at p3 from the
     direction of p2.  In addition to their role as graphics primitives,
     spline curves can be useful for constructing smooth paths around a
     series of control points, as in exspline.c.

See also:
*Note spline::.
*Note exspline::.


File: allegro.info,  Node: spline,  Next: floodfill,  Prev: calc_spline,  Up: Drawing

1.14.25 spline
--------------

void spline(BITMAP *bmp, const int points[8], int color);
     Draws a Bezier spline using the four control points specified in
     the points array.  Read the description of calc_spline() for
     information on how to build the points array.

See also:
*Note calc_spline::.
*Note drawing_mode::.
*Note makecol::.
*Note exspline::.
*Note BITMAP::.


File: allegro.info,  Node: floodfill,  Next: blit,  Prev: spline,  Up: Drawing

1.14.26 floodfill
-----------------

void floodfill(BITMAP *bmp, int x, int y, int color);
     Floodfills an enclosed area, starting at point (x, y), with the
     specified color.

See also:
*Note drawing_mode::.
*Note makecol::.
*Note BITMAP::.


File: allegro.info,  Node: Blitting,  Next: RLE,  Prev: Drawing,  Up: API

1.15 Blitting and sprites
=========================

As far as Allegro is concerned, a bitmap and a sprite are the same
thing, but to many people the two words imply slightly different things.
The function draw_sprite() is called so rather than draw_bitmap() partly
because it indicates that it uses a masked drawing mode (if it existed,
you could expect draw_bitmap() to be a simple block copy), and partly
for historical reasons.  In Allegro 1.0 there were actually different
structures for sprites and bitmaps, each with their own set of
abilities.  Allegro 2.0 merged these into a single more flexible
structure, but retained some names like draw_sprite().

In wider (non-Allegro) terms, the two words can mean quite different
things.  Generally you can say that sprites are a subset of bitmaps, but
even that isn't true in 100% of cases.

BITMAP: a widely accepted term that will be understood by anyone even
remotely connected with computer graphics.  It simply means an image
built up from a grid of pixels, ie.  just about any picture that you are
likely to come across on a computer (vector graphics formats are the
exception, but those must be rendered into a bitmap format before they
can be displayed by most hardware).  A more accurate term but slightly
rarer term with the same meaning is "pixmap" (pixel-map).

SPRITE: a particular usage of bitmapped images, restricted to video
games (other types of programmer probably won't be familiar with this
term).  Originally on machines like the C64, sprites were a hardware
feature that allowed a number of small bitmap images to be loaded into
special registers, and they could then be superimposed over the main
graphics display and moved around just by modifying the position
register.  They were used for the moving objects (player and enemy
characters), and enabled the C64 to do much more impressive things than
would have been possible if all the drawing had to be done directly by
the puny CPU.

Later on, a lot of old C64 programmers upgraded to machines like the
Atari ST, which didn't have any special sprite hardware, but they
carried on referring to their main moving objects as sprites (the
routine to draw such a thing would obviously be called draw_sprite()).
A sprite is really just a bitmap graphic which is drawn onto the screen,
but when you call it a sprite rather than a bitmap, this suggests it is
a gameplay element that can move freely around the world rather than
being a static part of the environment, and that it will be drawn in a
masked overlay mode rather than as a solid rectangle (there is also a
strong implication that a sprite will be animated by cycling through a
number of frames, but that isn't always the case).

In recent years some people have started using "sprite" to refer to any
character graphics, even if they are not in fact drawn as 2d bitmaps,
eg.  "this game uses 3d polygonal player sprites".  This is a confusing
misuse of the word (Doom uses sprites, Quake does not), but it does
happen.

The origin of the term "blit" is also rather interesting.  This was
originally BitBlt, an abbreviation of BITmap BLock Transfer, which was a
function designed (possibly) by the people at Xerox who did so much of
the pioneering work on graphics display systems, and subsequently copied
by virtually everybody doing computer graphics (the Microsoft Windows
GDI still provides a BitBlt function with identical functionality to the
original).  This routine was a workhorse for all sorts of drawing
operations, basically copying bitmap graphics from one place to another,
but including a number of different ROP modes (Raster OPerations) for
doing things like XOR, inverting pixels, etc.  A whole family of related
words grew up around the BitBlt function, but "blt" is impossible to
speak (try saying "bltter" or "bltting" :-) so people added the vowel to
make it easier to pronounce.

Therefore, the act of calling the BitBlt function came to be known as
"doing a blit".  The obvious next step was to rename the function itself
to blit(), which generally took place at the same time as people decided
to simplify the original, removing the different ROP modes on the
grounds that they aren't needed for games coding and don't work well
with anything higher than monochrome images in any case.  This leaves us
with a function called blit(), which is an abbreviation for "block
transfer".  A strong case could be made for calling this blot() instead,
but somehow that just doesn't sound the same!

Anyway, all the routines in this chapter are affected by the clipping
rectangle of the destination bitmap.

* Menu:

* blit::
* stretch_blit::
* masked_blit::
* masked_stretch_blit::
* draw_sprite_ex::
* draw_sprite::
* stretch_sprite::
* draw_sprite_v_flip::
* draw_trans_sprite::
* draw_lit_sprite::
* draw_gouraud_sprite::
* draw_character_ex::
* rotate_sprite::
* rotate_sprite_v_flip::
* rotate_scaled_sprite::
* rotate_scaled_sprite_v_flip::
* pivot_sprite::
* pivot_sprite_v_flip::
* pivot_scaled_sprite::
* pivot_scaled_sprite_v_flip::
* rotate_sprite_trans::
* rotate_sprite_v_flip_trans::
* rotate_scaled_sprite_trans::
* rotate_scaled_sprite_v_flip_trans::
* pivot_sprite_trans::
* pivot_sprite_v_flip_trans::
* pivot_scaled_sprite_trans::
* pivot_scaled_sprite_v_flip_trans::
* rotate_sprite_lit::
* rotate_sprite_v_flip_lit::
* rotate_scaled_sprite_lit::
* rotate_scaled_sprite_v_flip_lit::
* pivot_sprite_lit::
* pivot_sprite_v_flip_lit::
* pivot_scaled_sprite_lit::
* pivot_scaled_sprite_v_flip_lit::


File: allegro.info,  Node: blit,  Next: stretch_blit,  Prev: floodfill,  Up: Blitting

1.15.1 blit
-----------

void blit(BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height);
     Copies a rectangular area of the source bitmap to the destination
     bitmap.  The source_x and source_y parameters are the top left
     corner of the area to copy from the source bitmap, and dest_x and
     dest_y are the corresponding position in the destination bitmap.
     This routine respects the destination clipping rectangle, and it
     will also clip if you try to blit from areas outside the source
     bitmap.  Example:

          BITMAP *bmp;
          ...
          /* Blit src on the screen. */
          blit(bmp, screen, 0, 0, 0, 0, bmp->w, bmp->h);

          /* Now copy a chunk to a corner, slightly outside. /*
          blit(screen, screen, 100, 100, -10, -10, 25, 30);

     You can blit between any parts of any two bitmaps, even if the two
     memory areas overlap (ie.  source and dest are the same, or one is
     sub-bitmap of the other).  You should be aware, however, that a lot
     of SVGA cards don't provide separate read and write banks, which
     means that blitting from one part of the screen to another requires
     the use of a temporary bitmap in memory, and is therefore extremely
     slow.  As a general rule you should avoid blitting from the screen
     onto itself in SVGA modes.

     In mode-X, on the other hand, blitting from one part of the screen
     to another can be significantly faster than blitting from memory
     onto the screen, as long as the source and destination are
     correctly aligned with each other.  Copying between overlapping
     screen rectangles is slow, but if the areas don't overlap, and if
     they have the same plane alignment (ie.  (source_x%4) ==
     (dest_x%4)), the VGA latch registers can be used for a very fast
     data transfer.  To take advantage of this, in mode-X it is often
     worth storing tile graphics in a hidden area of video memory (using
     a large virtual screen), and blitting them from there onto the
     visible part of the screen.

     If the GFX_HW_VRAM_BLIT bit in the gfx_capabilities flag is set,
     the current driver supports hardware accelerated blits from one
     part of the screen onto another.  This is extremely fast, so when
     this flag is set it may be worth storing some of your more
     frequently used graphics in an offscreen portion of the video
     memory.

     Unlike most of the graphics routines, blit() allows the source and
     destination bitmaps to be of different color depths, so it can be
     used to convert images from one pixel format to another.  In this
     case, the behavior is affected by the COLORCONV_KEEP_TRANS and
     COLORCONV_DITHER* flags of the current color conversion mode: see
     set_color_conversion() for more information.

See also:
*Note masked_blit::.
*Note stretch_blit::.
*Note draw_sprite::.
*Note gfx_capabilities::.
*Note set_color_conversion::.
*Note Available Allegro examples: Available.
*Note BITMAP::.


File: allegro.info,  Node: stretch_blit,  Next: masked_blit,  Prev: blit,  Up: Blitting

1.15.2 stretch_blit
-------------------

void stretch_blit(BITMAP *source, BITMAP *dest, int source_x, source_y, source_width, source_height, int dest_x, dest_y, dest_width, dest_height);
     Like blit(), except it can scale images (so the source and
     destination rectangles don't need to be the same size) and requires
     the source and destination bitmaps to be of the same color depth.
     This routine doesn't do as much safety checking as the regular
     blit(): in particular you must take care not to copy from areas
     outside the source bitmap, and you cannot blit between overlapping
     regions, ie.  you must use different bitmaps for the source and the
     destination.  Moreover, the source must be a memory bitmap.
     Example:

          BITMAP *bmp;
          ...
          /* Stretch bmp to fill the screen. */
          stretch_blit(bmp, screen, 0, 0, bmp->w, bmp->h,
                       0, 0, SCREEN_W, SCREEN_H);

See also:
*Note blit::.
*Note masked_stretch_blit::.
*Note stretch_sprite::.
*Note exalpha::.
*Note exconfig::.
*Note exscale::.
*Note extrans::.
*Note extrans2::.
*Note BITMAP::.


File: allegro.info,  Node: masked_blit,  Next: masked_stretch_blit,  Prev: stretch_blit,  Up: Blitting

1.15.3 masked_blit
------------------

void masked_blit(BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height);
     Like blit(), but skips transparent pixels, which are marked by a
     zero in 256-color modes or bright pink for truecolor data (maximum
     red and blue, zero green), and requires the source and destination
     bitmaps to be of the same color depth.  The source and destination
     regions must not overlap.  Example:

          BITMAP *hud_overlay;
          ...
          /* Paint hud overlay on the screen. */
          masked_blit(hud_overlay, screen, 0, 0, 0, 0,
                      hud_overlay->w, hud_overlay->h);

     If the GFX_HW_VRAM_BLIT_MASKED bit in the gfx_capabilities flag is
     set, the current driver supports hardware accelerated masked blits
     from one part of the screen onto another.  This is extremely fast,
     so when this flag is set it may be worth storing some of your more
     frequently used sprites in an offscreen portion of the video
     memory.

     Warning: if the hardware acceleration flag is not set,
     masked_blit() will not work correctly when used with a source image
     in system or video memory so the latter must be a memory bitmap.

See also:
*Note blit::.
*Note masked_stretch_blit::.
*Note draw_sprite::.
*Note bitmap_mask_color::.
*Note ex12bit::.
*Note expat::.
*Note BITMAP::.


File: allegro.info,  Node: masked_stretch_blit,  Next: draw_sprite_ex,  Prev: masked_blit,  Up: Blitting

1.15.4 masked_stretch_blit
--------------------------

void masked_stretch_blit(BITMAP *source, BITMAP *dest, int source_x, source_y, source_w, source_h, int dest_x, dest_y, dest_w, dest_h);
     Like masked_blit(), except it can scale images (so the source and
     destination rectangles don't need to be the same size).  This
     routine doesn't do as much safety checking as the regular
     masked_blit(): in particular you must take care not to copy from
     areas outside the source bitmap.  Moreover, the source must be a
     memory bitmap.  Example:

          BITMAP *hud_overlay;
          ...
          /* Stretch hud overlay over the screen. */
          masked_stretch_blit(hud_overlay, screen, 0, 0,
                              hud_overlay->w, hud_overlay->h,
                              0, 0, SCREEN_W, SCREEN_H);

See also:
*Note blit::.
*Note masked_blit::.
*Note stretch_blit::.
*Note stretch_sprite::.
*Note BITMAP::.


File: allegro.info,  Node: draw_sprite_ex,  Next: draw_sprite,  Prev: masked_stretch_blit,  Up: Blitting

1.15.5 draw_sprite_ex
---------------------

void draw_sprite_ex(BITMAP *bmp, BITMAP *sprite, int x, int y, int mode, int flip);
     Draws the sprite image onto the destination bitmap using the
     specified mode argument, optionally flipping the sprite in the
     orientation specified by flip argument.  The mode argument defines
     how is sprite going to be drawn on the destination bitmap:

          DRAW_SPRITE_NORMAL     - draws a masked sprite, like draw_sprite()
          DRAW_SPRITE_LIT        - draws a tinted sprite, like draw_lit_sprite()
          DRAW_SPRITE_TRANS      - draws a blended sprite, like draw_trans_sprite()

     The flip argument defines the flipping orientation:

          DRAW_SPRITE_NO_FLIP = 0    - do not perform flipping
          DRAW_SPRITE_H_FLIP         - flip horizontally
          DRAW_SPRITE_V_FLIP         - flip vertically
          DRAW_SPRITE_VH_FLIP        - flip both vertically and horizontally

See also:
*Note draw_sprite::.
*Note draw_sprite_v_flip::.
*Note draw_sprite_h_flip: draw_sprite_v_flip.
*Note draw_trans_sprite::.
*Note draw_lit_sprite::.
*Note extrans2::.
*Note BITMAP::.


File: allegro.info,  Node: draw_sprite,  Next: stretch_sprite,  Prev: draw_sprite_ex,  Up: Blitting

1.15.6 draw_sprite
------------------

void draw_sprite(BITMAP *bmp, BITMAP *sprite, int x, int y);
     Draws a copy of the sprite bitmap onto the destination bitmap at
     the specified position.  This is almost the same as blit(sprite,
     bmp, 0, 0, x, y, sprite->w, sprite->h), but it uses a masked
     drawing mode where transparent pixels are skipped, so the
     background image will show through the masked parts of the sprite.
     Transparent pixels are marked by a zero in 256-color modes or
     bright pink for truecolor data (maximum red and blue, zero green).
     Example:

          BITMAP *spaceship;
          ...
          draw_sprite(screen, spaceship, x, y);

     If the GFX_HW_VRAM_BLIT_MASKED bit in the gfx_capabilities flag is
     set, the current driver supports hardware accelerated sprite
     drawing when the source image is a video memory bitmap or a
     sub-bitmap of the screen.  This is extremely fast, so when this
     flag is set it may be worth storing some of your more frequently
     used sprites in an offscreen portion of the video memory.

     Warning: if the hardware acceleration flag is not set,
     draw_sprite() will not work correctly when used with a sprite image
     in system or video memory so the latter must be a memory bitmap.

     Although generally not supporting graphics of mixed color depths,
     as a special case this function can be used to draw 256-color
     source images onto truecolor destination bitmaps, so you can use
     palette effects on specific sprites within a truecolor program.

See also:
*Note draw_sprite_v_flip::.
*Note draw_trans_sprite::.
*Note draw_lit_sprite::.
*Note draw_gouraud_sprite::.
*Note stretch_sprite::.
*Note rotate_sprite::.
*Note draw_character_ex::.
*Note draw_rle_sprite::.
*Note draw_compiled_sprite::.
*Note masked_blit::.
*Note blit::.
*Note bitmap_mask_color::.
*Note exsprite::.
*Note BITMAP::.


File: allegro.info,  Node: stretch_sprite,  Next: draw_sprite_v_flip,  Prev: draw_sprite,  Up: Blitting

1.15.7 stretch_sprite
---------------------

void stretch_sprite(BITMAP *bmp, BITMAP *sprite, int x, int y, int w, int h);
     Like draw_sprite(), except it can stretch the sprite image to the
     specified width and height and requires the sprite image and
     destination bitmap to be of the same color depth.  Moreover, the
     sprite image must be a memory bitmap.  Example:

          /* Create tunnel like effect. */
          for (step = 1; step
             int width = SCREEN_W / step;
             int height = SCREEN_H / step;
             stretch_sprite(screen, image, SCREEN_W / 2 - width / 2,
                            SCREEN_H / 2 - height / 2, width, height);
          }

See also:
*Note draw_sprite::.
*Note stretch_blit::.
*Note bitmap_mask_color::.
*Note BITMAP::.


File: allegro.info,  Node: draw_sprite_v_flip,  Next: draw_trans_sprite,  Prev: stretch_sprite,  Up: Blitting

1.15.8 draw_sprite_v_flip
-------------------------

void draw_sprite_v_flip(BITMAP *bmp, BITMAP *sprite, int x, int y);
void draw_sprite_h_flip(BITMAP *bmp, BITMAP *sprite, int x, int y);
void draw_sprite_vh_flip(BITMAP *bmp, BITMAP *sprite, int x, int y);
     These are like draw_sprite(), but they additionally flip the image
     vertically, horizontally, or both, respectively.  Flipping
     vertically means that the y-axis is reversed, while flipping
     horizontally means that the x-axis is reversed, between the source
     and the destination.  This produces exact mirror images, which is
     not the same as rotating the sprite (and it is a lot faster than
     the rotation routine).  The sprite must be a memory bitmap.
     Example:

          if (key[KEY_RIGHT])
             draw_sprite(screen, hero_right, pos_x, pos_y);
          else if (key[KEY_LEFT])
             draw_sprite_h_flip(screen, hero_right, pos_x, pos_y);
          else
             draw_sprite(screen, hero_idle, pos_x, pos_y);

See also:
*Note draw_sprite::.
*Note bitmap_mask_color::.
*Note exsprite::.
*Note BITMAP::.


File: allegro.info,  Node: draw_trans_sprite,  Next: draw_lit_sprite,  Prev: draw_sprite_v_flip,  Up: Blitting

1.15.9 draw_trans_sprite
------------------------

void draw_trans_sprite(BITMAP *bmp, BITMAP *sprite, int x, int y);
     Uses the global color_map table or truecolor blender functions to
     overlay the sprite on top of the existing image.  This must only be
     used after you have set up the color mapping table (for 256-color
     modes) or blender functions (for truecolor modes).  Because it
     involves reading as well as writing the bitmap memory, translucent
     drawing is very slow if you draw directly to video RAM, so wherever
     possible you should use a memory bitmap instead.  Example:

          /* Some one time initialisation code. */
          COLOR_MAP global_trans_table;
          create_trans_table(&global_trans_table, my_palette,
                             128, 128, 128, NULL);
          ...
          if (get_color_depth() == 8)
             color_map = &global_trans_table;
          else
             set_trans_blender(128, 128, 128, 128);

          draw_trans_sprite(buffer, ghost_sprite, x, y);

     The bitmap and sprite must normally be in the same color depth, but
     as a special case you can draw 32 bit RGBA format sprites onto any
     hicolor or truecolor bitmap, as long as you call
     set_alpha_blender() first, and you can draw 8-bit alpha images onto
     a 32-bit RGBA destination, as long as you call
     set_write_alpha_blender() first.  As draw_sprite() this function
     skips transparent pixels, except if the source sprite is an 8-bit
     image; if this is the case, you should pay attention to properly
     set up your color map table for index 0.

See also:
*Note draw_sprite::.
*Note draw_lit_sprite::.
*Note draw_trans_rle_sprite::.
*Note color_map::.
*Note set_trans_blender::.
*Note set_alpha_blender::.
*Note set_write_alpha_blender::.
*Note bitmap_mask_color::.
*Note exalpha::.
*Note exblend::.
*Note exlights::.
*Note exrotscl::.
*Note extrans::.
*Note exxfade::.
*Note BITMAP::.


File: allegro.info,  Node: draw_lit_sprite,  Next: draw_gouraud_sprite,  Prev: draw_trans_sprite,  Up: Blitting

1.15.10 draw_lit_sprite
-----------------------

void draw_lit_sprite(BITMAP *bmp, BITMAP *sprite, int x, int y, int color);
     In 256-color modes, uses the global color_map table to tint the
     sprite image to the specified color or to light it to the level
     specified by 'color', depending on the function which was used to
     build the table (create_trans_table or create_light_table), and
     draws the resulting image to the destination bitmap.  In truecolor
     modes, uses the blender functions to light the sprite image using
     the alpha level specified by 'color' (the alpha level which was
     passed to the blender functions is ignored) and draws the resulting
     image to the destination bitmap.  The 'color' parameter must be in
     the range [0-255] whatever its actual meaning is.  This must only
     be used after you have set up the color mapping table (for
     256-color modes) or blender functions (for truecolor modes).
     Example:

          /* Some one time initialisation code. */
          COLOR_MAP global_light_table;
          create_light_table(&global_trans_table, my_palette,
                             10, 10, 60, NULL);
          ...
          if (get_color_depth() == 8)
             color_map = &global_light_table;
          else
             set_trans_blender(40, 40, 255, 255);

          /* Lit the cape with a blueish light. */
          draw_lit_sprite(buffer, colored_cape, x, y, 64);

See also:
*Note draw_sprite::.
*Note draw_trans_sprite::.
*Note draw_gouraud_sprite::.
*Note draw_lit_rle_sprite::.
*Note color_map::.
*Note set_trans_blender::.
*Note bitmap_mask_color::.
*Note exblend::.
*Note BITMAP::.


File: allegro.info,  Node: draw_gouraud_sprite,  Next: draw_character_ex,  Prev: draw_lit_sprite,  Up: Blitting

1.15.11 draw_gouraud_sprite
---------------------------

void draw_gouraud_sprite(BITMAP *bmp, BITMAP *sprite, int x, int y, int c1, int c2, int c3, int c4);
     More sophisticated version of draw_lit_sprite(): the 'color'
     parameter is not constant across the sprite image anymore but
     interpolated between the four specified corner colors.  The corner
     values passed to this function indicate the strength of the color
     applied on them, ranging from 0 (no strength) to 255 (full
     strength).  Example:

          /* Some one time initialisation code. */
          COLOR_MAP global_light_table;
          create_light_table(&global_trans_table, my_palette,
                             0, 0, 0, NULL);
          ...
          if (get_color_depth() == 8)
             color_map = &global_light_table;
          else
             set_trans_blender(0, 0, 0, 128);

          /* Enemies are in shadow unless lit by torch. */
          draw_gouraud_sprite(buffer, menacing_spy, x, y,
                              light_strength_on_corner_1,
                              light_strength_on_corner_2,
                              light_strength_on_corner_3,
                              light_strength_on_corner_4);

See also:
*Note draw_sprite::.
*Note draw_lit_sprite::.
*Note color_map::.
*Note set_trans_blender::.
*Note bitmap_mask_color::.
*Note exshade::.
*Note BITMAP::.


File: allegro.info,  Node: draw_character_ex,  Next: rotate_sprite,  Prev: draw_gouraud_sprite,  Up: Blitting

1.15.12 draw_character_ex
-------------------------

void draw_character_ex(BITMAP *bmp, BITMAP *sprite, int x, int y, color, bg);
     Draws a copy of the sprite bitmap onto the destination bitmap at
     the specified position, drawing transparent pixels in the
     background color (or skipping them if the background color is -1)
     and setting all other pixels to the specified color.  Transparent
     pixels are marked by a zero in 256-color modes or bright pink for
     truecolor data (maximum red and blue, zero green).  The sprite must
     be an 8-bit image, even if the destination is a truecolor bitmap.
     Example:

          BITMAP *logo;
          ...
          /* Draw the logo silhouette in red. */
          draw_character_ex(screen, logo, SCREEN_W / 2, SCREEN_H / 2,
                            makecol(255, 0, 0), -1);

See also:
*Note draw_sprite::.
*Note bitmap_mask_color::.
*Note BITMAP::.


File: allegro.info,  Node: rotate_sprite,  Next: rotate_sprite_v_flip,  Prev: draw_character_ex,  Up: Blitting

1.15.13 rotate_sprite
---------------------

void rotate_sprite(BITMAP *bmp, BITMAP *sprite, int x, int y, fixed angle);
     Draws the sprite image onto the bitmap.  It is placed with its top
     left corner at the specified position, then rotated by the
     specified angle around its centre.  The angle is a fixed point
     16.16 number in the same format used by the fixed point trig
     routines, with 256 equal to a full circle, 64 a right angle, etc.
     All rotation functions can draw between any two bitmaps, even
     screen bitmaps or bitmaps of different color depth.

     Positive increments of the angle will make the sprite rotate
     clockwise on the screen, as demonstrated by the Allegro example.

See also:
*Note draw_sprite::.
*Note rotate_scaled_sprite::.
*Note rotate_sprite_v_flip::.
*Note rotate_scaled_sprite_v_flip::.
*Note pivot_sprite::.
*Note pivot_sprite_v_flip::.
*Note pivot_scaled_sprite::.
*Note pivot_scaled_sprite_v_flip::.
*Note itofix::.
*Note Fixed point trig::.
*Note exsprite::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: rotate_sprite_v_flip,  Next: rotate_scaled_sprite,  Prev: rotate_sprite,  Up: Blitting

1.15.14 rotate_sprite_v_flip
----------------------------

void rotate_sprite_v_flip(BITMAP *bmp, BITMAP *sprite, int x, int y, fixed angle);
     Like rotate_sprite, but flips the image vertically before rotating
     it.  To flip horizontally, use this routine but add itofix(128) to
     the angle.  To flip in both directions, use rotate_sprite() and add
     itofix(128) to its angle.

See also:
*Note rotate_sprite::.
*Note rotate_scaled_sprite_v_flip::.
*Note pivot_sprite_v_flip::.
*Note pivot_scaled_sprite_v_flip::.
*Note exsprite::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: rotate_scaled_sprite,  Next: rotate_scaled_sprite_v_flip,  Prev: rotate_sprite_v_flip,  Up: Blitting

1.15.15 rotate_scaled_sprite
----------------------------

void rotate_scaled_sprite(BITMAP *bmp, BITMAP *sprite, int x, int y, fixed angle, fixed scale);
     Like rotate_sprite(), but stretches or shrinks the image at the
     same time as rotating it.

See also:
*Note rotate_sprite::.
*Note rotate_scaled_sprite_v_flip::.
*Note pivot_scaled_sprite::.
*Note pivot_scaled_sprite_v_flip::.
*Note exrotscl::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: rotate_scaled_sprite_v_flip,  Next: pivot_sprite,  Prev: rotate_scaled_sprite,  Up: Blitting

1.15.16 rotate_scaled_sprite_v_flip
-----------------------------------

void rotate_scaled_sprite_v_flip(BITMAP *bmp, BITMAP *sprite, int x, int y, fixed angle, fixed scale);
     Draws the sprite, similar to rotate_scaled_sprite() except that it
     flips the sprite vertically first.

See also:
*Note rotate_sprite::.
*Note rotate_scaled_sprite::.
*Note rotate_sprite_v_flip::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: pivot_sprite,  Next: pivot_sprite_v_flip,  Prev: rotate_scaled_sprite_v_flip,  Up: Blitting

1.15.17 pivot_sprite
--------------------

void pivot_sprite(BITMAP *bmp, BITMAP *sprite, int x, int y, int cx, int cy, fixed angle);
     Like rotate_sprite(), but aligns the point in the sprite given by
     (cx, cy) to (x, y) in the bitmap, then rotates around this point.

See also:
*Note rotate_sprite::.
*Note pivot_scaled_sprite::.
*Note pivot_sprite_v_flip::.
*Note exsprite::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: pivot_sprite_v_flip,  Next: pivot_scaled_sprite,  Prev: pivot_sprite,  Up: Blitting

1.15.18 pivot_sprite_v_flip
---------------------------

void pivot_sprite_v_flip(BITMAP *bmp, BITMAP *sprite, int x, int y, int cx, int cy, fixed angle);
     Like rotate_sprite_v_flip(), but aligns the point in the sprite
     given by (cx, cy) to (x, y) in the bitmap, then rotates around this
     point.

See also:
*Note rotate_sprite::.
*Note rotate_sprite_v_flip::.
*Note pivot_sprite::.
*Note exsprite::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: pivot_scaled_sprite,  Next: pivot_scaled_sprite_v_flip,  Prev: pivot_sprite_v_flip,  Up: Blitting

1.15.19 pivot_scaled_sprite
---------------------------

void pivot_scaled_sprite(BITMAP *bmp, BITMAP *sprite, int x, int y, int cx, int cy, fixed angle, fixed scale);
     Like rotate_scaled_sprite(), but aligns the point in the sprite
     given by (cx, cy) to (x, y) in the bitmap, then rotates and scales
     around this point.

See also:
*Note rotate_sprite::.
*Note rotate_scaled_sprite::.
*Note pivot_sprite::.
*Note pivot_scaled_sprite_v_flip::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: pivot_scaled_sprite_v_flip,  Next: rotate_sprite_trans,  Prev: pivot_scaled_sprite,  Up: Blitting

1.15.20 pivot_scaled_sprite_v_flip
----------------------------------

void pivot_scaled_sprite_v_flip(BITMAP *bmp, BITMAP *sprite, int x, int y, int cx, int cy, fixed angle, fixed scale);
     Like rotate_scaled_sprite_v_flip(), but aligns the point in the
     sprite given by (cx, cy) to (x, y) in the bitmap, then rotates and
     scales around this point.

See also:
*Note rotate_sprite::.
*Note rotate_scaled_sprite_v_flip::.
*Note rotate_sprite_v_flip::.
*Note pivot_sprite::.
*Note pivot_scaled_sprite::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: rotate_sprite_trans,  Next: rotate_sprite_v_flip_trans,  Prev: pivot_scaled_sprite_v_flip,  Up: Blitting

1.15.21 rotate_sprite_trans
---------------------------

void rotate_sprite_trans(BITMAP *bmp, BITMAP *sprite,
int x, int y, fixed angle);
     Draws the sprite image onto the bitmap.  It is placed with its top
     left corner at the specified position, then rotated by the
     specified angle around its centre.  The angle is a fixed point
     16.16 number in the same format used by the fixed point trig
     routines, with 256 equal to a full circle, 64 a right angle, etc.
     All rotation functions can draw between any two bitmaps, even
     screen bitmaps or bitmaps of different color depth.

     Positive increments of the angle will make the sprite rotate
     clockwise on the screen, as demonstrated by the Allegro example.

See also:
*Note draw_trans_sprite::.
*Note rotate_scaled_sprite_trans::.
*Note rotate_sprite_v_flip_trans::.
*Note rotate_scaled_sprite_v_flip_trans::.
*Note pivot_sprite_trans::.
*Note pivot_sprite_v_flip_trans::.
*Note pivot_scaled_sprite_trans::.
*Note pivot_scaled_sprite_v_flip_trans::.
*Note itofix::.
*Note Fixed point trig::.
*Note exsprite::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: rotate_sprite_v_flip_trans,  Next: rotate_scaled_sprite_trans,  Prev: rotate_sprite_trans,  Up: Blitting

1.15.22 rotate_sprite_v_flip_trans
----------------------------------

void rotate_sprite_v_flip_trans(BITMAP *bmp, BITMAP *sprite, int x, int y, fixed angle);
     Like rotate_sprite_trans, but flips the image vertically before
     rotating it.  To flip horizontally, use this routine but add
     itofix(128) to the angle.  To flip in both directions, use
     rotate_sprite() and add itofix(128) to its angle.

See also:
*Note rotate_sprite_trans::.
*Note rotate_scaled_sprite_v_flip_trans::.
*Note pivot_sprite_v_flip_trans::.
*Note pivot_scaled_sprite_v_flip_trans::.
*Note exsprite::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: rotate_scaled_sprite_trans,  Next: rotate_scaled_sprite_v_flip_trans,  Prev: rotate_sprite_v_flip_trans,  Up: Blitting

1.15.23 rotate_scaled_sprite_trans
----------------------------------

void rotate_scaled_sprite_trans(BITMAP *bmp, BITMAP *sprite, int x, int y, fixed angle, fixed scale);
     Like rotate_sprite_trans(), but stretches or shrinks the image at
     the same time as rotating it.

See also:
*Note rotate_sprite_trans::.
*Note rotate_scaled_sprite_v_flip_trans::.
*Note pivot_scaled_sprite_trans::.
*Note pivot_scaled_sprite_v_flip_trans::.
*Note exrotscl::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: rotate_scaled_sprite_v_flip_trans,  Next: pivot_sprite_trans,  Prev: rotate_scaled_sprite_trans,  Up: Blitting

1.15.24 rotate_scaled_sprite_v_flip_trans
-----------------------------------------

void rotate_scaled_sprite_v_flip_trans(BITMAP *bmp, BITMAP *sprite, int x, int y,
fixed angle, fixed scale);
     Draws the sprite, similar to rotate_scaled_sprite_trans() except
     that it flips the sprite vertically first.

See also:
*Note rotate_sprite_trans::.
*Note rotate_scaled_sprite_trans::.
*Note rotate_sprite_v_flip_trans::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: pivot_sprite_trans,  Next: pivot_sprite_v_flip_trans,  Prev: rotate_scaled_sprite_v_flip_trans,  Up: Blitting

1.15.25 pivot_sprite_trans
--------------------------

void pivot_sprite_trans(BITMAP *bmp, BITMAP *sprite, int x, int y, int cx, int cy, fixed angle);
     Like rotate_sprite_trans(), but aligns the point in the sprite
     given by (cx, cy) to (x, y) in the bitmap, then rotates around this
     point.

See also:
*Note rotate_sprite_trans::.
*Note pivot_scaled_sprite_trans::.
*Note pivot_sprite_v_flip_trans::.
*Note exsprite::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: pivot_sprite_v_flip_trans,  Next: pivot_scaled_sprite_trans,  Prev: pivot_sprite_trans,  Up: Blitting

1.15.26 pivot_sprite_v_flip_trans
---------------------------------

void pivot_sprite_v_flip_trans(BITMAP *bmp, BITMAP *sprite, int x, int y, int cx, int cy, fixed angle);
     Like rotate_sprite_v_flip_trans(), but aligns the point in the
     sprite given by (cx, cy) to (x, y) in the bitmap, then rotates
     around this point.

See also:
*Note rotate_sprite_trans::.
*Note rotate_sprite_v_flip_trans::.
*Note pivot_sprite_trans::.
*Note exsprite::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: pivot_scaled_sprite_trans,  Next: pivot_scaled_sprite_v_flip_trans,  Prev: pivot_sprite_v_flip_trans,  Up: Blitting

1.15.27 pivot_scaled_sprite_trans
---------------------------------

void pivot_scaled_sprite_trans(BITMAP *bmp, BITMAP *sprite, int x, int y, int cx, int cy, fixed angle, fixed scale);
     Like rotate_scaled_sprite_trans(), but aligns the point in the
     sprite given by (cx, cy) to (x, y) in the bitmap, then rotates and
     scales around this point.

See also:
*Note rotate_sprite_trans::.
*Note rotate_scaled_sprite_trans::.
*Note pivot_sprite_trans::.
*Note pivot_scaled_sprite_v_flip_trans::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: pivot_scaled_sprite_v_flip_trans,  Next: rotate_sprite_lit,  Prev: pivot_scaled_sprite_trans,  Up: Blitting

1.15.28 pivot_scaled_sprite_v_flip_trans
----------------------------------------

void pivot_scaled_sprite_v_flip_trans(BITMAP *bmp, BITMAP *sprite, int x, int y,
int cx, int cy, fixed angle, fixed scale);
     Like rotate_scaled_sprite_v_flip_trans(), but aligns the point in
     the sprite given by (cx, cy) to (x, y) in the bitmap, then rotates
     and scales around this point.

See also:
*Note rotate_sprite_trans::.
*Note rotate_scaled_sprite_v_flip_trans::.
*Note rotate_sprite_v_flip_trans::.
*Note pivot_sprite_trans::.
*Note pivot_scaled_sprite_trans::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: rotate_sprite_lit,  Next: rotate_sprite_v_flip_lit,  Prev: pivot_scaled_sprite_v_flip_trans,  Up: Blitting

1.15.29 rotate_sprite_lit
-------------------------

void rotate_sprite_lit(BITMAP *bmp, BITMAP *sprite,
int x, int y, fixed angle);
     Draws the sprite image onto the bitmap.  It is placed with its top
     left corner at the specified position, then rotated by the
     specified angle around its centre.  The angle is a fixed point
     16.16 number in the same format used by the fixed point trig
     routines, with 256 equal to a full circle, 64 a right angle, etc.
     All rotation functions can draw between any two bitmaps, even
     screen bitmaps or bitmaps of different color depth.

     Positive increments of the angle will make the sprite rotate
     clockwise on the screen, as demonstrated by the Allegro example.

See also:
*Note draw_lit_sprite::.
*Note rotate_scaled_sprite_lit::.
*Note rotate_sprite_v_flip_lit::.
*Note rotate_scaled_sprite_v_flip_lit::.
*Note pivot_sprite_lit::.
*Note pivot_sprite_v_flip_lit::.
*Note pivot_scaled_sprite_lit::.
*Note pivot_scaled_sprite_v_flip_lit::.
*Note itofix::.
*Note Fixed point trig::.
*Note exsprite::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: rotate_sprite_v_flip_lit,  Next: rotate_scaled_sprite_lit,  Prev: rotate_sprite_lit,  Up: Blitting

1.15.30 rotate_sprite_v_flip_lit
--------------------------------

void rotate_sprite_v_flip_lit(BITMAP *bmp, BITMAP *sprite, int x, int y, fixed angle);
     Like rotate_sprite_lit, but flips the image vertically before
     rotating it.  To flip horizontally, use this routine but add
     itofix(128) to the angle.  To flip in both directions, use
     rotate_sprite() and add itofix(128) to its angle.

See also:
*Note rotate_sprite_lit::.
*Note rotate_scaled_sprite_v_flip_lit::.
*Note pivot_sprite_v_flip_lit::.
*Note pivot_scaled_sprite_v_flip_lit::.
*Note exsprite::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: rotate_scaled_sprite_lit,  Next: rotate_scaled_sprite_v_flip_lit,  Prev: rotate_sprite_v_flip_lit,  Up: Blitting

1.15.31 rotate_scaled_sprite_lit
--------------------------------

void rotate_scaled_sprite_lit(BITMAP *bmp, BITMAP *sprite, int x, int y, fixed angle, fixed scale);
     Like rotate_sprite_lit(), but stretches or shrinks the image at the
     same time as rotating it.

See also:
*Note rotate_sprite_lit::.
*Note rotate_scaled_sprite_v_flip_lit::.
*Note pivot_scaled_sprite_lit::.
*Note pivot_scaled_sprite_v_flip_lit::.
*Note exrotscl::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: rotate_scaled_sprite_v_flip_lit,  Next: pivot_sprite_lit,  Prev: rotate_scaled_sprite_lit,  Up: Blitting

1.15.32 rotate_scaled_sprite_v_flip_lit
---------------------------------------

void rotate_scaled_sprite_v_flip_lit(BITMAP *bmp, BITMAP *sprite, int x, int y,
fixed angle, fixed scale);
     Draws the sprite, similar to rotate_scaled_sprite_lit() except that
     it flips the sprite vertically first.

See also:
*Note rotate_sprite_lit::.
*Note rotate_scaled_sprite_lit::.
*Note rotate_sprite_v_flip_lit::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: pivot_sprite_lit,  Next: pivot_sprite_v_flip_lit,  Prev: rotate_scaled_sprite_v_flip_lit,  Up: Blitting

1.15.33 pivot_sprite_lit
------------------------

void pivot_sprite_lit(BITMAP *bmp, BITMAP *sprite, int x, int y, int cx, int cy, fixed angle);
     Like rotate_sprite_lit(), but aligns the point in the sprite given
     by (cx, cy) to (x, y) in the bitmap, then rotates around this
     point.

See also:
*Note rotate_sprite_lit::.
*Note pivot_scaled_sprite_lit::.
*Note pivot_sprite_v_flip_lit::.
*Note exsprite::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: pivot_sprite_v_flip_lit,  Next: pivot_scaled_sprite_lit,  Prev: pivot_sprite_lit,  Up: Blitting

1.15.34 pivot_sprite_v_flip_lit
-------------------------------

void pivot_sprite_v_flip_lit(BITMAP *bmp, BITMAP *sprite, int x, int y, int cx, int cy, fixed angle);
     Like rotate_sprite_v_flip_lit(), but aligns the point in the sprite
     given by (cx, cy) to (x, y) in the bitmap, then rotates around this
     point.

See also:
*Note rotate_sprite_lit::.
*Note rotate_sprite_v_flip_lit::.
*Note pivot_sprite_lit::.
*Note exsprite::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: pivot_scaled_sprite_lit,  Next: pivot_scaled_sprite_v_flip_lit,  Prev: pivot_sprite_v_flip_lit,  Up: Blitting

1.15.35 pivot_scaled_sprite_lit
-------------------------------

void pivot_scaled_sprite_lit(BITMAP *bmp, BITMAP *sprite, int x, int y, int cx, int cy, fixed angle, fixed scale);
     Like rotate_scaled_sprite_lit(), but aligns the point in the sprite
     given by (cx, cy) to (x, y) in the bitmap, then rotates and scales
     around this point.

See also:
*Note rotate_sprite_lit::.
*Note rotate_scaled_sprite_lit::.
*Note pivot_sprite_lit::.
*Note pivot_scaled_sprite_v_flip_lit::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: pivot_scaled_sprite_v_flip_lit,  Next: get_rle_sprite,  Prev: pivot_scaled_sprite_lit,  Up: Blitting

1.15.36 pivot_scaled_sprite_v_flip_lit
--------------------------------------

void pivot_scaled_sprite_v_flip_lit(BITMAP *bmp, BITMAP *sprite, int x, int y,
int cx, int cy, fixed angle, fixed scale);
     Like rotate_scaled_sprite_v_flip_lit(), but aligns the point in the
     sprite given by (cx, cy) to (x, y) in the bitmap, then rotates and
     scales around this point.

See also:
*Note rotate_sprite_lit::.
*Note rotate_scaled_sprite_v_flip_lit::.
*Note rotate_sprite_v_flip_lit::.
*Note pivot_sprite_lit::.
*Note pivot_scaled_sprite_lit::.
*Note fixed::.
*Note BITMAP::.


File: allegro.info,  Node: RLE,  Next: Compiled,  Prev: Blitting,  Up: API

1.16 RLE sprites
================

Because bitmaps can be used in so many different ways, the bitmap
structure is quite complicated, and it contains a lot of data.  In many
situations, though, you will find yourself storing images that are only
ever copied to the screen, rather than being drawn onto or used as
filling patterns, etc.  If this is the case you may be better off
storing your images in RLE_SPRITE (read chapter "Structures and types
defined by Allegro" for an internal description of the RLE_SPRITE
structure) or COMPILED_SPRITE (see next chapter) structures rather than
regular bitmaps.

RLE sprites store the image in a simple run-length encoded format, where
repeated zero pixels are replaced by a single length count, and strings
of non-zero pixels are preceded by a counter giving the length of the
solid run.  RLE sprites are usually much smaller than normal bitmaps,
both because of the run length compression, and because they avoid most
of the overhead of the bitmap structure.  They are often also faster
than normal bitmaps, because rather than having to compare every single
pixel with zero to determine whether it should be drawn, it is possible
to skip over a whole run of zeros with a single add, or to copy a long
run of non-zero pixels with fast string instructions.

Every silver lining has a cloud, though, and in the case of RLE sprites
it is a lack of flexibility.  You can't draw onto them, and you can't
flip them, rotate them, or stretch them.  In fact the only thing you can
do with them is to blast them onto a bitmap with the draw_rle_sprite()
function, which is equivalent to using draw_sprite() with a regular
bitmap.  You can convert bitmaps into RLE sprites at runtime, or you can
create RLE sprite structures in grabber datafiles by making a new object
of type 'RLE sprite'.

* Menu:

* get_rle_sprite::
* destroy_rle_sprite::
* draw_rle_sprite::
* draw_trans_rle_sprite::
* draw_lit_rle_sprite::


File: allegro.info,  Node: get_rle_sprite,  Next: destroy_rle_sprite,  Prev: pivot_scaled_sprite_v_flip_lit,  Up: RLE

1.16.1 get_rle_sprite
---------------------

RLE_SPRITE *get_rle_sprite(BITMAP *bitmap);
     Creates an RLE sprite based on the specified bitmap (which must be
     a memory bitmap).  Remember to free this RLE sprite later to avoid
     memory leaks.  Example:

          RLE_SPRITE *rle;
          BITMAP *bmp;
          ...
          /* Create RLE sprite from an existent bitmap. */
          rle = get_rle_sprite(bmp);
          if (!rle)
             abort_on_error("Couldn't create RLE sprite!");

          /* We don't need the bitmap any more.*/
          destroy_bitmap(bmp);

          /* Use the RLE sprite. */
          ...
          /* Destroy it when we don't need it any more. */
          destroy_rle_sprite(rle);

     Returns a pointer to the created RLE sprite, or NULL if the RLE
     sprite could not be created.  Remember to free this RLE sprite
     later to avoid memory leaks.

See also:
*Note draw_rle_sprite::.
*Note destroy_rle_sprite::.
*Note BITMAP::.
*Note RLE_SPRITE::.


File: allegro.info,  Node: destroy_rle_sprite,  Next: draw_rle_sprite,  Prev: get_rle_sprite,  Up: RLE

1.16.2 destroy_rle_sprite
-------------------------

void destroy_rle_sprite(RLE_SPRITE *sprite);
     Destroys an RLE sprite structure previously returned by
     get_rle_sprite().  If you pass a NULL pointer this function won't
     do anything.  Use this once you are done with an RLE sprite to
     avoid memory leaks in your program.

See also:
*Note get_rle_sprite::.
*Note RLE_SPRITE::.


File: allegro.info,  Node: draw_rle_sprite,  Next: draw_trans_rle_sprite,  Prev: destroy_rle_sprite,  Up: RLE

1.16.3 draw_rle_sprite
----------------------

void draw_rle_sprite(BITMAP *bmp, const RLE_SPRITE *sprite, int x, int y);
     Draws an RLE sprite onto a bitmap at the specified position.
     Example:

          RLE_SPRITE *rle_sprite;
          ...
          draw_rle_sprite(screen, rle_sprite, 100, 100);

See also:
*Note get_rle_sprite::.
*Note draw_sprite::.
*Note draw_compiled_sprite::.
*Note draw_trans_rle_sprite::.
*Note draw_lit_rle_sprite::.
*Note bitmap_mask_color::.
*Note BITMAP::.
*Note RLE_SPRITE::.


File: allegro.info,  Node: draw_trans_rle_sprite,  Next: draw_lit_rle_sprite,  Prev: draw_rle_sprite,  Up: RLE

1.16.4 draw_trans_rle_sprite
----------------------------

void draw_trans_rle_sprite(BITMAP *bmp, const RLE_SPRITE *sprite, int x, int y);
     Translucent version of draw_rle_sprite().  See the description of
     draw_trans_sprite().  This must only be used after you have set up
     the color mapping table (for 256-color modes) or blender functions
     (for truecolor modes).  The bitmap and sprite must normally be in
     the same color depth, but as a special case you can draw 32-bit
     RGBA format sprites onto any hicolor or truecolor bitmap, as long
     as you call set_alpha_blender() first.  Example:

          /* Some one time initialisation code. */
          COLOR_MAP global_trans_table;
          create_trans_table(&global_trans_table, my_palette,
                             128, 128, 128, NULL);
          ...
          if (get_color_depth() == 8)
             color_map = &global_trans_table;
          else
             set_trans_blender(128, 128, 128, 128);

          draw_trans_rle_sprite(buffer, rle_ghost_sprite, x, y);

See also:
*Note draw_rle_sprite::.
*Note draw_lit_rle_sprite::.
*Note draw_trans_sprite::.
*Note color_map::.
*Note set_trans_blender::.
*Note set_alpha_blender::.
*Note bitmap_mask_color::.
*Note BITMAP::.
*Note RLE_SPRITE::.


File: allegro.info,  Node: draw_lit_rle_sprite,  Next: get_compiled_sprite,  Prev: draw_trans_rle_sprite,  Up: RLE

1.16.5 draw_lit_rle_sprite
--------------------------

void draw_lit_rle_sprite(BITMAP *bmp, const RLE_SPRITE *sprite, int x, y, color);
     Tinted version of draw_rle_sprite().  See the description of
     draw_lit_sprite().  This must only be used after you have set up
     the color mapping table (for 256-color modes) or blender functions
     (for truecolor modes).  Example:

          /* Some one time initialisation code. */
          COLOR_MAP global_light_table;
          create_light_table(&global_trans_table, my_palette,
                             10, 10, 60, NULL);
          ...
          if (get_color_depth() == 8)
             color_map = &global_light_table;
          else
             set_trans_blender(40, 40, 255, 255);

          /* Lit the cape with a blueish light. */
          draw_lit_rle_sprite(buffer, rle_colored_cape, x, y, 64);

See also:
*Note draw_rle_sprite::.
*Note draw_trans_rle_sprite::.
*Note draw_lit_sprite::.
*Note color_map::.
*Note set_trans_blender::.
*Note bitmap_mask_color::.
*Note BITMAP::.
*Note RLE_SPRITE::.


File: allegro.info,  Node: Compiled,  Next: Fonts,  Prev: RLE,  Up: API

1.17 Compiled sprites
=====================

Compiled sprites are stored as actual machine code instructions that
draw a specific image onto a bitmap, using mov instructions with
immediate data values.  This is the fastest way to draw a masked image:
on slow machines, up to and including a 486, drawing compiled sprites
can be about to five times as fast as using draw_sprite() with a regular
bitmap.  On newer machines the difference is usually negligible.

Compiled sprites are big, so if memory is tight you should use RLE
sprites instead, and what you can do with them is even more restricted
than with RLE sprites, because they don't support clipping.  If you try
to draw one off the edge of a bitmap, you will corrupt memory and
probably crash the system.  You can convert bitmaps into compiled
sprites at runtime, or you can create compiled sprite structures in
grabber datafiles by making a new object of type 'Compiled sprite' or
'Compiled x-sprite'.

* Menu:

* get_compiled_sprite::
* destroy_compiled_sprite::
* draw_compiled_sprite::


File: allegro.info,  Node: get_compiled_sprite,  Next: destroy_compiled_sprite,  Prev: draw_lit_rle_sprite,  Up: Compiled

1.17.1 get_compiled_sprite
--------------------------

COMPILED_SPRITE *get_compiled_sprite(BITMAP *bitmap, int planar);
     Creates a compiled sprite based on the specified bitmap (which must
     be a memory bitmap).  Compiled sprites are device-dependent, so you
     have to specify whether to compile it into a linear or planar
     format.  Pass FALSE as the second parameter if you are going to be
     drawing it onto memory bitmaps or mode 13h and SVGA screen bitmaps,
     and pass TRUE if you are going to draw it onto mode-X or Xtended
     mode screen bitmaps.  Example:

          COMPILED_SPRITE *cspr;
          BITMAP *bmp;
          ...
          /* Create compiled sprite from an existent bitmap. */
          cspr = get_compiled_sprite(bmp, 0);
          if (!cspr)
             abort_on_error("Couldn't create compiled sprite!");

          /* We don't need the bitmap any more.*/
          destroy_bitmap(bmp);

          /* Use the compiled sprite. */
          ...
          /* Destroy it when we don't need it any more. */
          destroy_compiled_sprite(cspr);

     Returns a pointer to the created compiled sprite, or NULL if the
     compiled sprite could not be created.  Remember to free this
     compiled sprite later to avoid memory leaks.

See also:
*Note draw_compiled_sprite::.
*Note destroy_compiled_sprite::.
*Note BITMAP::.
*Note COMPILED_SPRITE::.


File: allegro.info,  Node: destroy_compiled_sprite,  Next: draw_compiled_sprite,  Prev: get_compiled_sprite,  Up: Compiled

1.17.2 destroy_compiled_sprite
------------------------------

void destroy_compiled_sprite(COMPILED_SPRITE *sprite);
     Destroys a compiled sprite structure previously returned by
     get_compiled_sprite().  If you pass a NULL pointer this function
     won't do anything.  Use this once you are done with a compiled
     sprite to avoid memory leaks in your program.

See also:
*Note get_compiled_sprite::.
*Note COMPILED_SPRITE::.


File: allegro.info,  Node: draw_compiled_sprite,  Next: register_font_file_type,  Prev: destroy_compiled_sprite,  Up: Compiled

1.17.3 draw_compiled_sprite
---------------------------

void draw_compiled_sprite(BITMAP *bmp, const COMPILED_SPRITE *sprite, int x, int y);
     Draws a compiled sprite onto a bitmap at the specified position.
     The sprite must have been compiled for the correct type of bitmap
     (linear or planar).  This function does not support clipping.

     Hint: if not being able to clip compiled sprites is a problem, a
     neat trick is to set up a work surface (memory bitmap, mode-X
     virtual screen, or whatever) a bit bigger than you really need, and
     use the middle of it as your screen.  That way you can draw
     slightly off the edge without any trouble...

See also:
*Note get_compiled_sprite::.
*Note draw_sprite::.
*Note draw_rle_sprite::.
*Note bitmap_mask_color::.
*Note BITMAP::.
*Note COMPILED_SPRITE::.


File: allegro.info,  Node: Fonts,  Next: Text,  Prev: Compiled,  Up: API

1.18 Fonts
==========

Allegro provides routines for loading fonts directly from GRX format
.fnt files, 8x8 or 8x16 BIOS format .fnt files, from bitmap images, from
datafiles or you can import a multiple-range Unicode font by writing a
.txt script that specifies a number of different source files for each
range of characters.

By default, Allegro can only use bitmapped (non-scalable) fonts.  If you
want to use TrueType fonts, you will need to use an add-on library which
allows you to load them on the fly (like AllegTTF or Glyph Keeper,
listed among others at http://www.allegro.cc/) and render them directly,
or generate a bitmapped version of a TrueType font with tools like
TTF2PCX (http://www.talula.demon.co.uk/ttf2pcx/index.html).

* Menu:

* register_font_file_type::
* load_font::
* destroy_font::
* make_trans_font::
* is_trans_font::
* is_color_font::
* is_mono_font::
* font_has_alpha::
* is_compatible_font::
* get_font_ranges::
* get_font_range_begin::
* get_font_range_end::
* extract_font_range::
* transpose_font::
* merge_fonts::
* load_dat_font::
* load_bios_font::
* load_grx_font::
* load_grx_or_bios_font::
* load_bitmap_font::
* grab_font_from_bitmap::
* load_txt_font::


File: allegro.info,  Node: register_font_file_type,  Next: load_font,  Prev: draw_compiled_sprite,  Up: Fonts

1.18.1 register_font_file_type
------------------------------

void register_font_file_type(const char *ext, FONT *(*load)(const char *filename, RGB *pal, void *param));
     Informs the load_font() functions of a new file type, providing a
     routine to read fonts in this format.  The function you supply must
     follow the following prototype:

          FONT *load_my_font(const char *filename, RGB *pal, void *param)
          {
             ...
          }

     The pal parameter can optionally be used to return a palette for
     the FONT. The parameter param can be anything you like: you can use
     this to pass information to your loading routine, such as for
     instance the font height, the character range to load or the index
     number of a font in a datafile.  If you choose to write your own
     font loading code, your function should be prepared to deal with a
     value of NULL for either of these parameters.

See also:
*Note load_font::.
*Note RGB::.
*Note FONT::.


File: allegro.info,  Node: load_font,  Next: destroy_font,  Prev: register_font_file_type,  Up: Fonts

1.18.2 load_font
----------------

FONT *load_font(const char *filename, RGB *pal, void *param);
     Loads a font from a file.  At present, this supports loading fonts
     from a GRX format .fnt file, a 8x8 or 8x16 BIOS format .fnt file, a
     datafile or any bitmap format that can be loaded by load_bitmap().

     If the font contains palette information, then the palette is
     returned in the second parameter, which should be an array of 256
     RGB structures (a PALETTE). The pal argument may be NULL. In this
     case, the palette data, if present, is simply not returned.

     The third parameter can be used to pass specific information to a
     custom loader routine.  Normally, you can just leave this as NULL.
     Note that another way of loading fonts is embedding them into a
     datafile and using the datafile related functions.

     Example:

          FONT *myfont;
          PALETTE palette;
          ...
          myfont = load_font("my_font.pcx", palette, NULL);
          if (!myfont)
             abort_on_error("Couldn't load font!");
          ...
          textout_centre_ex(screen, myfont, "This is my own pretty font!",
                            SCREEN_W / 2, SCREEN_H / 2, white, black);
          ...
          destroy_font(myfont);

     Returns a pointer to the font or NULL on error.  Remember that you
     are responsible for destroying the font when you are finished with
     it to avoid memory leaks.

See also:
*Note register_font_file_type::.
*Note load_bitmap::.
*Note load_dat_font::.
*Note load_bios_font::.
*Note load_grx_font::.
*Note load_grx_or_bios_font::.
*Note load_bitmap_font::.
*Note load_txt_font::.
*Note destroy_font::.
*Note exfont::.
*Note RGB::.
*Note FONT::.


File: allegro.info,  Node: destroy_font,  Next: make_trans_font,  Prev: load_font,  Up: Fonts

1.18.3 destroy_font
-------------------

void destroy_font(FONT *f);
     Frees the memory being used by a font structure.  Don't use this on
     the default global Allegro font or any text routines using it could
     crash.  You should use this only on fonts you have loaded manually
     after you are done with them, to prevent memory leaks in your
     program.

See also:
*Note load_datafile_object::.
*Note load_font::.
*Note exfont::.
*Note FONT::.


File: allegro.info,  Node: make_trans_font,  Next: is_trans_font,  Prev: destroy_font,  Up: Fonts

1.18.4 make_trans_font
----------------------

void make_trans_font(FONT *f);
     This function converts a font to use transparency for drawing.
     That is, each glyph in the font will be drawn with
     draw_trans_sprite, so you can use the same blenders as with
     draw_trans_sprite to draw the font.  One common use of this is to
     load a bitmap font with an alpha channel, and therefore get
     anti-aliased text output by using Allegro's alpha blender.  Here's
     an example how to do that:


          FONT *f = load_font("alphafont.tga", NULL, NULL);
          make_trans_font(f);
          set_alpha_blender();
          textprintf_centre_ex(screen, f, 320, 240, -1, -1, "Anti-aliased Font!");

See also:
*Note is_trans_font::.
*Note set_alpha_blender::.
*Note load_font::.
*Note draw_trans_sprite::.
*Note FONT::.


File: allegro.info,  Node: is_trans_font,  Next: is_color_font,  Prev: make_trans_font,  Up: Fonts

1.18.5 is_trans_font
--------------------

int is_trans_font(FONT *f)
     This function checks if the given font is a color font using
     draw_trans_sprite to render glyphs.

     Returns TRUE if the font uses transparency, FALSE if it does not.

See also:
*Note make_trans_font::.
*Note is_color_font::.
*Note is_mono_font::.
*Note FONT::.


File: allegro.info,  Node: is_color_font,  Next: is_mono_font,  Prev: is_trans_font,  Up: Fonts

1.18.6 is_color_font
--------------------

int is_color_font(FONT *f)
     This function checks if the given font is a color font, as opposed
     to a monochrome font.

     Returns TRUE if the font is a color font, FALSE if it is not.

See also:
*Note is_trans_font::.
*Note is_mono_font::.
*Note FONT::.


File: allegro.info,  Node: is_mono_font,  Next: font_has_alpha,  Prev: is_color_font,  Up: Fonts

1.18.7 is_mono_font
-------------------

int is_mono_font(FONT *f)
     This function checks if the given font is a mono font, as opposed
     to a color font.

     Returns TRUE if the font is a monochrome font, FALSE if it is not.

See also:
*Note is_trans_font::.
*Note is_color_font::.
*Note FONT::.


File: allegro.info,  Node: font_has_alpha,  Next: is_compatible_font,  Prev: is_mono_font,  Up: Fonts

1.18.8 font_has_alpha
---------------------

int font_has_alpha(FONT *f)
     This function goes through all pixels of all glyphs in the font and
     looks for alpha values.

     Returns TRUE if any alpha pixels are found, else FALSE.

See also:
*Note is_trans_font::.
*Note FONT::.


File: allegro.info,  Node: is_compatible_font,  Next: get_font_ranges,  Prev: font_has_alpha,  Up: Fonts

1.18.9 is_compatible_font
-------------------------

int *is_compatible_font(FONT *f1, FONT *f2)
     This function compares the two fonts, which you can use to find out
     if Allegro is capable of merging them.

     Returns TRUE if the two fonts are of the same general type (both
     are color fonts or both are monochrome fonts, for instance).

See also:
*Note merge_fonts::.
*Note is_trans_font::.
*Note is_color_font::.
*Note is_mono_font::.
*Note FONT::.


File: allegro.info,  Node: get_font_ranges,  Next: get_font_range_begin,  Prev: is_compatible_font,  Up: Fonts

1.18.10 get_font_ranges
-----------------------

int get_font_ranges(FONT *f)
     Use this function to find out the number of character ranges in a
     font.  You should query each of these ranges with
     get_font_range_begin() and get_font_range_end() to find out what
     characters are available in the font.  Example:

          FONT *f;
          int range;
          int n;
          ...

          range = get_font_ranges(f);
          printf("The font has %d character ranges:\n", range);
          for (n = 0; n < range; n++)
             printf("Range %d from 0x%03x - 0x%03x\n",
                    get_font_range_begin(f, n),
                    get_font_range_end(f, n));

     Returns the number of continuous character ranges in a font, or -1
     if that information is not available.

See also:
*Note get_font_range_begin::.
*Note get_font_range_end::.
*Note transpose_font::.
*Note FONT::.


File: allegro.info,  Node: get_font_range_begin,  Next: get_font_range_end,  Prev: get_font_ranges,  Up: Fonts

1.18.11 get_font_range_begin
----------------------------

int get_font_range_begin(FONT *f, int range)
     This function allows you to find out the start of a specific
     character range for a font.  You can pass -1 for the 'range'
     parameter if you want to know the start of the whole font range, or
     a number from 0 to (but not including) get_font_ranges(f) to get
     the start of a specific character range in the font.  Example:

          printf("The font has a character range of %d - %d\n",
                 get_font_range_begin(font, -1),
                 get_font_range_end(font, -1));

     Returns the first character in the font range, or -1 if that
     information is not available.

See also:
*Note get_font_ranges::.
*Note get_font_range_end::.
*Note transpose_font::.
*Note FONT::.


File: allegro.info,  Node: get_font_range_end,  Next: extract_font_range,  Prev: get_font_range_begin,  Up: Fonts

1.18.12 get_font_range_end
--------------------------

int get_font_range_end(FONT *f, int range)
     This function allows you to find out the index to the last
     character of a character range for a font.  You can pass -1 for the
     range parameter if you want to know the start of the whole font
     range, or a number from 0 to (but not including) get_font_ranges(f)
     to get the start of a specific character range in the font.  You
     should check the start and end of all font ranges to see if a
     specific character is actually available in the font.  Not all
     characters in the range returned by get_font_range_begin(f, -1) and
     get_font_range_end(f, -1) need to be available!  Example:

          printf("The font has a character range of %d - %d\n",
                 get_font_range_begin(font, -1),
                 get_font_range_end(font, -1));

     Returns the last character in the font range, or -1 if that
     information is not available.

See also:
*Note get_font_ranges::.
*Note get_font_range_begin::.
*Note transpose_font::.
*Note FONT::.


File: allegro.info,  Node: extract_font_range,  Next: transpose_font,  Prev: get_font_range_end,  Up: Fonts

1.18.13 extract_font_range
--------------------------

FONT *extract_font_range(FONT *f, int begin, int end)
     This function extracts a character range from a font and returns a
     new font that contains only the range of characters selected by
     this function.  You can pass -1 for either the lower or upper bound
     if you want to select all characters from the start or to the end
     of the font.  Example:

          FONT *myfont;
          FONT *capitals;
          FONT *fontcopy;
          ...
          /* Create a font of only capital letters */
          capitals = extract_font_range(myfont, 'A', 'Z');

          /* Create a copy of the font */
          fontcopy = extract_font_range(myfont, -1, -1);
          ...
          destroy_font(capitals);
          destroy_font(fontcopy);

     Returns a pointer to the new font or NULL on error.  Remember that
     you are responsible for destroying the font when you are finished
     with it to avoid memory leaks.

See also:
*Note get_font_range_begin::.
*Note get_font_range_end::.
*Note merge_fonts::.
*Note transpose_font::.
*Note exfont::.
*Note FONT::.


File: allegro.info,  Node: transpose_font,  Next: merge_fonts,  Prev: extract_font_range,  Up: Fonts

1.18.14 transpose_font
----------------------

int transpose_font(FONT *f, int drange)
     This function transposes all characters in a font, effectively
     remapping the font.  Example:

          FONT *myfont;
          FONT *capitals;
          ...
          /* Create a font of only capital letters */
          capitals = extract_font_range(myfont, 'A', 'Z');

          /* Now transpose the characters in the font so that they will be used */
          /*  for the lower case letters a-z */
          transpose_font(capitals, 'a'-'A');
          textout_ex(screen, capitals, "allcaps",
                     100, 100, makecol(255,255,255), 0);

     Returns 0 on success, -1 on failure.

See also:
*Note get_font_range_begin::.
*Note get_font_range_end::.
*Note merge_fonts::.
*Note extract_font_range::.
*Note FONT::.


File: allegro.info,  Node: merge_fonts,  Next: load_dat_font,  Prev: transpose_font,  Up: Fonts

1.18.15 merge_fonts
-------------------

FONT *merge_fonts(FONT *f1, FONT *f2)
     This function merges the character ranges from two fonts and
     returns a new font containing all characters in the old fonts.  In
     general, you cannot merge fonts of different types (eg, TrueType
     fonts and bitmapped fonts), but as a special case, this function
     can promote a monochrome bitmapped font to a color font and merge
     those.  Example:

          FONT *myfont;
          FONT *myfancy_font;
          FONT *lower_range;
          FONT *upper_range;
          FONT *capitals;
          FONT *combined_font;
          FONT *tempfont;
          ...
          /* Create a font that contains the capitals from  */
          /* the fancy font but other characters from myfont */
          lower_range = extract_font_range(myfont, -1, 'A'-1);
          upper_range = extract_font_range(myfont, 'Z'+1, -1);
          capitals = extract_font_range(myfancy_font, 'A', 'Z');

          tempfont = merge_fonts(lower_range, capitals);
          combined_font = merge_fonts(tempfont, upper_range);

          /* Clean up temporary fonts */
          destroy_font(lower_range);
          destroy_font(upper_range);
          destroy_font(capitals);
          destroy_font(tempfont);

     Returns a pointer to the new font or NULL on error.  Remember that
     you are responsible for destroying the font when you are finished
     with it to avoid memory leaks.

See also:
*Note extract_font_range::.
*Note is_trans_font::.
*Note is_color_font::.
*Note is_mono_font::.
*Note exfont::.
*Note FONT::.


File: allegro.info,  Node: load_dat_font,  Next: load_bios_font,  Prev: merge_fonts,  Up: Fonts

1.18.16 load_dat_font
---------------------

FONT *load_dat_font(const char *filename, RGB *pal, void *param)
     Loads a FONT from an Allegro datafile.  You can set param parameter
     to point to an array that holds two strings that identify the font
     and the palette in the datafile by name.  The first string in this
     list is the name of the font.  You can pass NULL here to just load
     the first font found in the datafile.  The second string can be
     used to specify the name of the palette associated with the font.
     This is only returned if the pal parameter is not NULL. If you pass
     NULL for the name of the palette, the last palette found before the
     font was found is returned.  You can also pass NULL for param,
     which is treated as if you had passed NULL for both strings
     separately.  In this case, the function will simply load the first
     font it finds from the datafile and the palette that precedes it.

     For example, suppose you have a datafile named 'fonts.dat' with the
     following contents:

          FONT  FONT_1_DATA
          FONT  FONT_2_DATA
          FONT  FONT_3_DATA
          PAL   FONT_1_PALETTE
          PAL   FONT_2_PALETTE

     Then the following code will load FONT_1_DATA as a FONT and return
     FONT_1_PALETTE as the palette:

          FONT *f;
          PALETTE pal;
          char *names[] = { "FONT_1_DATA", "FONT_1_PALETTE" }

          f = load_dat_font("fonts.dat", pal, names);

     If instead you want to load the second font, FONT_2, from the
     datafile, you would use:

          FONT *f;
          PALETTE pal;
          char *names[] = { "FONT_2_DATA", "FONT_2_PALETTE" }

          f = load_dat_font("fonts.dat", pal, names);

     If you want to load the third font, but not bother with a palette,
     use:

          FONT *f;
          char *names[] = { "FONT_3_DATA", NULL }

          f = load_dat_font("fonts.dat", NULL, names);

     Returns a pointer to the font or NULL on error.  Remember that you
     are responsible for destroying the font when you are finished with
     it to avoid memory leaks.

See also:
*Note register_font_file_type::.
*Note load_font::.
*Note RGB::.
*Note FONT::.


File: allegro.info,  Node: load_bios_font,  Next: load_grx_font,  Prev: load_dat_font,  Up: Fonts

1.18.17 load_bios_font
----------------------

FONT *load_bios_font(const char *filename, RGB *pal, void *param)
     Loads a 8x8 or 8x16 BIOS format font.  You shouldn't normally call
     this routine directly.

     Returns a pointer to the font or NULL on error.  Remember that you
     are responsible for destroying the font when you are finished with
     it to avoid memory leaks.

See also:
*Note register_font_file_type::.
*Note load_font::.
*Note RGB::.
*Note FONT::.


File: allegro.info,  Node: load_grx_font,  Next: load_grx_or_bios_font,  Prev: load_bios_font,  Up: Fonts

1.18.18 load_grx_font
---------------------

FONT *load_grx_font(const char *filename, RGB *pal, void *param)
     Loads a GRX format font.  You shouldn't normally call this routine
     directly.

     Returns a pointer to the font or NULL on error.  Remember that you
     are responsible for destroying the font when you are finished with
     it to avoid memory leaks.

See also:
*Note register_font_file_type::.
*Note load_font::.
*Note RGB::.
*Note FONT::.


File: allegro.info,  Node: load_grx_or_bios_font,  Next: load_bitmap_font,  Prev: load_grx_font,  Up: Fonts

1.18.19 load_grx_or_bios_font
-----------------------------

FONT *load_grx_or_bios_font(const char *filename, RGB *pal, void *param)
     Loads either a BIOS or GRX format font.  You shouldn't normally
     call this routine directly.

     Returns a pointer to the font or NULL on error.  Remember that you
     are responsible for destroying the font when you are finished with
     it to avoid memory leaks.

See also:
*Note register_font_file_type::.
*Note load_font::.
*Note RGB::.
*Note FONT::.


File: allegro.info,  Node: load_bitmap_font,  Next: grab_font_from_bitmap,  Prev: load_grx_or_bios_font,  Up: Fonts

1.18.20 load_bitmap_font
------------------------

FONT *load_bitmap_font(const char *filename, RGB *pal, void *param)
     Tries to grab a font from a bitmap.  The bitmap can be in any
     format that load_bitmap understands.

     The size of each character is determined by the layout of the
     image, which should be a rectangular grid containing all the ASCII
     characters from space (32) up to the tilde (126).  The way the
     characters are separated depends on the color depth of the image
     file:

        * paletted (8 bit) image file Use color 0 for the transparent
          portions of the characters and fill the spaces between each
          letter with color 255.
        * High (15/16 bit) and true (24/32 bit) color image file Use
          bright pink (maximum red and blue, zero green) for the
          transparent portions of the characters and fill the spaces
          between each letter with bright yellow (maximum red and green,
          zero blue).

     Note that in each horizontal row the bounding boxes around the
     characters should align and have the same height.

     Probably the easiest way to get to grips with how this works is to
     load up the 'demo.dat' file and export the TITLE_FONT into a PCX
     file.  Have a look at the resulting picture in your paint program:
     that is the format a font should be in.

     Take care with high and true color fonts: Allegro will convert
     these to the current color depth when you load the font.  If you
     try to use a font on a bitmap with a different color depth Allegro
     will do color conversions on the fly, which will be rather slow.
     For optimal performance you should set the color depth to the color
     depth you want to use before loading any fonts.

     Returns a pointer to the font or NULL on error.  Remember that you
     are responsible for destroying the font when you are finished with
     it to avoid memory leaks.

See also:
*Note register_font_file_type::.
*Note load_font::.
*Note load_bitmap::.
*Note set_color_depth::.
*Note grab_font_from_bitmap::.
*Note RGB::.
*Note FONT::.


File: allegro.info,  Node: grab_font_from_bitmap,  Next: load_txt_font,  Prev: load_bitmap_font,  Up: Fonts

1.18.21 grab_font_from_bitmap
-----------------------------

FONT *grab_font_from_bitmap(BITMAP *bmp)
     This function is the work-horse of load_bitmap_font, and can be
     used to grab a font from a bitmap in memory.  You can use this if
     you want to generate or modify a font at runtime.  The bitmap
     should follow the layout described for load_bitmap_font.

     Returns a pointer to the font or NULL on error.  Remember that you
     are responsible for destroying the font when you are finished with
     it to avoid memory leaks.

See also:
*Note load_bitmap_font::.
*Note BITMAP::.
*Note FONT::.


File: allegro.info,  Node: load_txt_font,  Next: font,  Prev: grab_font_from_bitmap,  Up: Fonts

1.18.22 load_txt_font
---------------------

FONT *load_txt_font(const char *filename, RGB *pal, void *param)
     This function can be used to load scripted fonts.  The script file
     contains a number of lines in the format "filename start end",
     which specify the source file for that range of characters, the
     Unicode value of the first character in the range, and the end
     character in the range (optional, if left out, the entire input
     file will be grabbed).  If the filename is replaced by a hyphen,
     more characters will be grabbed from the previous input file.  For
     example, the script:

          ascii.fnt 0x20 0x7F
          - 0xA0 0xFF
          dingbats.fnt 0x1000

     would import the first 96 characters from ascii.fnt as the range
     0x20-0x7F, the next 96 characters from ascii.fnt as the range
     0xA0-0xFF, and the entire contents of dingbats.fnt starting at
     Unicode position 0x1000.

     Returns a pointer to the font or NULL on error.  Remember that you
     are responsible for destroying the font when you are finished with
     it to avoid memory leaks.

See also:
*Note register_font_file_type::.
*Note load_font::.
*Note RGB::.
*Note FONT::.


File: allegro.info,  Node: Text,  Next: Polygon,  Prev: Fonts,  Up: API

1.19 Text output
================

Allegro provides text output routines that work with both monochrome and
color fonts, which can contain any number of Unicode character ranges.
The grabber program can create fonts from sets of characters drawn in a
bitmap file (see grabber.txt for more information), and can also import
GRX or BIOS format font files.  The font structure contains a number of
hooks that can be used to extend it with your own custom drawing code:
see the definition in allegro/text.h for details.

* Menu:

* font::
* allegro_404_char::
* text_length::
* text_height::
* textout_ex::
* textout_centre_ex::
* textout_right_ex::
* textout_justify_ex::
* textprintf_ex::
* textprintf_centre_ex::
* textprintf_right_ex::
* textprintf_justify_ex::


File: allegro.info,  Node: font,  Next: allegro_404_char,  Prev: load_txt_font,  Up: Text

1.19.1 font
-----------

extern FONT *font;
     A simple 8x8 fixed size font (the mode 13h BIOS default).  If you
     want to alter the font used by the GUI routines, change this to
     point to one of your own fonts.  This font contains the standard
     ASCII (U+20 to U+7F), Latin-1 (U+A1 to U+FF), and Latin Extended-A
     (U+0100 to U+017F) character ranges.

See also:
*Note textout_ex::.
*Note textprintf_ex::.
*Note Available Allegro examples: Available.
*Note FONT::.


File: allegro.info,  Node: allegro_404_char,  Next: text_length,  Prev: font,  Up: Text

1.19.2 allegro_404_char
-----------------------

extern int allegro_404_char;
     When Allegro cannot find a glyph it needs in a font, it will
     instead output the character given in allegro_404_char.  By
     default, this is set to the caret symbol, '^', but you can change
     this global to use any other character instead.  Example:

          /* Show unknown glyphs with an asterisk. */
          allegro_404_char = '*';

See also:
*Note font::.


File: allegro.info,  Node: text_length,  Next: text_height,  Prev: allegro_404_char,  Up: Text

1.19.3 text_length
------------------

int text_length(const FONT *f, const char *str);
     Returns the length (in pixels) of a string in the specified font.
     Example:

          int width = text_length(font, "I love spam");
          ...
          bmp = create_bitmap(width, height);

See also:
*Note text_height::.
*Note ex12bit::.
*Note exmidi::.
*Note expat::.
*Note exunicod::.
*Note FONT::.


File: allegro.info,  Node: text_height,  Next: textout_ex,  Prev: text_length,  Up: Text

1.19.4 text_height
------------------

int text_height(const FONT *f)
     Returns the height (in pixels) of the specified font.  Example:

          int height = text_height(font);
          ...
          bmp = create_bitmap(width, height);

See also:
*Note text_length::.
*Note ex12bit::.
*Note exmidi::.
*Note expackf::.
*Note expat::.
*Note exsprite::.
*Note exsyscur::.
*Note exunicod::.
*Note FONT::.


File: allegro.info,  Node: textout_ex,  Next: textout_centre_ex,  Prev: text_height,  Up: Text

1.19.5 textout_ex
-----------------

void textout_ex(BITMAP *bmp, const FONT *f, const char *s, int x, int y, int color, int bg);
     Writes the string 's' onto the bitmap at position x, y, using the
     specified font, foreground color and background color.  If the
     background color is -1, then the text is written transparently.  If
     the foreground color is -1 and a color font is in use, it will be
     drawn using the colors from the original font bitmap (the one you
     imported into the grabber program), which allows multicolored text
     output.  For high and true color fonts, the foreground color is
     ignored and always treated as -1.  Example:

          /* Show the program's version in blue letters. */
          textout_ex(screen, font, "v4.2.0-beta2", 10, 10,
                     makecol(0, 0, 255), -1);

See also:
*Note font::.
*Note textout_centre_ex::.
*Note textout_right_ex::.
*Note textout_justify_ex::.
*Note textprintf_ex::.
*Note text_height::.
*Note text_length::.
*Note Available Allegro examples: Available.
*Note BITMAP::.
*Note FONT::.


File: allegro.info,  Node: textout_centre_ex,  Next: textout_right_ex,  Prev: textout_ex,  Up: Text

1.19.6 textout_centre_ex
------------------------

void textout_centre_ex(BITMAP *bmp, const FONT *f, const char *s, int x, y, int color, int bg);
     Like textout_ex(), but interprets the x coordinate as the centre
     rather than the left edge of the string.  Example:

          /* Important texts go in the middle. */
          width = text_length("GAME OVER");
          textout_centre_ex(screen, font, "GAME OVER",
                            SCREEN_W / 2, SCREEN_H / 2,
                            makecol(255, 0, 0), makecol(0, 0, 0));

See also:
*Note textout_ex::.
*Note textprintf_centre_ex::.
*Note Available Allegro examples: Available.
*Note BITMAP::.
*Note FONT::.


File: allegro.info,  Node: textout_right_ex,  Next: textout_justify_ex,  Prev: textout_centre_ex,  Up: Text

1.19.7 textout_right_ex
-----------------------

void textout_right_ex(BITMAP *bmp, const FONT *f, const char *s, int x, int y, int color, int bg);
     Like textout_ex(), but interprets the x coordinate as the right
     rather than the left edge of the string.  Example:

          textout_right_ex(screen, font, "Look at this color!",
                           SCREEN_W - 10, 10, my_yellow, -1);

See also:
*Note textout_ex::.
*Note textprintf_right_ex::.
*Note BITMAP::.
*Note FONT::.


File: allegro.info,  Node: textout_justify_ex,  Next: textprintf_ex,  Prev: textout_right_ex,  Up: Text

1.19.8 textout_justify_ex
-------------------------

void textout_justify_ex(BITMAP *bmp, const FONT *f, const char *s, int x1, int x2, int y, int diff, int color, int bg);
     Draws justified text within the region x1-x2.  If the amount of
     spare space is greater than the diff value, it will give up and
     draw regular left justified text instead.  Example:

          char *lines[] = {"Draws justified text",
                           "within the specified",
                           "x2-x1 area. But not",
                           "T H I S !", NULL};
          /* Show the justification marker. */
          vline(screen, 200, 0, SCREEN_H-1, makecol(0, 0, 0));
          /* Draw all the lines until we reach a NULL entry. */
          for (num = 0, y = 0; lines[num]; num++, y += text_height(font))
             textout_justify_ex(screen, font, lines[num], 0, 200,
                                y, 80, makecol(0, 0, 0),
                                makecol(255, 255, 255));

See also:
*Note textout_ex::.
*Note textprintf_justify_ex::.
*Note BITMAP::.
*Note FONT::.


File: allegro.info,  Node: textprintf_ex,  Next: textprintf_centre_ex,  Prev: textout_justify_ex,  Up: Text

1.19.9 textprintf_ex
--------------------

void textprintf_ex(BITMAP *bmp, const FONT *f, int x, int y, int color, int bg, const char *fmt, ...);
     Formatted text output, using a printf() style format string.  Due
     to an internal limitation, this function can't be used for
     extremely long texts.  If you happen to reach this limit, you can
     work around it by using uszprintf() and textout_ex(), which don't
     have any.  Example:

          int player_score;
          ...
          textprintf_ex(screen, font, 10, 10, makecol(255, 100, 200),
                        -1, "Score: %d", player_score);

See also:
*Note font::.
*Note textout_ex::.
*Note textprintf_centre_ex::.
*Note textprintf_right_ex::.
*Note textprintf_justify_ex::.
*Note text_height::.
*Note text_length::.
*Note uszprintf::.
*Note Available Allegro examples: Available.
*Note BITMAP::.
*Note FONT::.


File: allegro.info,  Node: textprintf_centre_ex,  Next: textprintf_right_ex,  Prev: textprintf_ex,  Up: Text

1.19.10 textprintf_centre_ex
----------------------------

void textprintf_centre_ex(BITMAP *bmp, const FONT *f, int x, int y, int color, int bg, const char *fmt, ...);
     Like textprintf_ex(), but interprets the x coordinate as the centre
     rather than the left edge of the string.  This function shares the
     text length limitation of textprintf_ex().  Example:

          textprintf_centre_ex(screen, font, SCREEN_W / 2, 120,
                               makecol(0, 100, 243), -1,
                               "Your best score so far was %d!",
                               total_max_points);

See also:
*Note textprintf_ex::.
*Note textout_centre_ex::.
*Note Available Allegro examples: Available.
*Note BITMAP::.
*Note FONT::.


File: allegro.info,  Node: textprintf_right_ex,  Next: textprintf_justify_ex,  Prev: textprintf_centre_ex,  Up: Text

1.19.11 textprintf_right_ex
---------------------------

void textprintf_right_ex(BITMAP *bmp, const FONT *f, int x, y, color, bg, const char *fmt, ...);
     Like textprintf_ex(), but interprets the x coordinate as the right
     rather than the left edge of the string.  This function shares the
     text length limitation of textprintf_ex().  Example:

          textprintf_right_ex(screen, font, SCREEN_W - 10, 10,
                              makecol(200, 200, 20), -1,
                              "%d bullets left", player_ammo);

See also:
*Note textprintf_ex::.
*Note textout_right_ex::.
*Note exmouse::.
*Note BITMAP::.
*Note FONT::.


File: allegro.info,  Node: textprintf_justify_ex,  Next: POLYTYPE_FLAT,  Prev: textprintf_right_ex,  Up: Text

1.19.12 textprintf_justify_ex
-----------------------------

void textprintf_justify_ex(BITMAP *bmp, const FONT *f, int x1, x2, y, diff, color, bg, const char *fmt, ...);
     Like textout_justify_ex(), but using a printf() style format
     string.  This function shares the text length limitation of
     textprintf_ex().  Example:

          char *lines[] = {"Line %02d: Draws justified text",
                           "Line %02d: within the specified",
                           "Line %02d: x2-x1 area. But not",
                           "Line %02d: T H I S !", NULL};
          /* Show the justification marker. */
          vline(screen, 300, 0, SCREEN_H-1, makecol(0, 0, 0));
          /* Draw all the lines until we reach a NULL entry. */
          for (num = 0, y = 0; lines[num]; num++, y += text_height(font))
             textprintf_justify_ex(screen, font, 0, 300, y, 180,
                                   makecol(0, 0, 0), makecol(255, 255, 255),
                                   lines[num], num);

See also:
*Note textprintf_ex::.
*Note textout_justify_ex::.
*Note BITMAP::.
*Note FONT::.


File: allegro.info,  Node: Polygon,  Next: Transparency,  Prev: Text,  Up: API

1.20 Polygon rendering
======================

All the 3d functions that accept a 'type' parameter are asking for a
polygon rendering mode, which can be any of the following POLYTYPE_*
values.  If the CPU_MMX flag of the cpu_capabilities global variable is
set, the GRGB and truecolor *LIT routines will be optimised using MMX
instructions.  If the CPU_3DNOW flag is set, the truecolor PTEX*LIT
routines will take advantage of the 3DNow!  CPU extensions.

Using MMX for *LIT routines has a side effect: normally (without MMX),
these routines use the blender functions used also for other lighting
functions, set with set_trans_blender() or set_blender_mode().  The MMX
versions only use the RGB value passed to set_trans_blender() and do the
linear interpolation themselves.  Therefore a new set of blender
functions passed to set_blender_mode() is ignored.

* Menu:

* POLYTYPE_FLAT::
* POLYTYPE_GCOL::
* POLYTYPE_GRGB::
* POLYTYPE_ATEX::
* POLYTYPE_PTEX::
* POLYTYPE_ATEX_MASK::
* POLYTYPE_ATEX_LIT::
* POLYTYPE_ATEX_MASK_LIT::
* POLYTYPE_ATEX_TRANS::
* POLYTYPE_ATEX_MASK_TRANS::
* polygon3d::
* triangle3d::
* quad3d::
* clip3d_f::
* clip3d::
* Zbuffered rendering::
* create_zbuffer::
* create_sub_zbuffer::
* set_zbuffer::
* clear_zbuffer::
* destroy_zbuffer::
* Scene rendering::
* create_scene::
* clear_scene::
* destroy_scene::
* scene_polygon3d::
* render_scene::
* scene_gap::


File: allegro.info,  Node: POLYTYPE_FLAT,  Next: POLYTYPE_GCOL,  Prev: textprintf_justify_ex,  Up: Polygon

1.20.1 POLYTYPE_FLAT
--------------------

#define POLYTYPE_FLAT
     A simple flat shaded polygon, taking the color from the 'c' value
     of the first vertex.  This polygon type is affected by the
     drawing_mode() function, so it can be used to render XOR or
     translucent polygons.

See also:
*Note Polygon rendering: Polygon.
*Note polygon3d::.
*Note drawing_mode::.
*Note ex3d::.
*Note excamera::.


File: allegro.info,  Node: POLYTYPE_GCOL,  Next: POLYTYPE_GRGB,  Prev: POLYTYPE_FLAT,  Up: Polygon

1.20.2 POLYTYPE_GCOL
--------------------

#define POLYTYPE_GCOL
     A single-color gouraud shaded polygon.  The colors for each vertex
     are taken from the 'c' value, and interpolated across the polygon.
     This is very fast, but will only work in 256-color modes if your
     palette contains a smooth gradient between the colors.  In
     truecolor modes it interprets the color as a packed, display-format
     value as produced by the makecol() function.

See also:
*Note Polygon rendering: Polygon.
*Note polygon3d::.
*Note makecol::.
*Note ex3d::.
*Note exscn3d::.
*Note exzbuf::.


File: allegro.info,  Node: POLYTYPE_GRGB,  Next: POLYTYPE_ATEX,  Prev: POLYTYPE_GCOL,  Up: Polygon

1.20.3 POLYTYPE_GRGB
--------------------

#define POLYTYPE_GRGB
     A gouraud shaded polygon which interpolates RGB triplets rather
     than a single color.  In 256-color modes this uses the global
     rgb_map table to convert the result to an 8-bit paletted color, so
     it must only be used after you have set up the RGB mapping table!
     The colors for each vertex are taken from the 'c' value, which is
     interpreted as a 24-bit RGB triplet (0xFF0000 is red, 0x00FF00 is
     green, and 0x0000FF is blue).

See also:
*Note Polygon rendering: Polygon.
*Note polygon3d::.
*Note rgb_map::.
*Note ex3d::.


File: allegro.info,  Node: POLYTYPE_ATEX,  Next: POLYTYPE_PTEX,  Prev: POLYTYPE_GRGB,  Up: Polygon

1.20.4 POLYTYPE_ATEX
--------------------

#define POLYTYPE_ATEX
     An affine texture mapped polygon.  This stretches the texture
     across the polygon with a simple 2d linear interpolation, which is
     fast but not mathematically correct.  It can look OK if the polygon
     is fairly small or flat-on to the camera, but because it doesn't
     deal with perspective foreshortening, it can produce strange
     warping artifacts.  To see what this means, run Allegro's test
     program and see what happens to the polygon3d() test when you zoom
     in very close to the cube.

See also:
*Note Polygon rendering: Polygon.
*Note polygon3d::.
*Note ex3d::.


File: allegro.info,  Node: POLYTYPE_PTEX,  Next: POLYTYPE_ATEX_MASK,  Prev: POLYTYPE_ATEX,  Up: Polygon

1.20.5 POLYTYPE_PTEX
--------------------

#define POLYTYPE_PTEX
     A perspective-correct texture mapped polygon.  This uses the 'z'
     value from the vertex structure as well as the u/v coordinates, so
     textures are displayed correctly regardless of the angle they are
     viewed from.  Because it involves division calculations in the
     inner texture mapping loop, this mode is a lot slower than
     POLYTYPE_ATEX, and it uses floating point so it will be very slow
     on anything less than a Pentium (even with an FPU, a 486 can't
     overlap floating point division with other integer operations like
     the Pentium can).

See also:
*Note Polygon rendering: Polygon.
*Note polygon3d::.
*Note POLYTYPE_ATEX::.
*Note ex3d::.


File: allegro.info,  Node: POLYTYPE_ATEX_MASK,  Next: POLYTYPE_ATEX_LIT,  Prev: POLYTYPE_PTEX,  Up: Polygon

1.20.6 POLYTYPE_ATEX_MASK
-------------------------

#define POLYTYPE_ATEX_MASK
#define POLYTYPE_PTEX_MASK
     Like POLYTYPE_ATEX and POLYTYPE_PTEX, but zero texture map pixels
     are skipped, allowing parts of the texture map to be transparent.

See also:
*Note Polygon rendering: Polygon.
*Note polygon3d::.
*Note POLYTYPE_ATEX::.
*Note POLYTYPE_PTEX::.
*Note ex3d::.


File: allegro.info,  Node: POLYTYPE_ATEX_LIT,  Next: POLYTYPE_ATEX_MASK_LIT,  Prev: POLYTYPE_ATEX_MASK,  Up: Polygon

1.20.7 POLYTYPE_ATEX_LIT
------------------------

#define POLYTYPE_ATEX_LIT
#define POLYTYPE_PTEX_LIT
     Like POLYTYPE_ATEX and POLYTYPE_PTEX, but the global color_map
     table (for 256-color modes) or blender function (for non-MMX
     truecolor modes) is used to blend the texture with a light level
     taken from the 'c' value in the vertex structure.  This must only
     be used after you have set up the color mapping table or blender
     functions!

See also:
*Note Polygon rendering: Polygon.
*Note polygon3d::.
*Note POLYTYPE_ATEX::.
*Note POLYTYPE_PTEX::.
*Note color_map::.
*Note Truecolor transparency::.
*Note ex3d::.


File: allegro.info,  Node: POLYTYPE_ATEX_MASK_LIT,  Next: POLYTYPE_ATEX_TRANS,  Prev: POLYTYPE_ATEX_LIT,  Up: Polygon

1.20.8 POLYTYPE_ATEX_MASK_LIT
-----------------------------

#define POLYTYPE_ATEX_MASK_LIT
#define POLYTYPE_PTEX_MASK_LIT
     Like POLYTYPE_ATEX_LIT and POLYTYPE_PTEX_LIT, but zero texture map
     pixels are skipped, allowing parts of the texture map to be
     transparent.

See also:
*Note Polygon rendering: Polygon.
*Note polygon3d::.
*Note POLYTYPE_ATEX_LIT::.
*Note POLYTYPE_PTEX_LIT: POLYTYPE_ATEX_LIT.
*Note ex3d::.


File: allegro.info,  Node: POLYTYPE_ATEX_TRANS,  Next: POLYTYPE_ATEX_MASK_TRANS,  Prev: POLYTYPE_ATEX_MASK_LIT,  Up: Polygon

1.20.9 POLYTYPE_ATEX_TRANS
--------------------------

#define POLYTYPE_ATEX_TRANS
#define POLYTYPE_PTEX_TRANS
     Render translucent textures.  All the general rules for drawing
     translucent things apply.  However, these modes have a major
     limitation: they only work with memory bitmaps or linear frame
     buffers (not with banked frame buffers).  Don't even try, they do
     not check and your program will die horribly (or at least draw
     wrong things).

See also:
*Note Polygon rendering: Polygon.
*Note polygon3d::.
*Note ex3d::.


File: allegro.info,  Node: POLYTYPE_ATEX_MASK_TRANS,  Next: polygon3d,  Prev: POLYTYPE_ATEX_TRANS,  Up: Polygon

1.20.10 POLYTYPE_ATEX_MASK_TRANS
--------------------------------

#define POLYTYPE_ATEX_MASK_TRANS
#define POLYTYPE_PTEX_MASK_TRANS
     Like POLYTYPE_ATEX_TRANS and POLYTYPE_PTEX_TRANS, but zero texture
     map pixels are skipped.

See also:
*Note Polygon rendering: Polygon.
*Note polygon3d::.
*Note ex3d::.


File: allegro.info,  Node: polygon3d,  Next: triangle3d,  Prev: POLYTYPE_ATEX_MASK_TRANS,  Up: Polygon

1.20.11 polygon3d
-----------------

void polygon3d(BITMAP *bmp, int type, BITMAP *texture, int vc, V3D *vtx[]);
void polygon3d_f(BITMAP *bmp, int type, BITMAP *texture, int vc, V3D_f *vtx[]);
     Draw 3d polygons onto the specified bitmap, using the specified
     rendering mode.  Unlike the regular polygon() function, these
     routines don't support concave or self-intersecting shapes, and
     they can't draw onto mode-X screen bitmaps (if you want to write 3d
     code in mode-X, draw onto a memory bitmap and then blit to the
     screen).  The width and height of the texture bitmap must be powers
     of two, but can be different, eg.  a 64x16 texture is fine, but a
     17x3 one is not.  The vertex count parameter (vc) should be
     followed by an array containing the appropriate number of pointers
     to vertex structures: polygon3d() uses the fixed point V3D
     structure, while polygon3d_f() uses the floating point V3D_f
     structure.  These are defined as:

          typedef struct V3D
          {
             fixed x, y, z;       - position
             fixed u, v;          - texture map coordinates
             int c;               - color
          } V3D;

          typedef struct V3D_f
          {
             float x, y, z;       - position
             float u, v;          - texture map coordinates
             int c;               - color
          } V3D_f;

     How the vertex data is used depends on the rendering mode:

     The 'x' and 'y' values specify the position of the vertex in 2d
     screen coordinates.

     The 'z' value is only required when doing perspective correct
     texture mapping, and specifies the depth of the point in 3d world
     coordinates.

     The 'u' and 'v' coordinates are only required when doing texture
     mapping, and specify a point on the texture plane to be mapped on
     to this vertex.  The texture plane is an infinite plane with the
     texture bitmap tiled across it.  Each vertex in the polygon has a
     corresponding vertex on the texture plane, and the image of the
     resulting polygon in the texture plane will be mapped on to the
     polygon on the screen.

     We refer to pixels in the texture plane as texels.  Each texel is a
     block, not just a point, and whole numbers for u and v refer to the
     top-left corner of a texel.  This has a few implications.  If you
     want to draw a rectangular polygon and map a texture sized 32x32 on
     to it, you would use the texture coordinates (0,0), (0,32), (32,32)
     and (32,0), assuming the vertices are specified in anticlockwise
     order.  The texture will then be mapped perfectly on to the
     polygon.  However, note that when we set u=32, the last column of
     texels seen on the screen is the one at u=31, and the same goes for
     v.  This is because the coordinates refer to the top-left corner of
     the texels.  In effect, texture coordinates at the right and bottom
     on the texture plane are exclusive.

     There is another interesting point here.  If you have two polygons
     side by side sharing two vertices (like the two parts of folded
     piece of cardboard), and you want to map a texture across them
     seamlessly, the values of u and v on the vertices at the join will
     be the same for both polygons.  For example, if they are both
     rectangular, one polygon may use (0,0), (0,32), (32,32) and (32,0),
     and the other may use (32,0), (32,32), (64,32), (64,0).  This would
     create a seamless join.

     Of course you can specify fractional numbers for u and v to
     indicate a point part-way across a texel.  In addition, since the
     texture plane is infinite, you can specify larger values than the
     size of the texture.  This can be used to tile the texture several
     times across the polygon.

     The 'c' value specifies the vertex color, and is interpreted
     differently by various rendering modes.  Read the beginning of
     chapter "Polygon rendering" for a list of rendering types you can
     use with this function.

See also:
*Note triangle3d::.
*Note quad3d::.
*Note polygon::.
*Note clip3d::.
*Note cpu_capabilities::.
*Note excamera::.
*Note BITMAP::.
*Note V3D::.
*Note V3D_f::.


File: allegro.info,  Node: triangle3d,  Next: quad3d,  Prev: polygon3d,  Up: Polygon

1.20.12 triangle3d
------------------

void triangle3d(BITMAP *bmp, int type, BITMAP *tex, V3D *v1, *v2, *v3);
void triangle3d_f(BITMAP *bmp, int type, BITMAP *tex, V3D_f *v1, *v2, *v3);
     Draw 3d triangles, using either fixed or floating point vertex
     structures.  Unlike quad3d[_f](), triangle3d[_f]() functions are
     not wrappers of polygon3d[_f]().  The triangle3d[_f]() functions
     use their own routines taking into account the constantness of the
     gradients.  Therefore triangle3d[_f](bmp, type, tex, v1, v2, v3) is
     faster than polygon3d[_f](bmp, type, tex, 3, v[]).

     Read the beginning of chapter "Polygon rendering" for a list of
     rendering types you can use with this function.

See also:
*Note polygon3d::.
*Note quad3d::.
*Note triangle::.
*Note Polygon rendering: Polygon.
*Note BITMAP::.
*Note V3D::.
*Note V3D_f::.


File: allegro.info,  Node: quad3d,  Next: clip3d_f,  Prev: triangle3d,  Up: Polygon

1.20.13 quad3d
--------------

void quad3d(BITMAP *bmp, int type, BITMAP *tex, V3D *v1, *v2, *v3, *v4);
void quad3d_f(BITMAP *bmp, int type, BITMAP *tex, V3D_f *v1, *v2, *v3, *v4);
     Draw 3d quads, using either fixed or floating point vertex
     structures.  These are equivalent to calling polygon3d(bmp, type,
     tex, 4, v[]) or polygon3d_f(bmp, type, tex, 4, v[]).

     Read the beginning of chapter "Polygon rendering" for a list of
     rendering types you can use with this function.

See also:
*Note polygon3d::.
*Note triangle3d::.
*Note Polygon rendering: Polygon.
*Note ex3d::.
*Note BITMAP::.
*Note V3D::.
*Note V3D_f::.


File: allegro.info,  Node: clip3d_f,  Next: clip3d,  Prev: quad3d,  Up: Polygon

1.20.14 clip3d_f
----------------

int clip3d_f(int type, float min_z, float max_z, int vc, const V3D_f *vtx[], V3D_f *vout[], V3D_f *vtmp[], int out[]);
     Clips the polygon given in 'vtx'.  The number of vertices is 'vc',
     the result goes in 'vout', and 'vtmp' and 'out' are needed for
     internal purposes.  The pointers in 'vtx', 'vout' and 'vtmp' must
     point to valid V3D_f structures.

     As additional vertices may appear in the process of clipping, so
     the size of 'vout', 'vtmp' and 'out' should be at least vc * (1.5 ^
     n), where 'n' is the number of clipping planes (5 or 6), and '^'
     denotes "to the power of".

     The frustum (viewing volume) is defined by -z<x<z, -z<y<z,
     0<min_z<z<max_z.  If max_z<=min_z, the z<max_z clipping is not
     done.  As you can see, clipping is done in the camera space, with
     perspective in mind, so this routine should be called after you
     apply the camera matrix, but before the perspective projection.
     The routine will correctly interpolate u, v, and c in the vertex
     structure.  However, no provision is made for high/truecolor GCOL.

     Returns the number of vertices after clipping is done.

See also:
*Note polygon3d::.
*Note clip3d::.
*Note excamera::.
*Note exscn3d::.
*Note V3D_f::.


File: allegro.info,  Node: clip3d,  Next: Zbuffered rendering,  Prev: clip3d_f,  Up: Polygon

1.20.15 clip3d
--------------

int clip3d(int type, fixed min_z, fixed max_z, int vc, const V3D *vtx[], V3D *vout[], V3D *vtmp[], int out[]);
     Fixed point version of clip3d_f().  This function should be used
     with caution, due to the limited precision of fixed point
     arithmetic and high chance of rounding errors: the floating point
     code is better for most situations.

     Returns the number of vertices after clipping is done.

See also:
*Note polygon3d::.
*Note clip3d_f::.
*Note fixed::.
*Note V3D::.


File: allegro.info,  Node: Zbuffered rendering,  Next: create_zbuffer,  Prev: clip3d,  Up: Polygon

1.20.16 Zbuffered rendering
---------------------------

A Z-buffer stores the depth of each pixel that is drawn on a viewport.
When a 3D object is rendered, the depth of each of its pixels is
compared against the value stored into the Z-buffer: if the pixel is
closer it is drawn, otherwise it is skipped.

No polygon sorting is needed.  However, backface culling should be done
because it prevents many invisible polygons being compared against the
Z-buffer.  Z-buffered rendering is the only algorithm supported by
Allegro that directly solves penetrating shapes (see example exzbuf.c,
for instance).  The price to pay is more complex (and slower) routines.

Z-buffered polygons are designed as an extension of the normal
POLYTYPE_* rendering styles.  Just OR the POLYTYPE with the value
POLYTYPE_ZBUF, and the normal polygon3d(), polygon3d_f(), quad3d(), etc.
functions will render z-buffered polygons.

Example:

     polygon3d(bmp, POLYTYPE_ATEX | POLYTYPE_ZBUF, tex, vc, vtx);

Of course, the z coordinates have to be valid regardless of rendering
style.

A Z-buffered rendering procedure looks like a double-buffered rendering
procedure.  You should follow four steps: create a Z-buffer at the
beginning of the program and make the library use it by calling
set_zbuffer().  Then, for each frame, clear the Z-buffer and draw
polygons with POLYTYPE_* | POLYTYPE_ZBUF and finally destroy the
Z-buffer when leaving the program.

Notes on Z-buffered renderers:

   * Unlike the normal POLYTYPE_FLAT renderers, the Z-buffered ones
     don't use the hline() routine.  Therefore DRAW_MODE has no effect.
   * The *LIT* routines work the traditional way - through the set of
     blender routines.
   * All the Z-buffered routines are much slower than their normal
     counterparts (they all use the FPU to interpolate and test 1/z
     values).


File: allegro.info,  Node: create_zbuffer,  Next: create_sub_zbuffer,  Prev: Zbuffered rendering,  Up: Polygon

1.20.17 create_zbuffer
----------------------

ZBUFFER *create_zbuffer(BITMAP *bmp);
     Creates a Z-buffer using the size of the BITMAP you are planning to
     draw on.  Several Z-buffers can be defined but only one can be used
     at the same time, so you must call set_zbuffer() to make this
     Z-buffer active.

     Returns the pointer to the ZBUFFER or NULL if there was an error.
     Remember to destroy the ZBUFFER once you are done with it, to avoid
     having memory leaks.

See also:
*Note create_sub_zbuffer::.
*Note set_zbuffer::.
*Note clear_zbuffer::.
*Note destroy_zbuffer::.
*Note exzbuf::.
*Note BITMAP::.
*Note ZBUFFER::.


File: allegro.info,  Node: create_sub_zbuffer,  Next: set_zbuffer,  Prev: create_zbuffer,  Up: Polygon

1.20.18 create_sub_zbuffer
--------------------------

ZBUFFER *create_sub_zbuffer(ZBUFFER *parent, int x, int y, int width, int height);
     Creates a sub-z-buffer, ie.  a z-buffer sharing drawing memory with
     a pre-existing z-buffer, but possibly with a different size.  The
     same rules as for sub-bitmaps apply: the sub-z-buffer width and
     height can extend beyond the right and bottom edges of the parent
     (they will be clipped), but the origin point must lie within the
     parent region.

     When drawing z-buffered to a bitmap, the top left corner of the
     bitmap is always mapped to the top left corner of the current
     z-buffer.  So this function is primarily useful if you want to draw
     to a sub-bitmap and use the corresponding sub-area of the z-buffer.
     In other cases, eg.  if you just want to draw to a sub-bitmap of
     screen (and not to other parts of screen), then you would usually
     want to create a normal z-buffer (not sub-z-buffer) the size of the
     visible screen.  You don't need to first create a z-buffer the size
     of the virtual screen and then a sub-z-buffer of that.

     Returns the pointer to the sub ZBUFFER or NULL if there was an
     error.  Remember to destroy the ZBUFFER once you are done with it,
     to avoid having memory leaks.

See also:
*Note create_zbuffer::.
*Note create_sub_bitmap::.
*Note destroy_zbuffer::.
*Note ZBUFFER::.


File: allegro.info,  Node: set_zbuffer,  Next: clear_zbuffer,  Prev: create_sub_zbuffer,  Up: Polygon

1.20.19 set_zbuffer
-------------------

void set_zbuffer(ZBUFFER *zbuf);
     Makes the given Z-buffer be the active one.  This should have been
     previously created with create_zbuffer().

See also:
*Note create_zbuffer::.
*Note clear_zbuffer::.
*Note destroy_zbuffer::.
*Note exzbuf::.
*Note ZBUFFER::.


File: allegro.info,  Node: clear_zbuffer,  Next: destroy_zbuffer,  Prev: set_zbuffer,  Up: Polygon

1.20.20 clear_zbuffer
---------------------

void clear_zbuffer(ZBUFFER *zbuf, float z);
     Writes z into the given Z-buffer (0 means far away).  This function
     should be used to initialize the Z-buffer before each frame.
     Actually, low-level routines compare depth of the current pixel
     with 1/z: for example, if you want to clip polygons farther than
     10, you must call clear_zbuffer(zbuf, 0.1).

See also:
*Note create_zbuffer::.
*Note set_zbuffer::.
*Note destroy_zbuffer::.
*Note exzbuf::.
*Note ZBUFFER::.


File: allegro.info,  Node: destroy_zbuffer,  Next: Scene rendering,  Prev: clear_zbuffer,  Up: Polygon

1.20.21 destroy_zbuffer
-----------------------

void destroy_zbuffer(ZBUFFER *zbuf);
     Destroys the Z-buffer when you are finished with it.  Use this to
     avoid memory leaks in your program.

See also:
*Note create_zbuffer::.
*Note set_zbuffer::.
*Note clear_zbuffer::.
*Note exzbuf::.
*Note ZBUFFER::.


File: allegro.info,  Node: Scene rendering,  Next: create_scene,  Prev: destroy_zbuffer,  Up: Polygon

1.20.22 Scene rendering
-----------------------

Allegro provides two simple approaches to remove hidden surfaces:

   * Z-buffering - (see above)
   * Scan-line algorithms - along each scanline on your screen, you keep
     track of what polygons you are "in" and which is the nearest.  This
     status changes only where the scanline crosses some polygon edge.
     So you have to juggle an edge list and a polygon list.  And you
     have to sort the edges for each scanline (this can be countered by
     keeping the order of the previous scanline - it won't change much).
     The BIG advantage is that you write each pixel only once.  If you
     have a lot of overlapping polygons you can get incredible speeds
     compared to any of the previous algorithms.  This algorithm is
     covered by the *_scene routines.

The scene rendering has approximately the following steps:

   * Initialize the scene (set the clip area, clear the bitmap, blit a
     background, etc.)
   * Call clear_scene().
   * Transform all your points to camera space.
   * Clip polygons.
   * Project with persp_project() or persp_project_f().
   * "Draw" polygons with scene_polygon3d() and/or scene_polygon3d_f().
     This doesn't do any actual drawing, only initializes tables.
   * Render all the polygons defined previously to the bitmap with
     render_scene().
   * Overlay some non-3D graphics.
   * Show the bitmap (blit it to screen, flip the page, etc).

For each horizontal line in the viewport an x-sorted edge list is used
to keep track of what polygons are "in" and which is the nearest.
Vertical coherency is used - the edge list for a scanline is sorted
starting from the previous one - it won't change much.  The scene
rendering routines use the same low-level asm routines as normal
polygon3d().

Notes on scene rendering:

   * Unlike polygon3d(), scene_polygon3d() requires valid z coordinates
     for all vertices, regardless of rendering style (unlike
     polygon3d(), which only uses z coordinate for *PTEX*).
   * All polygons passed to scene_polygon3d() have to be
     persp_project()'ed.
   * After render_scene() the mode is reset to SOLID.

Using a lot of *MASK* polygons drastically reduces performance, because
when a MASKed polygon is the first in line of sight, the polygons
underneath have to be drawn too.  The same applies to FLAT polygons
drawn with DRAW_MODE_TRANS.

Z-buffered rendering works also within the scene renderer.  It may be
helpful when you have a few intersecting polygons, but most of the
polygons may be safely rendered by the normal scanline sorting
algorithm.  Same as before: just OR the POLYTYPE with POLYTYPE_ZBUF.
Also, you have to clear the z-buffer at the start of the frame.
Example:

     clear_scene(buffer);
     if (some_polys_are_zbuf) clear_zbuffer(0.);
     while (polygons) {
        ...
        if (this_poly_is_zbuf) type |= POLYTYPE_ZBUF;
        scene_polygon3d(type, tex, vc, vtx);
     }
     render_scene();


File: allegro.info,  Node: create_scene,  Next: clear_scene,  Prev: Scene rendering,  Up: Polygon

1.20.23 create_scene
--------------------

int create_scene(int nedge, int npoly);
     Allocates memory for a scene, 'nedge' and 'npoly' are your
     estimates of how many edges and how many polygons you will render
     (you cannot get over the limit specified here).  If you use same
     values in successive calls, the space will be reused (no new
     malloc()).

     The memory allocated is a little less than 150 * (nedge + npoly)
     bytes.

     Returns zero on success, or a negative number if allocations fail.

See also:
*Note scene_polygon3d::.
*Note render_scene::.
*Note clear_scene::.
*Note destroy_scene::.
*Note scene_gap::.
*Note create_zbuffer::.
*Note exscn3d::.


File: allegro.info,  Node: clear_scene,  Next: destroy_scene,  Prev: create_scene,  Up: Polygon

1.20.24 clear_scene
-------------------

void clear_scene(BITMAP *bmp);
     Initializes a scene.  The bitmap is the bitmap you will eventually
     render on.

See also:
*Note create_scene::.
*Note scene_polygon3d::.
*Note render_scene::.
*Note destroy_scene::.
*Note scene_gap::.
*Note exscn3d::.
*Note BITMAP::.


File: allegro.info,  Node: destroy_scene,  Next: scene_polygon3d,  Prev: clear_scene,  Up: Polygon

1.20.25 destroy_scene
---------------------

void destroy_scene();
     Deallocate memory previously allocated by create_scene.  Use this
     to avoid memory leaks in your program.

See also:
*Note create_scene::.
*Note scene_polygon3d::.
*Note clear_scene::.
*Note render_scene::.
*Note scene_gap::.
*Note exscn3d::.


File: allegro.info,  Node: scene_polygon3d,  Next: render_scene,  Prev: destroy_scene,  Up: Polygon

1.20.26 scene_polygon3d
-----------------------

int scene_polygon3d(int type, BITMAP *texture, int vc, V3D *vtx[]);
int scene_polygon3d_f(int type, BITMAP *texture, int vc, V3D_f *vtx[]);
     Puts a polygon in the rendering list.  Nothing is really rendered
     at this moment.  Should be called between clear_scene() and
     render_scene().

     Arguments are the same as for polygon3d(), except the bitmap is
     missing.  The one passed to clear_scene() will be used.

     Unlike polygon3d(), the polygon may be concave or
     self-intersecting.  Shapes that penetrate one another may look OK,
     but they are not really handled by this code.

     Note that the texture is stored as a pointer only, and you should
     keep the actual bitmap around until render_scene(), where it is
     used.

     Since the FLAT style is implemented with the low-level hline()
     function, the FLAT style is subject to DRAW_MODEs.  All these modes
     are valid.  Along with the polygon, this mode will be stored for
     the rendering moment, and also all the other related variables
     (color_map pointer, pattern pointer, anchor, blender values).

     The settings of the CPU_MMX and CPU_3DNOW flags of the
     cpu_capabilities global variable on entry in this routine affect
     the choice of low-level asm routine that will be used by
     render_scene() for this polygon.

     Returns zero on success, or a negative number if it won't be
     rendered for lack of a rendering routine.

See also:
*Note create_scene::.
*Note clear_scene::.
*Note render_scene::.
*Note destroy_scene::.
*Note polygon3d::.
*Note cpu_capabilities::.
*Note exscn3d::.
*Note BITMAP::.
*Note V3D::.
*Note V3D_f::.


File: allegro.info,  Node: render_scene,  Next: scene_gap,  Prev: scene_polygon3d,  Up: Polygon

1.20.27 render_scene
--------------------

void render_scene();
     Renders all the specified scene_polygon3d()'s on the bitmap passed
     to clear_scene().  Rendering is done one scanline at a time, with
     no pixel being processed more than once.

     Note that between clear_scene() and render_scene() you shouldn't
     change the clip rectangle of the destination bitmap.  For speed
     reasons, you should set the clip rectangle to the minimum.

     Note also that all the textures passed to scene_polygon3d() are
     stored as pointers only and actually used in render_scene().

See also:
*Note create_scene::.
*Note clear_scene::.
*Note destroy_scene::.
*Note scene_gap::.
*Note scene_polygon3d::.
*Note exscn3d::.


File: allegro.info,  Node: scene_gap,  Next: drawing_mode,  Prev: render_scene,  Up: Polygon

1.20.28 scene_gap
-----------------

extern float scene_gap;
     This number (default value = 100.0) controls the behaviour of the
     z-sorting algorithm.  When an edge is very close to another's
     polygon plane, there is an interval of uncertainty in which you
     cannot tell which object is visible (which z is smaller).  This is
     due to cumulative numerical errors for edges that have undergone a
     lot of transformations and interpolations.

     The default value means that if the 1/z values (in projected space)
     differ by only 1/100 (one percent), they are considered to be equal
     and the x-slopes of the planes are used to find out which plane is
     getting closer when we move to the right.

     Larger values means narrower margins, and increasing the chance of
     missing true adjacent edges/planes.  Smaller values means larger
     margins, and increasing the chance of mistaking close polygons for
     adjacent ones.  The value of 100 is close to the optimum.  However,
     the optimum shifts slightly with resolution, and may be
     application-dependent.  It is here for you to fine-tune.

See also:
*Note create_scene::.
*Note clear_scene::.
*Note destroy_scene::.
*Note render_scene::.
*Note scene_polygon3d::.


File: allegro.info,  Node: Transparency,  Next: Converting,  Prev: Polygon,  Up: API

1.21 Transparency and patterned drawing
=======================================

* Menu:

* drawing_mode::
* xor_mode::
* solid_mode::
* 256-color transparency::
* color_map::
* create_trans_table::
* create_light_table::
* create_color_table::
* create_blender_table::
* Truecolor transparency::
* set_trans_blender::
* set_alpha_blender::
* set_write_alpha_blender::
* set_add_blender::
* set_burn_blender::
* set_color_blender::
* set_difference_blender::
* set_dissolve_blender::
* set_dodge_blender::
* set_hue_blender::
* set_invert_blender::
* set_luminance_blender::
* set_multiply_blender::
* set_saturation_blender::
* set_screen_blender::
* set_blender_mode::
* set_blender_mode_ex::


File: allegro.info,  Node: drawing_mode,  Next: xor_mode,  Prev: scene_gap,  Up: Transparency

1.21.1 drawing_mode
-------------------

void drawing_mode(int mode, BITMAP *pattern, int x_anchor, int y_anchor);
     Sets the graphics drawing mode.  This only affects the geometric
     routines like putpixel, lines, rectangles, circles, polygons,
     floodfill, etc, not the text output, blitting, or sprite drawing
     functions.  The mode should be one of the following constants:

          DRAW_MODE_SOLID               - the default, solid color
                                          drawing
          DRAW_MODE_XOR                 - exclusive-or drawing
          DRAW_MODE_COPY_PATTERN        - multicolored pattern fill
          DRAW_MODE_SOLID_PATTERN       - single color pattern fill
          DRAW_MODE_MASKED_PATTERN      - masked pattern fill
          DRAW_MODE_TRANS               - translucent color blending

     In DRAW_MODE_SOLID, pixels of the bitmap being drawn onto are
     simply replaced by those produced by the drawing function.

     In DRAW_MODE_XOR, pixels are written to the bitmap with an
     exclusive-or operation rather than a simple copy, so drawing the
     same shape twice will erase it.  Because it involves reading as
     well as writing the bitmap memory, xor drawing is a lot slower than
     the normal replace mode.

     With the patterned modes, you provide a pattern bitmap which is
     tiled across the surface of the shape.  Allegro stores a pointer to
     this bitmap rather than copying it, so you must not destroy the
     bitmap while it is still selected as the pattern.  The width and
     height of the pattern must be powers of two, but they can be
     different, eg.  a 64x16 pattern is fine, but a 17x3 one is not.
     The pattern is tiled in a grid starting at point (x_anchor,
     y_anchor).  Normally you should just pass zero for these values,
     which lets you draw several adjacent shapes and have the patterns
     meet up exactly along the shared edges.  Zero alignment may look
     peculiar if you are moving a patterned shape around the screen,
     however, because the shape will move but the pattern alignment will
     not, so in some situations you may wish to alter the anchor
     position.

     When you select DRAW_MODE_COPY_PATTERN, pixels are simply copied
     from the pattern bitmap onto the destination bitmap.  This allows
     the use of multicolored patterns, and means that the color you pass
     to the drawing routine is ignored.  This is the fastest of the
     patterned modes.

     In DRAW_MODE_SOLID_PATTERN, each pixel in the pattern bitmap is
     compared with the mask color, which is zero in 256-color modes or
     bright pink for truecolor data (maximum red and blue, zero green).
     If the pattern pixel is solid, a pixel of the color you passed to
     the drawing routine is written to the destination bitmap, otherwise
     a zero is written.  The pattern is thus treated as a monochrome
     bitmask, which lets you use the same pattern to draw different
     shapes in different colors, but prevents the use of multicolored
     patterns.

     DRAW_MODE_MASKED_PATTERN is almost the same as
     DRAW_MODE_SOLID_PATTERN, but the masked pixels are skipped rather
     than being written as zeros, so the background shows through the
     gaps.

     In DRAW_MODE_TRANS, the global color_map table or truecolor blender
     functions are used to overlay pixels on top of the existing image.
     This must only be used after you have set up the color mapping
     table (for 256 color modes) or blender functions (for truecolor
     modes).  Because it involves reading as well as writing the bitmap
     memory, translucent drawing is very slow if you draw directly to
     video RAM, so wherever possible you should use a memory bitmap
     instead.

See also:
*Note xor_mode::.
*Note solid_mode::.
*Note color_map::.
*Note set_trans_blender::.
*Note exalpha::.
*Note excolmap::.
*Note exjoy::.
*Note expat::.
*Note extrans::.
*Note BITMAP::.


File: allegro.info,  Node: xor_mode,  Next: solid_mode,  Prev: drawing_mode,  Up: Transparency

1.21.2 xor_mode
---------------

void xor_mode(int on);
     This is a shortcut for toggling xor drawing mode on and off.
     Calling xor_mode(TRUE) is equivalent to drawing_mode(DRAW_MODE_XOR,
     NULL, 0, 0).  Calling xor_mode(FALSE) is equivalent to
     drawing_mode(DRAW_MODE_SOLID, NULL, 0, 0).

See also:
*Note drawing_mode::.
*Note exspline::.
*Note exupdate::.


File: allegro.info,  Node: solid_mode,  Next: 256-color transparency,  Prev: xor_mode,  Up: Transparency

1.21.3 solid_mode
-----------------

void solid_mode();
     This is a shortcut for selecting solid drawing mode.  It is
     equivalent to calling drawing_mode(DRAW_MODE_SOLID, NULL, 0, 0).

See also:
*Note drawing_mode::.
*Note exalpha::.
*Note expat::.


File: allegro.info,  Node: 256-color transparency,  Next: color_map,  Prev: solid_mode,  Up: Transparency

1.21.4 256-color transparency
-----------------------------

In paletted video modes, translucency and lighting are implemented with
a 64k lookup table, which contains the result of combining any two
colors c1 and c2.  You must set up this table before you use any of the
translucency or lighting routines.  Depending on how you construct the
table, a range of different effects are possible.  For example,
translucency can be implemented by using a color halfway between c1 and
c2 as the result of the combination.  Lighting is achieved by treating
one of the colors as a light level (0-255) rather than a color, and
setting up the table appropriately.  A range of specialised effects are
possible, for instance replacing any color with any other color and
making individual source or destination colors completely solid or
invisible.  Color mapping tables can be precalculated with the colormap
utility, or generated at runtime.  Read chapter "Structures and types
defined by Allegro" for an internal description of the COLOR_MAP
structure.


File: allegro.info,  Node: color_map,  Next: create_trans_table,  Prev: 256-color transparency,  Up: Transparency

1.21.5 color_map
----------------

extern COLOR_MAP *color_map;
     Global pointer to the color mapping table.  You must allocate your
     own COLOR_MAP either statically or dynamically and set color_map to
     it before using any translucent or lit drawing functions in a
     256-color video mode!  Example:

          color_map = malloc(sizeof(COLOR_MAP));
          if (!color_map)
             abort_on_error("Not enough memory for color map!");

See also:
*Note create_color_table::.
*Note create_light_table::.
*Note create_trans_table::.
*Note create_blender_table::.
*Note set_trans_blender::.
*Note draw_trans_sprite::.
*Note draw_lit_sprite::.
*Note draw_gouraud_sprite::.
*Note drawing_mode::.
*Note ex3d::.
*Note excolmap::.
*Note exlights::.
*Note exshade::.
*Note extrans::.
*Note COLOR_MAP::.


File: allegro.info,  Node: create_trans_table,  Next: create_light_table,  Prev: color_map,  Up: Transparency

1.21.6 create_trans_table
-------------------------

void create_trans_table(COLOR_MAP *table, const PALETTE pal, int r, g, b, void (*callback)(int pos));
     Fills the specified color mapping table with lookup data for doing
     translucency effects with the specified palette.  When combining
     the colors c1 and c2 with this table, the result will be a color
     somewhere between the two.  The r, g, and b parameters specify the
     solidity of each color component, ranging from 0 (totally
     transparent) to 255 (totally solid).  For 50% solidity, pass 128.

     This function treats source color #0 as a special case, leaving the
     destination unchanged whenever a zero source pixel is encountered,
     so that masked sprites will draw correctly.  This function will
     take advantage of the global rgb_map variable to speed up color
     conversions.  If the callback function is not NULL, it will be
     called 256 times during the calculation, allowing you to display a
     progress indicator.  Example:

          COLOR_MAP trans_table;
          ...
          /* Build a color lookup table for translucent drawing. */
          create_trans_table(&trans_table, pal, 128, 128, 128, NULL);

See also:
*Note color_map::.
*Note create_light_table::.
*Note create_color_table::.
*Note create_blender_table::.
*Note draw_trans_sprite::.
*Note draw_lit_sprite::.
*Note draw_gouraud_sprite::.
*Note rgb_map::.
*Note ex3d::.
*Note extrans::.
*Note PALETTE::.
*Note COLOR_MAP::.


File: allegro.info,  Node: create_light_table,  Next: create_color_table,  Prev: create_trans_table,  Up: Transparency

1.21.7 create_light_table
-------------------------

void create_light_table(COLOR_MAP *table, const PALETTE pal, int r, g, b, void (*callback)(int pos));
     Fills the specified color mapping table with lookup data for doing
     lighting effects with the specified palette.  When combining the
     colors c1 and c2 with this table, c1 is treated as a light level
     from 0-255.  At light level 255 the table will output color c2
     unchanged, at light level 0 it will output the r, g, b value you
     specify to this function, and at intermediate light levels it will
     output a color somewhere between the two extremes.  The r, g, and b
     values are in the range 0-63.

     This function will take advantage of the global rgb_ap variable to
     speed up color conversions.  If the callback function is not NULL,
     it will be called 256 times during the calculation, allowing you to
     display a progress indicator.  Example:

          COLOR_MAP light_table;
          ...
          /* Build a color lookup table for lighting effects. */
          create_light_table(&light_table, pal, 0, 0, 0, NULL);

See also:
*Note color_map::.
*Note create_trans_table::.
*Note create_color_table::.
*Note create_blender_table::.
*Note draw_trans_sprite::.
*Note draw_lit_sprite::.
*Note draw_gouraud_sprite::.
*Note rgb_map::.
*Note ex3d::.
*Note exshade::.
*Note extrans::.
*Note PALETTE::.
*Note COLOR_MAP::.


File: allegro.info,  Node: create_color_table,  Next: create_blender_table,  Prev: create_light_table,  Up: Transparency

1.21.8 create_color_table
-------------------------

void create_color_table(COLOR_MAP *table, const PALETTE pal, void (*blend)(PALETTE pal, int x, int y, RGB *rgb), void (*callback)(int pos));
     Fills the specified color mapping table with lookup data for doing
     customised effects with the specified palette, calling the blend
     function to determine the results of each color combination.

     Your blend routine will be passed a pointer to the palette and the
     two indices of the colors which are to be combined, and should fill
     in the RGB structure with the desired result in 0-63 format.
     Allegro will then search the palette for the closest match to the
     RGB color that you requested, so it doesn't matter if the palette
     has no exact match for this color.

     If the callback function is not NULL, it will be called 256 times
     during the calculation, allowing you to display a progress
     indicator.  Example:

          COLOR_MAP greyscale_table;
          ...
          void return_grey_color(const PALETTE pal,
                                 int x, int y, RGB *rgb)
          {
             ...
          }
          ...
             /* Build a color lookup table for greyscale effect. */
             create_color_table(&greyscale_table, pal,
                                return_grey_color, NULL);

See also:
*Note color_map::.
*Note create_light_table::.
*Note create_trans_table::.
*Note create_blender_table::.
*Note draw_trans_sprite::.
*Note draw_lit_sprite::.
*Note draw_gouraud_sprite::.
*Note rgb_map::.
*Note excolmap::.
*Note PALETTE::.
*Note RGB::.
*Note COLOR_MAP::.


File: allegro.info,  Node: create_blender_table,  Next: Truecolor transparency,  Prev: create_color_table,  Up: Transparency

1.21.9 create_blender_table
---------------------------

void create_blender_table(COLOR_MAP *table, const PALETTE pal, void (*callback)(int pos));
     Fills the specified color mapping table with lookup data for doing
     a paletted equivalent of whatever truecolor blender mode is
     currently selected.  After calling set_trans_blender(),
     set_blender_mode(), or any of the other truecolor blender mode
     routines, you can use this function to create an 8-bit mapping
     table that will have the same results as whatever 24-bit blending
     mode you have enabled.

See also:
*Note color_map::.
*Note create_light_table::.
*Note create_trans_table::.
*Note create_color_table::.
*Note draw_trans_sprite::.
*Note draw_lit_sprite::.
*Note draw_gouraud_sprite::.
*Note set_trans_blender::.
*Note set_blender_mode::.
*Note PALETTE::.
*Note COLOR_MAP::.


File: allegro.info,  Node: Truecolor transparency,  Next: set_trans_blender,  Prev: create_blender_table,  Up: Transparency

1.21.10 Truecolor transparency
------------------------------

In truecolor video modes, translucency and lighting are implemented by a
blender function of the form:

     unsigned long (*BLENDER_FUNC)(unsigned long x, y, n);

For each pixel to be drawn, this routine is passed two color parameters
x and y, decomposes them into their red, green and blue components,
combines them according to some mathematical transformation involving
the interpolation factor n, and then merges the result back into a
single return color value, which will be used to draw the pixel onto the
destination bitmap.

The parameter x represents the blending modifier color and the parameter
y represents the base color to be modified.  The interpolation factor n
is in the range [0-255] and controls the solidity of the blending.

When a translucent drawing function is used, x is the color of the
source, y is the color of the bitmap being drawn onto and n is the alpha
level that was passed to the function that sets the blending mode (the
RGB triplet that was passed to this function is not taken into account).

When a lit sprite drawing function is used, x is the color represented
by the RGB triplet that was passed to the function that sets the
blending mode (the alpha level that was passed to this function is not
taken into account), y is the color of the sprite and n is the alpha
level that was passed to the drawing function itself.

Since these routines may be used from various different color depths,
there are three such callbacks, one for use with 15-bit 5.5.5 pixels,
one for 16 bit 5.6.5 pixels, and one for 24-bit 8.8.8 pixels (this can
be shared between the 24 and 32-bit code since the bit packing is the
same).


File: allegro.info,  Node: set_trans_blender,  Next: set_alpha_blender,  Prev: Truecolor transparency,  Up: Transparency

1.21.11 set_trans_blender
-------------------------

void set_trans_blender(int r, int g, int b, int a);
     Enables a linear interpolator blender mode for combining
     translucent or lit truecolor pixels.

See also:
*Note set_blender_mode::.
*Note set_alpha_blender::.
*Note set_write_alpha_blender::.
*Note color_map::.
*Note draw_trans_sprite::.
*Note draw_lit_sprite::.
*Note drawing_mode::.
*Note set_add_blender::.
*Note set_burn_blender::.
*Note set_color_blender::.
*Note set_difference_blender::.
*Note set_dissolve_blender::.
*Note set_dodge_blender::.
*Note set_hue_blender::.
*Note set_invert_blender::.
*Note set_luminance_blender::.
*Note set_multiply_blender::.
*Note set_saturation_blender::.
*Note set_screen_blender::.
*Note ex3d::.
*Note exblend::.
*Note exrotscl::.
*Note exshade::.
*Note extrans::.
*Note extrans2::.
*Note exxfade::.


File: allegro.info,  Node: set_alpha_blender,  Next: set_write_alpha_blender,  Prev: set_trans_blender,  Up: Transparency

1.21.12 set_alpha_blender
-------------------------

void set_alpha_blender();
     Enables the special alpha-channel blending mode, which is used for
     drawing 32-bit RGBA sprites.  After calling this function, you can
     use draw_trans_sprite() or draw_trans_rle_sprite() to draw a 32-bit
     source image onto any hicolor or truecolor destination.  The alpha
     values will be taken directly from the source graphic, so you can
     vary the solidity of each part of the image.  You can't use any of
     the normal translucency functions while this mode is active,
     though, so you should reset to one of the normal blender modes (eg.
     set_trans_blender()) before drawing anything other than 32-bit RGBA
     sprites.

See also:
*Note set_trans_blender::.
*Note draw_trans_sprite::.
*Note draw_trans_rle_sprite::.
*Note set_write_alpha_blender::.
*Note exalpha::.
*Note exrotscl::.
*Note extrans::.


File: allegro.info,  Node: set_write_alpha_blender,  Next: set_add_blender,  Prev: set_alpha_blender,  Up: Transparency

1.21.13 set_write_alpha_blender
-------------------------------

void set_write_alpha_blender();
     Enables the special alpha-channel editing mode, which is used for
     drawing alpha channels over the top of an existing 32-bit RGB
     sprite, to turn it into an RGBA format image.  After calling this
     function, you can set the drawing mode to DRAW_MODE_TRANS and then
     write draw color values (0-255) onto a 32-bit image.  This will
     leave the color values unchanged, but alter the alpha to whatever
     values you are writing.  After enabling this mode you can also use
     draw_trans_sprite() to superimpose an 8-bit alpha mask over the top
     of an existing 32-bit sprite.

See also:
*Note set_alpha_blender::.
*Note draw_trans_sprite::.
*Note drawing_mode::.
*Note exalpha::.
*Note extrans::.


File: allegro.info,  Node: set_add_blender,  Next: set_burn_blender,  Prev: set_write_alpha_blender,  Up: Transparency

1.21.14 set_add_blender
-----------------------

void set_add_blender(int r, int g, int b, int a);
     Enables an additive blender mode for combining translucent or lit
     truecolor pixels.

See also:
*Note set_trans_blender::.
*Note drawing_mode::.


File: allegro.info,  Node: set_burn_blender,  Next: set_color_blender,  Prev: set_add_blender,  Up: Transparency

1.21.15 set_burn_blender
------------------------

void set_burn_blender(int r, int g, int b, int a);
     Enables a burn blender mode for combining translucent or lit
     truecolor pixels.  Here the lightness values of the colours of the
     source image reduce the lightness of the destination image,
     darkening the image.

See also:
*Note set_trans_blender::.
*Note drawing_mode::.


File: allegro.info,  Node: set_color_blender,  Next: set_difference_blender,  Prev: set_burn_blender,  Up: Transparency

1.21.16 set_color_blender
-------------------------

void set_color_blender(int r, int g, int b, int a);
     Enables a color blender mode for combining translucent or lit
     truecolor pixels.  Applies only the hue and saturation of the
     source image to the destination image.  The luminance of the
     destination image is not affected.

See also:
*Note set_trans_blender::.
*Note drawing_mode::.


File: allegro.info,  Node: set_difference_blender,  Next: set_dissolve_blender,  Prev: set_color_blender,  Up: Transparency

1.21.17 set_difference_blender
------------------------------

void set_difference_blender(int r, int g, int b, int a);
     Enables a difference blender mode for combining translucent or lit
     truecolor pixels.  This makes an image which has colours calculated
     by the difference between the source and destination colours.

See also:
*Note set_trans_blender::.
*Note drawing_mode::.


File: allegro.info,  Node: set_dissolve_blender,  Next: set_dodge_blender,  Prev: set_difference_blender,  Up: Transparency

1.21.18 set_dissolve_blender
----------------------------

void set_dissolve_blender(int r, int g, int b, int a);
     Enables a dissolve blender mode for combining translucent or lit
     truecolor pixels.  Randomly replaces the colours of some pixels in
     the destination image with those of the source image.  The number
     of pixels replaced depends on the alpha value (higher value, more
     pixels replaced; you get the idea :).

See also:
*Note set_trans_blender::.
*Note drawing_mode::.


File: allegro.info,  Node: set_dodge_blender,  Next: set_hue_blender,  Prev: set_dissolve_blender,  Up: Transparency

1.21.19 set_dodge_blender
-------------------------

void set_dodge_blender(int r, int g, int b, int a);
     Enables a dodge blender mode for combining translucent or lit
     truecolor pixels.  The lightness of colours in the source lighten
     the colours of the destination.  White has the most effect; black
     has none.

See also:
*Note set_trans_blender::.
*Note drawing_mode::.


File: allegro.info,  Node: set_hue_blender,  Next: set_invert_blender,  Prev: set_dodge_blender,  Up: Transparency

1.21.20 set_hue_blender
-----------------------

void set_hue_blender(int r, int g, int b, int a);
     Enables a hue blender mode for combining translucent or lit
     truecolor pixels.  This applies the hue of the source to the
     destination.

See also:
*Note set_trans_blender::.
*Note drawing_mode::.


File: allegro.info,  Node: set_invert_blender,  Next: set_luminance_blender,  Prev: set_hue_blender,  Up: Transparency

1.21.21 set_invert_blender
--------------------------

void set_invert_blender(int r, int g, int b, int a);
     Enables an invert blender mode for combining translucent or lit
     truecolor pixels.  Blends the inverse (or negative) colour of the
     source with the destination.

See also:
*Note set_trans_blender::.
*Note drawing_mode::.


File: allegro.info,  Node: set_luminance_blender,  Next: set_multiply_blender,  Prev: set_invert_blender,  Up: Transparency

1.21.22 set_luminance_blender
-----------------------------

void set_luminance_blender(int r, int g, int b, int a);
     Enables a luminance blender mode for combining translucent or lit
     truecolor pixels.  Applies the luminance of the source to the
     destination.  The colour of the destination is not affected.

See also:
*Note set_trans_blender::.
*Note drawing_mode::.


File: allegro.info,  Node: set_multiply_blender,  Next: set_saturation_blender,  Prev: set_luminance_blender,  Up: Transparency

1.21.23 set_multiply_blender
----------------------------

void set_multiply_blender(int r, int g, int b, int a);
     Enables a multiply blender mode for combining translucent or lit
     truecolor pixels.  Combines the source and destination images,
     multiplying the colours to produce a darker colour.  If a colour is
     multiplied by white it remains unchanged; when multiplied by black
     it also becomes black.

See also:
*Note set_trans_blender::.
*Note drawing_mode::.
*Note exalpha::.


File: allegro.info,  Node: set_saturation_blender,  Next: set_screen_blender,  Prev: set_multiply_blender,  Up: Transparency

1.21.24 set_saturation_blender
------------------------------

void set_saturation_blender(int r, int g, int b, int a);
     Enables a saturation blender mode for combining translucent or lit
     truecolor pixels.  Applies the saturation of the source to the
     destination image.

See also:
*Note set_trans_blender::.
*Note drawing_mode::.


File: allegro.info,  Node: set_screen_blender,  Next: set_blender_mode,  Prev: set_saturation_blender,  Up: Transparency

1.21.25 set_screen_blender
--------------------------

void set_screen_blender(int r, int g, int b, int a);
     Enables a screen blender mode for combining translucent or lit
     truecolor pixels.  This blender mode lightens the colour of the
     destination image by multiplying the inverse of the source and
     destination colours.  Sort of like the opposite of the multiply
     blender mode.

See also:
*Note set_trans_blender::.
*Note drawing_mode::.


File: allegro.info,  Node: set_blender_mode,  Next: set_blender_mode_ex,  Prev: set_screen_blender,  Up: Transparency

1.21.26 set_blender_mode
------------------------

void set_blender_mode(BLENDER_FUNC b15, b16, b24, int r, g, b, a);
     Specifies a custom set of truecolor blender routines, which can be
     used to implement whatever special interpolation modes you need.
     This function shares a single blender between the 24 and 32-bit
     modes.

See also:
*Note set_blender_mode_ex::.
*Note set_trans_blender::.
*Note color_map::.
*Note draw_trans_sprite::.
*Note draw_lit_sprite::.
*Note drawing_mode::.


File: allegro.info,  Node: set_blender_mode_ex,  Next: bestfit_color,  Prev: set_blender_mode,  Up: Transparency

1.21.27 set_blender_mode_ex
---------------------------

void set_blender_mode_ex(BLENDER_FUNC b15, b16, b24, b32, b15x, b16x, b24x, int r, g, b, a);
     Like set_blender_mode(), but allows you to specify a more complete
     set of blender routines.  The b15, b16, b24, and b32 routines are
     used when drawing pixels onto destinations of the same format,
     while b15x, b16x, and b24x are used by draw_trans_sprite() and
     draw_trans_rle_sprite() when drawing RGBA images onto destination
     bitmaps of another format.  These blenders will be passed a 32-bit
     x parameter, along with a y value of a different color depth, and
     must try to do something sensible in response.

See also:
*Note set_blender_mode::.
*Note set_alpha_blender::.


File: allegro.info,  Node: Converting,  Next: Direct,  Prev: Transparency,  Up: API

1.22 Converting between color formats
=====================================

In general, Allegro is designed to be used in only one color depth at a
time, so you will call set_color_depth() once and then store all your
bitmaps in the same format.  If you want to mix several different pixel
formats, you can use create_bitmap_ex() in place of create_bitmap(), and
call bitmap_color_depth() to query the format of a specific image.  Most
of the graphics routines require all their input parameters to be in the
same format (eg.  you cannot stretch a 15-bit source bitmap onto a
24-bit destination), but there are some exceptions:

   * blit() and the rotation routines can copy between bitmaps of any
     format, converting the data as required.
   * draw_sprite() can draw 256-color source images onto destinations of
     any format.
   * draw_character_ex() _always_ uses a 256-color source bitmap,
     whatever the format of the destination.
   * The draw_trans_sprite() and draw_trans_rle_sprite() functions are
     able to draw 32-bit RGBA images onto any hicolor or truecolor
     destination, as long as you call set_alpha_blender() first.
   * The draw_trans_sprite() function is able to draw an 8-bit alpha
     channel image over the top of an existing 32-bit image, as long as
     you call set_write_alpha_blender() first.

Expanding a 256-color source onto a truecolor destination is fairly fast
(obviously you must set the correct palette before doing this
conversion!).  Converting between different truecolor formats is
slightly slower, and reducing truecolor images to a 256-color
destination is very slow (it can be sped up significantly if you set up
the global rgb_map table before doing the conversion).

* Menu:

* bestfit_color::
* rgb_map::
* create_rgb_table::
* hsv_to_rgb::


File: allegro.info,  Node: bestfit_color,  Next: rgb_map,  Prev: set_blender_mode_ex,  Up: Converting

1.22.1 bestfit_color
--------------------

int bestfit_color(const PALETTE pal, int r, int g, int b);
     Searches the specified palette for the closest match to the
     requested color, which are specified in the VGA hardware 0-63
     format.  Normally you should call makecol8() instead, but this
     lower level function may be useful if you need to use a palette
     other than the currently selected one, or specifically don't want
     to use the rgb_map lookup table.

     Returns the index of the palette for the closest match to the
     requested color.

See also:
*Note makecol8::.
*Note PALETTE::.


File: allegro.info,  Node: rgb_map,  Next: create_rgb_table,  Prev: bestfit_color,  Up: Converting

1.22.2 rgb_map
--------------

extern RGB_MAP *rgb_map;
     To speed up reducing RGB values to 8-bit paletted colors, Allegro
     uses a 32k lookup table (5 bits for each color component).  You
     must set up this table before using the gouraud shading routines,
     and if present the table will also vastly accelerate the makecol8()
     and some create_*_table() functions.  RGB tables can be
     precalculated with the rgbmap utility, or generated at runtime with
     create_rgb_table().

See also:
*Note create_rgb_table::.
*Note makecol8::.
*Note create_trans_table::.
*Note create_light_table::.
*Note create_color_table::.
*Note ex3d::.
*Note excolmap::.
*Note exrgbhsv::.
*Note exshade::.
*Note extrans::.
*Note RGB_MAP::.


File: allegro.info,  Node: create_rgb_table,  Next: hsv_to_rgb,  Prev: rgb_map,  Up: Converting

1.22.3 create_rgb_table
-----------------------

void create_rgb_table(RGB_MAP *table, const PALETTE pal, void (*callback)(int pos));
     Fills the specified RGB mapping table with lookup data for the
     specified palette.  If the callback function is not NULL, it will
     be called 256 times during the calculation, allowing you to display
     a progress indicator.  Example:

          RGB_MAP rgb_table;

          create_rgb_table(&rgb_table, palette, NULL);
          rgb_map = &rgb_table;

See also:
*Note rgb_map::.
*Note ex3d::.
*Note excolmap::.
*Note exrgbhsv::.
*Note exshade::.
*Note extrans::.
*Note PALETTE::.
*Note RGB_MAP::.


File: allegro.info,  Node: hsv_to_rgb,  Next: bmp_write_line,  Prev: create_rgb_table,  Up: Converting

1.22.4 hsv_to_rgb
-----------------

void hsv_to_rgb(float h, float s, float v, int *r, int *g, int *b);
void rgb_to_hsv(int r, int g, int b, float *h, float *s, float *v);
     Convert color values between the HSV and RGB color spaces.  The RGB
     values range from 0 to 255, hue is from 0 to 360, and saturation
     and value are from 0 to 1.  Example:

          int r, g, b;
          float hue, saturation, value;
          ...
          /* Convert a reddish color to HSV format. */
          rgb_to_hsv(255, 0, 128, &hue, &saturation, &value);

          /* Now put our tin foil hat, and verify that. */
          hsv_to_rgb(hue, saturation, value, &r, &g, &b);
          ASSERT(r == 255);
          ASSERT(g == 0);
          ASSERT(b == 128);

See also:
*Note exlights::.
*Note exrgbhsv::.


File: allegro.info,  Node: Direct,  Next: FLIC,  Prev: Converting,  Up: API

1.23 Direct access to video memory
==================================

Read chapter "Structures and types defined by Allegro" for an internal
description of the BITMAP structure.  There are several ways to get
direct access to the image memory of a bitmap, varying in complexity
depending on what sort of bitmap you are using.

The simplest approach will only work with memory bitmaps (obtained from
create_bitmap(), grabber datafiles, and image files) and sub-bitmaps of
memory bitmaps.  This uses a table of char pointers, called 'line',
which is a part of the bitmap structure and contains pointers to the
start of each line of the image.  For example, a simple memory bitmap
putpixel function is:

     void memory_putpixel(BITMAP *bmp, int x, int y, int color)
     {
        bmp->line[y][x] = color;
     }

For truecolor modes you need to cast the line pointer to the appropriate
type, for example:

     void memory_putpixel_15_or_16_bpp(BITMAP *bmp, int x, int y, int color)
     {
        ((short *)bmp->line[y])[x] = color;
     }

     void memory_putpixel_32(BITMAP *bmp, int x, int y, int color)
     {
        ((long *)bmp->line[y])[x] = color;
     }

If you want to write to the screen as well as to memory bitmaps, you
need to use some helper macros, because the video memory may not be part
of your normal address space.  This simple routine will work for any
linear screen, eg.  a VESA linear framebuffers:

     void linear_screen_putpixel(BITMAP *bmp, int x, int y, int color)
     {
        bmp_select(bmp);
        bmp_write8((unsigned long)bmp->line[y]+x, color);
     }

For truecolor modes you should replace the bmp_write8() with
bmp_write16(), bmp_write24(), or bmp_write32(), and multiply the x
offset by the number of bytes per pixel.  There are of course similar
functions to read a pixel value from a bitmap, namely bmp_read8(),
bmp_read16(), bmp_read24() and bmp_read32().

This still won't work in banked SVGA modes, however, or on platforms
like Windows that do special processing inside the bank switching
functions.  For more flexible access to bitmap memory, you need to call
the following routines.  They are implemented as inline assembler
routines, so they are not as inefficient as they might seem.  If the
bitmap doesn't require bank switching (ie.  it is a memory bitmap, mode
13h screen, etc), these functions just return bmp->line[line].

* Menu:

* bmp_write_line::
* bmp_read_line::
* bmp_unwrite_line::
* More on banked direct memory access::


File: allegro.info,  Node: bmp_write_line,  Next: bmp_read_line,  Prev: hsv_to_rgb,  Up: Direct

1.23.1 bmp_write_line
---------------------

unsigned long bmp_write_line(BITMAP *bmp, int line);
     Selects the line of a bitmap that you are going to draw onto.

     Returns the address of the selected line for writing.

See also:
*Note exflame::.
*Note exlights::.
*Note BITMAP::.


File: allegro.info,  Node: bmp_read_line,  Next: bmp_unwrite_line,  Prev: bmp_write_line,  Up: Direct

1.23.2 bmp_read_line
--------------------

unsigned long bmp_read_line(BITMAP *bmp, int line);
     Selects the line of a bitmap that you are going to read from.

     Returns the address of the selected line for reading.

See also:
*Note exflame::.
*Note BITMAP::.


File: allegro.info,  Node: bmp_unwrite_line,  Next: More on banked direct memory access,  Prev: bmp_read_line,  Up: Direct

1.23.3 bmp_unwrite_line
-----------------------

void bmp_unwrite_line(BITMAP *bmp);
     Releases the bitmap memory after you are finished with it.  You
     only need to call this once at the end of a drawing operation, even
     if you have called bmp_write_line() or bmp_read_line() several
     times before it.

See also:
*Note exflame::.
*Note exlights::.
*Note BITMAP::.


File: allegro.info,  Node: More on banked direct memory access,  Next: play_fli,  Prev: bmp_unwrite_line,  Up: Direct

1.23.4 More on banked direct memory access
------------------------------------------

Although SVGA bitmaps are banked, Allegro provides linear access to the
memory within each scanline, so you only need to pass a y coordinate to
these functions.  Various x positions can be obtained by simply adding
the x coordinate to the returned address.  The return value is an
unsigned long rather than a char pointer because the bitmap memory may
not be in your data segment, and you need to access it with far
pointers.  For example, a putpixel using the bank switching functions
is:

     void banked_putpixel(BITMAP *bmp, int x, int y, int color)
     {
        unsigned long address = bmp_write_line(bmp, y);
        bmp_select(bmp);
        bmp_write8(address+x, color);
        bmp_unwrite_line(bmp);
     }

You will notice that Allegro provides separate functions for setting the
read and write banks.  It is important that you distinguish between
these, because on some graphics cards the banks can be set individually,
and on others the video memory is read and written at different
addresses.  Life is never quite as simple as we might wish it to be,
though (this is true even when we _aren't_ talking about graphics coding
:-) and so of course some cards only provide a single bank.  On these
the read and write bank functions will behave identically, so you
shouldn't assume that you can read from one part of video memory and
write to another at the same time.  You can call bmp_read_line(), and
read whatever you like from that line, and then call bmp_write_line()
with the same or a different line number, and write whatever you like to
this second line, but you mustn't call bmp_read_line() and
bmp_write_line() together and expect to be able to read one line and
write the other simultaneously.  It would be nice if this was possible,
but if you do it, your code won't work on single banked SVGA cards.

And then there's mode-X. If you've never done any mode-X graphics
coding, you probably won't understand this, but for those of you who
want to know how Allegro sets up the mode-X screen bitmaps, here goes...

The line pointers are still present, and they contain planar addresses,
ie.  the actual location at which you access the first pixel in the
line.  These addresses are guaranteed to be quad aligned, so you can
just set the write plane, divide your x coordinate by four, and add it
to the line pointer.  For example, a mode-X putpixel is:

     void modex_putpixel(BITMAP *b, int x, int y, int color)
     {
        outportw(0x3C4, (0x100<<(x&3))|2);
        bmp_select(bmp);
        bmp_write8((unsigned long)bmp->line[y]+(x>>2), color);
     }

Oh yeah: the DJGPP nearptr hack.  Personally I don't like this very much
because it disables memory protection and isn't portable to other
platforms, but a lot of people swear by it because it can give you
direct access to the screen memory via a normal C pointer.  Warning:
this method will only work with the DJGPP library, when using VGA 13h or
a linear framebuffer modes!

In your setup code:

     #include <sys/nearptr.h>

     unsigned char *screenmemory;
     unsigned long screen_base_addr;

     __djgpp_nearptr_enable();

     __dpmi_get_segment_base_address(screen->seg, &screen_base_addr);

     screenmemory = (unsigned char *)(screen_base_addr +
                                      screen->line[0] -
                                      __djgpp_base_address);

Then:

     void nearptr_putpixel(int x, int y, int color)
     {
        screenmemory[x + y*VIRTUAL_W] = color;
     }


File: allegro.info,  Node: FLIC,  Next: Sound,  Prev: Direct,  Up: API

1.24 FLIC routines
==================

There are two high level functions for playing FLI/FLC animations:
play_fli(), which reads the data directly from disk, and
play_memory_fli(), which uses data that has already been loaded into
RAM. Apart from the different sources of the data, these two functions
behave identically.  They draw the animation onto the specified bitmap,
which should normally be the screen.  Frames will be aligned with the
top left corner of the bitmap: if you want to position them somewhere
else you will need to create a sub-bitmap for the FLI player to draw
onto.

If the callback function is not NULL it will be called once for each
frame, allowing you to perform background tasks of your own.  This
callback should normally return zero: if it returns non-zero the player
will terminate (this is the only way to stop an animation that is
playing in looped mode).

The FLI player returns FLI_OK if it reached the end of the file,
FLI_ERROR if something went wrong, and the value returned by the
callback function if that was what stopped it.  If you need to
distinguish between different return values, your callback should return
positive integers, since FLI_OK is zero and FLI_ERROR is negative.

Note that the FLI player will only work when the timer module is
installed, and that it will alter the palette according to whatever
palette data is present in the animation file.

Occasionally you may need more detailed control over how an FLI is
played, for example if you want to superimpose a text scroller on top of
the animation, or to play it back at a different speed.  You could do
both of these with the lower level functions described below.

* Menu:

* play_fli::
* play_memory_fli::
* open_fli::
* close_fli::
* next_fli_frame::
* fli_bitmap::
* fli_palette::
* fli_bmp_dirty_from::
* fli_pal_dirty_from::
* reset_fli_variables::
* fli_frame::
* fli_timer::


File: allegro.info,  Node: play_fli,  Next: play_memory_fli,  Prev: More on banked direct memory access,  Up: FLIC

1.24.1 play_fli
---------------

int play_fli(const char *filename, BITMAP *bmp, int loop, int (*callback)());
     Plays an Autodesk Animator FLI or FLC animation file on the
     specified BITMAP, reading the data from disk as it is required.  If
     'loop' is not zero, the player will cycle when it reaches the end
     of the file, otherwise it will play through the animation once and
     then return.  Read the beginning of chapter "FLIC routines" for a
     description of the callback parameter.  Example:

          /* Let users skip looped animations. */
          int check_escape_key(void)
          {
             if (key[KEY_ESC])
                return 1;
             else
                return 0;
          }
          ...
             int ret = play_fli("animlogo.fli", screen, 1,
                                 check_escape_key);
             if (ret == FLI_ERROR)
                abort_on_error("Error playing intro!");

     The FLI player returns FLI_OK if it reached the end of the file,
     FLI_ERROR if something went wrong, and the value returned by the
     callback function if that was what stopped it.

See also:
*Note play_memory_fli::.
*Note install_timer::.
*Note fli_frame::.
*Note BITMAP::.


File: allegro.info,  Node: play_memory_fli,  Next: open_fli,  Prev: play_fli,  Up: FLIC

1.24.2 play_memory_fli
----------------------

int play_memory_fli(const void *fli_data, BITMAP *bmp, int loop, int (*callback)());
     Plays an Autodesk Animator FLI or FLC animation on the specified
     BITMAP, reading the data from a copy of the file which is held in
     memory.  You can obtain the 'fli_data' pointer by allocating a
     block of memory and reading an FLI file into it, or by importing an
     FLI into a grabber datafile.  If 'loop' is not zero, the player
     will cycle when it reaches the end of the file, otherwise it will
     play through the animation once and then return.  Read the
     beginning of chapter "FLIC routines" for a description of the
     callback parameter.

     Playing animations from memory is obviously faster than cuing them
     directly from disk, and is particularly useful with short, looped
     FLI's.  Animations can easily get very large, though, so in most
     cases you will probably be better just using play_fli().  You can
     think of this function as a wrapper on top of open_memory_fli(),
     next_fli_frame() and close_fli().  Example:

          int ret = play_memory_fli(anim_data, screen, 0, NULL);
          if (ret == FLI_ERROR)
             abort_on_error("Corrupted animation data?");

     The FLI player returns FLI_OK if it reached the end of the file,
     FLI_ERROR if something went wrong, and the value returned by the
     callback function if that was what stopped it.

See also:
*Note play_fli::.
*Note install_timer::.
*Note fli_frame::.
*Note BITMAP::.


File: allegro.info,  Node: open_fli,  Next: close_fli,  Prev: play_memory_fli,  Up: FLIC

1.24.3 open_fli
---------------

int open_fli(const char *filename);
int open_memory_fli(const void *fli_data);
     Open FLI files ready for playing, reading the data from disk or
     memory respectively.  Information about the current FLI is held in
     the global variables fli_bitmap and fli_palette, which you can use
     if this function succeeds.  However, you can only have one
     animation open at a time.  Example:

          if (open_fli("intro.fli") == FLI_ERROR)
             abort_on_error("Error playing intro");

     Returns FLI_OK on success, FLI_ERROR if something went wrong, like
     trying to open another FLI file without closing the previous one.

See also:
*Note close_fli::.
*Note next_fli_frame::.
*Note fli_bitmap::.
*Note fli_palette::.


File: allegro.info,  Node: close_fli,  Next: next_fli_frame,  Prev: open_fli,  Up: FLIC

1.24.4 close_fli
----------------

void close_fli();
     Closes an FLI file when you have finished reading from it.
     Remember to do this to avoid having memory leaks in your program.

See also:
*Note open_fli::.


File: allegro.info,  Node: next_fli_frame,  Next: fli_bitmap,  Prev: close_fli,  Up: FLIC

1.24.5 next_fli_frame
---------------------

int next_fli_frame(int loop);
     Reads the next frame of the current animation file.  If 'loop' is
     not zero, the player will cycle when it reaches the end of the
     file, otherwise it will return FLI_EOF. The frame is read into the
     global variables fli_bitmap and fli_palette.  Example:

          while (next_fli_frame(0) == FLI_OK) {
             /* Do stuff, like play audio stream
                or check keys to skip animation. */
             /* Rest some time until next frame... */
          }

     Returns FLI_OK on success, FLI_ERROR or FLI_NOT_OPEN on error, and
     FLI_EOF on reaching the end of the file.

See also:
*Note open_fli::.
*Note fli_bitmap::.
*Note fli_palette::.
*Note fli_timer::.
*Note fli_frame::.


File: allegro.info,  Node: fli_bitmap,  Next: fli_palette,  Prev: next_fli_frame,  Up: FLIC

1.24.6 fli_bitmap
-----------------

extern BITMAP *fli_bitmap;
     Contains the current frame of the FLI/FLC animation.  If there is
     no open animation, its value will be NULL.

See also:
*Note next_fli_frame::.
*Note fli_bmp_dirty_from::.
*Note fli_palette::.
*Note BITMAP::.


File: allegro.info,  Node: fli_palette,  Next: fli_bmp_dirty_from,  Prev: fli_bitmap,  Up: FLIC

1.24.7 fli_palette
------------------

extern PALETTE fli_palette;
     Contains the current FLI palette.

See also:
*Note next_fli_frame::.
*Note fli_pal_dirty_from::.
*Note fli_bitmap::.
*Note PALETTE::.


File: allegro.info,  Node: fli_bmp_dirty_from,  Next: fli_pal_dirty_from,  Prev: fli_palette,  Up: FLIC

1.24.8 fli_bmp_dirty_from
-------------------------

extern int fli_bmp_dirty_from;
extern int fli_bmp_dirty_to;
     These variables are set by next_fli_frame() to indicate which part
     of the fli_bitmap has changed since the last call to
     reset_fli_variables().  If fli_bmp_dirty_from is greater than
     fli_bmp_dirty_to, the bitmap has not changed, otherwise lines
     fli_bmp_dirty_from to fli_bmp_dirty_to (inclusive) have altered.
     You can use these when copying the fli_bitmap onto the screen, to
     avoid moving data unnecessarily.  Example:

          if (fli_bmp_dirty_from <= fli_bmp_dirty_to)
             blit(fli_bitmap, screen, 0, fli_bmp_dirty_from,
                  0, fli_bmp_dirty_from, fli_bitmap->w,
                  fli_bmp_dirty_to - fli_bmp_dirty_from + 1);

See also:
*Note fli_bitmap::.
*Note reset_fli_variables::.


File: allegro.info,  Node: fli_pal_dirty_from,  Next: reset_fli_variables,  Prev: fli_bmp_dirty_from,  Up: FLIC

1.24.9 fli_pal_dirty_from
-------------------------

extern int fli_pal_dirty_from;
extern int fli_pal_dirty_to;
     These variables are set by next_fli_frame() to indicate which part
     of the fli_palette has changed since the last call to
     reset_fli_variables().  If fli_pal_dirty_from is greater than
     fli_pal_dirty_to, the palette has not changed, otherwise colors
     fli_pal_dirty_from to fli_pal_dirty_to (inclusive) have altered.
     You can use these when updating the hardware palette, to avoid
     unnecessary calls to set_palette().  Example:

          if (fli_pal_dirty_from <= fli_pal_dirty_to)
             set_palette_range(fli_palette, fli_pal_dirty_from,
                               fli_pal_dirty_to, 1);

See also:
*Note fli_palette::.
*Note reset_fli_variables::.


File: allegro.info,  Node: reset_fli_variables,  Next: fli_frame,  Prev: fli_pal_dirty_from,  Up: FLIC

1.24.10 reset_fli_variables
---------------------------

void reset_fli_variables();
     Once you have done whatever you are going to do with the fli_bitmap
     and fli_palette, call this function to reset the fli_bmp_dirty_*
     and fli_pal_dirty_* variables.

See also:
*Note fli_bmp_dirty_from::.
*Note fli_pal_dirty_from::.


File: allegro.info,  Node: fli_frame,  Next: fli_timer,  Prev: reset_fli_variables,  Up: FLIC

1.24.11 fli_frame
-----------------

extern int fli_frame;
     Global variable containing the current frame number in the FLI
     file.  This is useful for synchronising other events with the
     animation, for instance you could check it in a play_fli() callback
     function and use it to trigger a sample at a particular point.
     Example:

          while (next_fli_frame(0) == FLI_OK) {
             if (fli_frame == 345)
                play_sample(trumpet_sound, 255, 128, 1000, 0);
             /* Rest some time until next frame... */
          }

See also:
*Note play_fli::.
*Note play_memory_fli::.
*Note next_fli_frame::.


File: allegro.info,  Node: fli_timer,  Next: detect_digi_driver,  Prev: fli_frame,  Up: FLIC

1.24.12 fli_timer
-----------------

extern volatile int fli_timer;
     Global variable for timing FLI playback.  When you open an FLI
     file, a timer interrupt is installed which increments this variable
     every time a new frame should be displayed.  Calling
     next_fli_frame() decrements it, so you can test it and know that it
     is time to display a new frame if it is greater than zero.
     Example:

          while (next_fli_frame(0) == FLI_OK) {
             /* Do stuff, like play audio stream
                or check keys to skip animation. */
             /* Rest some time until next frame... */
             while (fli_timer <= 0)
                rest(0);
          }

See also:
*Note install_timer::.
*Note next_fli_frame::.


File: allegro.info,  Node: Sound,  Next: Mixer,  Prev: FLIC,  Up: API

1.25 Sound init routines
========================

Allegro allows you to use the sound hardware in two ways: automatic, or
manual.  Usually you should try the automatic version first.  This means
calling install_sound() with the autodetection parameters and using the
rest of the sound functions to play samples or music.  In this
situation, Allegro will handle the sound devices and mix the samples
and/or music the best way it can.

However, sound hardware has a limitation on the number of samples it may
play all at the same time (from now on, called hardware voices).  When
you exceed this limit, Allegro will cut off one of the samples being
played and reproduce the new one.  Depending on the type of sounds you
are playing, how many of them you need at the same time and their nature
(e.g: vital audio feedback to the user or useless "ping" when some
shrapnel hits a rock in the scenery) you will want to specify more
carefully how hardware voices are reserved and which samples have
priority over others.

The hardware voice reservation phase has to be done before the call to
install_sound(), since it directly affects how Allegro talks to the
sound drivers.

* Menu:

* detect_digi_driver::
* detect_midi_driver::
* reserve_voices::
* set_volume_per_voice::
* install_sound::
* remove_sound::
* set_volume::
* set_hardware_volume::
* get_volume::
* get_hardware_volume::


File: allegro.info,  Node: detect_digi_driver,  Next: detect_midi_driver,  Prev: fli_timer,  Up: Sound

1.25.1 detect_digi_driver
-------------------------

int detect_digi_driver(int driver_id);
     Detects whether the specified digital sound device is available.
     This function must be called _before_ install_sound().

     Returns the maximum number of voices that the driver can provide,
     or zero if the hardware is not present.

See also:
*Note install_sound::.
*Note reserve_voices::.
*Note DIGI_*/DOS::.
*Note DIGI_*/Windows::.
*Note DIGI_*/Unix::.
*Note DIGI_*/BeOS::.
*Note DIGI_*/QNX::.
*Note DIGI_*/MacOSX::.


File: allegro.info,  Node: detect_midi_driver,  Next: reserve_voices,  Prev: detect_digi_driver,  Up: Sound

1.25.2 detect_midi_driver
-------------------------

int detect_midi_driver(int driver_id);
     Detects whether the specified MIDI sound device is available.  This
     function must be called _before_ install_sound().

     Returns the maximum number of voices that the driver can provide,
     or zero if the hardware is not present.

     There are two special-case return values that you should watch out
     for: if this function returns -1 it is a note-stealing driver (eg.
     DIGMID) that shares voices with the current digital sound driver,
     and if it returns 0xFFFF it is an external device like an MPU-401
     where there is no way to determine how many voices are available.

See also:
*Note install_sound::.
*Note reserve_voices::.
*Note MIDI_*/DOS::.
*Note MIDI_*/Windows::.
*Note MIDI_*/Unix::.
*Note MIDI_*/BeOS::.
*Note MIDI_*/QNX::.
*Note MIDI_*/MacOSX::.


File: allegro.info,  Node: reserve_voices,  Next: set_volume_per_voice,  Prev: detect_midi_driver,  Up: Sound

1.25.3 reserve_voices
---------------------

void reserve_voices(int digi_voices, int midi_voices);
     Call this function to specify the number of voices that are to be
     used by the digital and MIDI sound drivers respectively.  This must
     be done _before_ calling install_sound().  If you reserve too many
     voices, subsequent calls to install_sound() will fail.  How many
     voices are available depends on the driver, and in some cases you
     will actually get more than you reserve (eg.  the FM synth drivers
     will always provide 9 voices on an OPL2 and 18 on an OPL3, and the
     SB digital driver will round the number of voices up to the nearest
     power of two).  Pass negative values to restore the default
     settings.  You should be aware that the sound quality is usually
     inversely related to how many voices you use, so don't reserve any
     more than you really need.

See also:
*Note set_volume_per_voice::.
*Note install_sound::.
*Note detect_digi_driver::.
*Note detect_midi_driver::.
*Note get_mixer_voices::.


File: allegro.info,  Node: set_volume_per_voice,  Next: install_sound,  Prev: reserve_voices,  Up: Sound

1.25.4 set_volume_per_voice
---------------------------

void set_volume_per_voice(int scale);
     By default, Allegro will play a centered sample at half volume on
     both the left and right channel.  A sample panned to the far right
     or left will be played at maximum volume on that channel only.
     This is done so you can play a single panned sample without
     distortion.  If you play multiple samples at full volume, the
     mixing process can result in clipping, a noticeable form of
     distortion.  The more samples, the more likely clipping is to
     occur, and the more clipping, the worse the output will sound.

     If clipping is a problem - or if the output is too quiet - this
     function can be used to adjust the volume of each voice.  You
     should first check that your speakers are at a reasonable volume,
     Allegro's global volume is at maximum (see set_volume() below), and
     any other mixers such as the Windows Volume Control are set
     reasonably.  Once you are sure that Allegro's output level is
     unsuitable for your application, use this function to adjust it.

     Each time you increase the parameter by one, the volume of each
     voice will halve.  For example, if you pass 4, you can play up to
     16 centred samples at maximum volume without distortion.

     If you pass 0 to this function, each centred sample will play at
     the maximum volume possible without distortion, as will all samples
     played through a mono driver.  Samples at the extreme left and
     right will distort if played at full volume.  If you wish to play
     panned samples at full volume without distortion, you should pass 1
     to this function.  Note: this is different from the function's
     behaviour in WIPs 3.9.34, 3.9.35 and 3.9.36.  If you used this
     function under one of these WIPs, you will have to increase your
     parameter by one to get the same volume.

     Note: The default behaviour has changed as of Allegro 4.1.15.  If
     you would like the behaviour of earlier versions of Allegro, pass
     -1 to this function.  Allegro will choose a value dependent on the
     number of voices, so that if you reserve n voices, you can play up
     to n/2 normalised samples with centre panning without risking
     distortion.  The exception is when you have fewer than 8 voices,
     where the volume remains the same as for 8 voices.  Here are the
     values, dependent on the number of voices:

          1-8 voices - set_volume_per_voice(2)
           16 voices - set_volume_per_voice(3)
           32 voices - set_volume_per_voice(4)
           64 voices - set_volume_per_voice(5)

     Of course this function does not override the volume you specify
     with play_sample() or voice_set_volume().  It simply alters the
     overall output of the program.  If you play samples at lower
     volumes, or if they are not normalised, then you can play more of
     them without distortion.

     It is recommended that you hard-code the parameter into your
     program, rather than offering it to the user.  The user can alter
     the volume with the configuration file instead, or you can provide
     for this with set_volume().

     To restore volume per voice to its default behaviour, pass 1.

See also:
*Note reserve_voices::.
*Note set_volume::.
*Note install_sound::.
*Note detect_digi_driver::.
*Note detect_midi_driver::.


File: allegro.info,  Node: install_sound,  Next: remove_sound,  Prev: set_volume_per_voice,  Up: Sound

1.25.5 install_sound
--------------------

int install_sound(int digi, int midi, const char *cfg_path);
     Initialises the sound module.  You should normally pass
     DIGI_AUTODETECT and MIDI_AUTODETECT as the driver parameters to
     this function, in which case Allegro will read hardware settings
     from the current configuration file.  This allows the user to
     select different values with the setup utility: see the config
     section for details.  Alternatively, see the platform specific
     documentation for a list of the available drivers.  The cfg_path
     parameter is only present for compatibility with previous versions
     of Allegro, and has no effect on anything.

     Returns zero if the sound is successfully installed, and -1 on
     failure.  If it fails it will store a description of the problem in
     allegro_error.

See also:
*Note remove_sound::.
*Note reserve_voices::.
*Note detect_digi_driver::.
*Note detect_midi_driver::.
*Note set_volume::.
*Note play_sample::.
*Note Voice control::.
*Note play_midi::.
*Note play_audio_stream::.
*Note install_sound_input::.
*Note allegro_error::.
*Note Standard config variables::.
*Note set_mixer_quality::.
*Note DIGI_*/DOS::.
*Note DIGI_*/Windows::.
*Note DIGI_*/Unix::.
*Note DIGI_*/BeOS::.
*Note DIGI_*/QNX::.
*Note DIGI_*/MacOSX::.
*Note MIDI_*/DOS::.
*Note MIDI_*/Windows::.
*Note MIDI_*/Unix::.
*Note MIDI_*/BeOS::.
*Note MIDI_*/QNX::.
*Note MIDI_*/MacOSX::.
*Note exmidi::.
*Note exsample::.
*Note exsprite::.
*Note exstream::.


File: allegro.info,  Node: remove_sound,  Next: set_volume,  Prev: install_sound,  Up: Sound

1.25.6 remove_sound
-------------------

void remove_sound();
     Cleans up after you are finished with the sound routines.  You
     don't normally need to call this, because allegro_exit() will do it
     for you.

See also:
*Note install_sound::.
*Note allegro_exit::.


File: allegro.info,  Node: set_volume,  Next: set_hardware_volume,  Prev: remove_sound,  Up: Sound

1.25.7 set_volume
-----------------

void set_volume(int digi_volume, int midi_volume);
     Alters the global sound output volume.  Specify volumes for both
     digital samples and MIDI playback, as integers from 0 to 255, or
     pass a negative value to leave one of the settings unchanged.
     Values bigger than 255 will be reduced to 255.  This routine will
     not alter the volume of the hardware mixer if it exists (i.e.  only
     your application will be affected).

See also:
*Note install_sound::.
*Note set_hardware_volume::.


File: allegro.info,  Node: set_hardware_volume,  Next: get_volume,  Prev: set_volume,  Up: Sound

1.25.8 set_hardware_volume
--------------------------

void set_hardware_volume(int digi_volume, int midi_volume);
     Alters the hardware sound output volume.  Specify volumes for both
     digital samples and MIDI playback, as integers from 0 to 255, or
     pass a negative value to leave one of the settings unchanged.
     Values bigger than 255 will be reduced to 255.  This routine will
     use the hardware mixer to control the volume if it exists (i.e.
     the volume of all the applications on your machine will be
     affected), otherwise do nothing.

See also:
*Note install_sound::.
*Note set_volume::.


File: allegro.info,  Node: get_volume,  Next: get_hardware_volume,  Prev: set_hardware_volume,  Up: Sound

1.25.9 get_volume
-----------------

void get_volume(int *digi_volume, int *midi_volume);
     Retrieves the global sound output volume, both for digital samples
     and MIDI playback, as integers from 0 to 255.  Parameters
     digi_volume and midi_volume must be valid pointers to int, or NULL
     if not interested in specific value.

See also:
*Note set_volume::.
*Note get_hardware_volume::.


File: allegro.info,  Node: get_hardware_volume,  Next: set_mixer_quality,  Prev: get_volume,  Up: Sound

1.25.10 get_hardware_volume
---------------------------

void get_hardware_volume(int *digi_volume, int *midi_volume);
     Retrieves the hardware sound output volume, both for digital
     samples and MIDI playback, as integers from 0 to 255, or -1 if the
     information is not available.  Parameters digi_volume and
     midi_volume must be valid pointers to int, or NULL if not
     interested in specific value.

See also:
*Note set_hardware_volume::.
*Note get_volume::.


File: allegro.info,  Node: Mixer,  Next: Digital,  Prev: Sound,  Up: API

1.26 Mixer routines
===================

* Menu:

* set_mixer_quality::
* get_mixer_quality::
* get_mixer_frequency::
* get_mixer_bits::
* get_mixer_channels::
* get_mixer_voices::
* get_mixer_buffer_length::


File: allegro.info,  Node: set_mixer_quality,  Next: get_mixer_quality,  Prev: get_hardware_volume,  Up: Mixer

1.26.1 set_mixer_quality
------------------------

void set_mixer_quality(int quality);
     Sets the resampling quality of the mixer.  Valid values are the
     same as the 'quality' config variable.  Please read chapter
     "Standard config variables" for details.  You can call this
     function at any point in your program, even before allegro_init().

See also:
*Note get_mixer_quality::.
*Note Standard config variables::.


File: allegro.info,  Node: get_mixer_quality,  Next: get_mixer_frequency,  Prev: set_mixer_quality,  Up: Mixer

1.26.2 get_mixer_quality
------------------------

int get_mixer_quality(void);
     Returns the current mixing quality, as specified by the 'quality'
     config variable, or a previous call to set_mixer_quality().

See also:
*Note set_mixer_quality::.
*Note Standard config variables::.


File: allegro.info,  Node: get_mixer_frequency,  Next: get_mixer_bits,  Prev: get_mixer_quality,  Up: Mixer

1.26.3 get_mixer_frequency
--------------------------

int get_mixer_frequency(void);
     Returns the mixer frequency, in Hz.

See also:
*Note Standard config variables::.


File: allegro.info,  Node: get_mixer_bits,  Next: get_mixer_channels,  Prev: get_mixer_frequency,  Up: Mixer

1.26.4 get_mixer_bits
---------------------

int get_mixer_bits(void);
     Returns the mixer bit depth (8 or 16).

See also:
*Note Standard config variables::.


File: allegro.info,  Node: get_mixer_channels,  Next: get_mixer_voices,  Prev: get_mixer_bits,  Up: Mixer

1.26.5 get_mixer_channels
-------------------------

int get_mixer_channels(void);
     Returns the number of output channels.  2 for stereo, 1 for mono, 0
     if the mixer isn't active.

See also:
*Note Standard config variables::.


File: allegro.info,  Node: get_mixer_voices,  Next: get_mixer_buffer_length,  Prev: get_mixer_channels,  Up: Mixer

1.26.6 get_mixer_voices
-----------------------

int get_mixer_voices(void);
     Returns the number of voices allocated to the mixer.

See also:
*Note reserve_voices::.


File: allegro.info,  Node: get_mixer_buffer_length,  Next: load_sample,  Prev: get_mixer_voices,  Up: Mixer

1.26.7 get_mixer_buffer_length
------------------------------

int get_mixer_buffer_length(void);
     Returns the number of samples per channel in the mixer buffer.

See also:
*Note Standard config variables::.


File: allegro.info,  Node: Digital,  Next: Music,  Prev: Mixer,  Up: API

1.27 Digital sample routines
============================

* Menu:

* load_sample::
* load_wav::
* load_wav_pf::
* load_voc::
* load_voc_pf::
* save_sample::
* create_sample::
* destroy_sample::
* lock_sample::
* register_sample_file_type::
* play_sample::
* adjust_sample::
* stop_sample::
* Voice control::
* allocate_voice::
* deallocate_voice::
* reallocate_voice::
* release_voice::
* voice_start::
* voice_stop::
* voice_set_priority::
* voice_check::
* voice_get_position::
* voice_set_position::
* voice_set_playmode::
* voice_get_volume::
* voice_set_volume::
* voice_ramp_volume::
* voice_stop_volumeramp::
* voice_get_frequency::
* voice_set_frequency::
* voice_sweep_frequency::
* voice_stop_frequency_sweep::
* voice_get_pan::
* voice_set_pan::
* voice_sweep_pan::
* voice_stop_pan_sweep::
* voice_set_echo::
* voice_set_tremolo::
* voice_set_vibrato::


File: allegro.info,  Node: load_sample,  Next: load_wav,  Prev: get_mixer_buffer_length,  Up: Digital

1.27.1 load_sample
------------------

SAMPLE *load_sample(const char *filename);
     Loads a sample from a file, supporting both mono and stereo WAV and
     mono VOC files, in 8 or 16-bit formats, as well as formats handled
     by functions registered using register_sample_file_type().
     Example:

          SAMPLE *sample = load_sample(user_input);
          if (!sample)
             abort_on_error("Couldn't load sample!");

     Returns a pointer to the SAMPLE or NULL on error.  Remember to free
     this sample later to avoid memory leaks.

See also:
*Note destroy_sample::.
*Note load_voc::.
*Note load_wav::.
*Note play_sample::.
*Note save_sample::.
*Note register_sample_file_type::.
*Note Voice control::.
*Note exsample::.
*Note SAMPLE::.


File: allegro.info,  Node: load_wav,  Next: load_wav_pf,  Prev: load_sample,  Up: Digital

1.27.2 load_wav
---------------

SAMPLE *load_wav(const char *filename);
     Loads a sample from a RIFF WAV file.  Example:

          SAMPLE *sample = load_wav("scream.wav");
          if (!sample)
             abort_on_error("Couldn't scare user!");

     Returns a pointer to the SAMPLE or NULL on error.  Remember to free
     this sample later to avoid memory leaks.

See also:
*Note load_sample::.
*Note register_sample_file_type::.
*Note SAMPLE::.


File: allegro.info,  Node: load_wav_pf,  Next: load_voc,  Prev: load_wav,  Up: Digital

1.27.3 load_wav_pf
------------------

SAMPLE *load_wav_pf(PACKFILE *f);
     A version of load_wav() which reads from a packfile.  Example:

          PACKFILE *packfile;
          SAMPLE *sample;

          packfile = pack_fopen("sound.wav", F_READ);
          if (!packfile)
             abort_on_error("Couldn't open sound.wav");

          sample = load_wav_pf(packfile);
          if (!sample)
             abort_on_error("Error loading sound.wav");

     Returns a pointer to the SAMPLE or NULL on error.  Remember to free
     this sample later to avoid memory leaks.

See also:
*Note load_wav::.
*Note SAMPLE::.
*Note PACKFILE::.


File: allegro.info,  Node: load_voc,  Next: load_voc_pf,  Prev: load_wav_pf,  Up: Digital

1.27.4 load_voc
---------------

SAMPLE *load_voc(const char *filename);
     Loads a sample from a Creative Labs VOC file.  Example:

          SAMPLE *sample = load_voc("alarm.voc");
          if (!sample)
             abort_on_error("Couldn't alert user!");

     Returns a pointer to the SAMPLE or NULL on error.  Remember to free
     this sample later to avoid memory leaks.

See also:
*Note load_sample::.
*Note register_sample_file_type::.
*Note SAMPLE::.


File: allegro.info,  Node: load_voc_pf,  Next: save_sample,  Prev: load_voc,  Up: Digital

1.27.5 load_voc_pf
------------------

SAMPLE *load_voc_pf(PACKFILE *f);
     A version of load_voc() which reads from a packfile.  Example:

          PACKFILE *packfile;
          SAMPLE *sample;

          packfile = pack_fopen("sound.wav", F_READ);
          if (!packfile)
             abort_on_error("Couldn't open sound.wav");

          sample = load_wav_pf(packfile);
          if (!sample)
             abort_on_error("Error loading sound.wav");

     Returns a pointer to the SAMPLE or NULL on error.  Remember to free
     this sample later to avoid memory leaks.

See also:
*Note load_voc::.
*Note SAMPLE::.
*Note PACKFILE::.


File: allegro.info,  Node: save_sample,  Next: create_sample,  Prev: load_voc_pf,  Up: Digital

1.27.6 save_sample
------------------

int save_sample(const char *filename, SAMPLE *spl);
     Writes a sample into a file.  The output format is determined from
     the filename extension.  At present Allegro does not natively
     support the writing of any sample formats, so you must register a
     custom saver routine with register_sample_file_type().  Example:

          if (save_sample("sound.wav", sample) != 0)
             abort_on_error("Couldn't save sample!");

     Returns zero on success, non-zero otherwise.

See also:
*Note load_sample::.
*Note register_sample_file_type::.
*Note SAMPLE::.


File: allegro.info,  Node: create_sample,  Next: destroy_sample,  Prev: save_sample,  Up: Digital

1.27.7 create_sample
--------------------

SAMPLE *create_sample(int bits, int stereo, int freq, int len);
     Constructs a new sample structure of the specified type.  Read
     chapter "Structures and types defined by Allegro" for an internal
     description of the SAMPLE structure.  The 'bits' parameter can be 8
     or 16, 'stereo' can be zero for mono samples and non-zero for
     stereo samples, 'freq' is the frequency in hertz, and 'len' is the
     number of samples you want to allocate for the full sound buffer.

     Returns a pointer to the created sample, or NULL if the sample
     could not be created.  Remember to free this sample later to avoid
     memory leaks.

See also:
*Note load_sample::.
*Note destroy_sample::.
*Note Structures and types defined by Allegro: Structures.
*Note SAMPLE::.


File: allegro.info,  Node: destroy_sample,  Next: lock_sample,  Prev: create_sample,  Up: Digital

1.27.8 destroy_sample
---------------------

void destroy_sample(SAMPLE *spl);
     Destroys a sample structure when you are done with it.  It is safe
     to call this even when the sample might be playing, because it
     checks and will kill it off if it is active.  Use this to avoid
     memory leaks in your program.

See also:
*Note load_sample::.
*Note exsample::.
*Note SAMPLE::.


File: allegro.info,  Node: lock_sample,  Next: register_sample_file_type,  Prev: destroy_sample,  Up: Digital

1.27.9 lock_sample
------------------

void lock_sample(SAMPLE *spl);
     Under DOS, locks all the memory used by a sample.  You don't
     normally need to call this function because load_sample() and
     create_sample() do it for you.

See also:
*Note load_sample::.
*Note create_sample::.
*Note SAMPLE::.


File: allegro.info,  Node: register_sample_file_type,  Next: play_sample,  Prev: lock_sample,  Up: Digital

1.27.10 register_sample_file_type
---------------------------------

void register_sample_file_type(const char *ext, SAMPLE *(*load)(const char *filename), int (*save)(const char *filename, SAMPLE *spl));
     Informs the load_sample() function of a new sample file type,
     providing routines to read and write samples in this format (either
     function may be NULL). Example:

          SAMPLE *load_mp3(const char *filename)
          {
             ...
          }

             register_sample_file_type("mp3", load_mp3, NULL);

See also:
*Note load_sample::.
*Note save_sample::.
*Note SAMPLE::.


File: allegro.info,  Node: play_sample,  Next: adjust_sample,  Prev: register_sample_file_type,  Up: Digital

1.27.11 play_sample
-------------------

int play_sample(const SAMPLE *spl, int vol, int pan, int freq, int loop);
     Triggers a sample at the specified volume, pan position, and
     frequency.  The parameters 'vol' and 'pan' range from 0 (min/left)
     to 255 (max/right).  Frequency is relative rather than absolute:
     1000 represents the frequency that the sample was recorded at, 2000
     is twice this, etc.  If 'loop' is not zero, the sample will repeat
     until you call stop_sample(), and can be manipulated while it is
     playing by calling adjust_sample().  Example:

          /* Scream from the left speaker, twice the freq. */
          int sound = play_sample(scream, 255, 0, 2000, 0);

     Returns the voice number that was allocated for the sample or
     negative if no voices were available.

See also:
*Note install_sound::.
*Note load_sample::.
*Note adjust_sample::.
*Note stop_sample::.
*Note Voice control::.
*Note exsample::.
*Note exsprite::.
*Note SAMPLE::.


File: allegro.info,  Node: adjust_sample,  Next: stop_sample,  Prev: play_sample,  Up: Digital

1.27.12 adjust_sample
---------------------

void adjust_sample(const SAMPLE *spl, int vol, int pan, int freq, int loop);
     Alters the parameters of a sample while it is playing (useful for
     manipulating looped sounds).  You can alter the volume, pan, and
     frequency, and can also clear the loop flag, which will stop the
     sample when it next reaches the end of its loop.  The values of the
     parameters are just like those of play_sample().  If there are
     several copies of the same sample playing, this will adjust the
     first one it comes across.  If the sample is not playing it has no
     effect.

See also:
*Note play_sample::.
*Note exsample::.
*Note SAMPLE::.


File: allegro.info,  Node: stop_sample,  Next: Voice control,  Prev: adjust_sample,  Up: Digital

1.27.13 stop_sample
-------------------

void stop_sample(const SAMPLE *spl);
     Stop a sample from playing, which is required if you have set a
     sample going in looped mode.  If there are several copies of the
     sample playing, it will stop them all.  You must still destroy the
     sample using destroy_sample().

See also:
*Note play_sample::.
*Note destroy_sample::.
*Note SAMPLE::.


File: allegro.info,  Node: Voice control,  Next: allocate_voice,  Prev: stop_sample,  Up: Digital

1.27.14 Voice control
---------------------

If you need more detailed control over how samples are played, you can
use the lower level voice functions rather than just calling
play_sample().  This is rather more work, because you have to explicitly
allocate and free the voices rather than them being automatically
released when they finish playing, but allows far more precise
specification of exactly how you want everything to sound.  You may also
want to modify a couple of fields from the SAMPLE structure.  Read
chapter "Structures and types defined by Allegro" for its definition.

See also:
*Note install_sound::.
*Note allocate_voice::.
*Note deallocate_voice::.
*Note reallocate_voice::.
*Note release_voice::.
*Note voice_start::.
*Note voice_set_priority::.
*Note voice_check::.
*Note voice_set_position::.
*Note voice_set_playmode::.
*Note voice_set_volume::.
*Note voice_set_frequency::.
*Note voice_set_pan::.
*Note SAMPLE::.


File: allegro.info,  Node: allocate_voice,  Next: deallocate_voice,  Prev: Voice control,  Up: Digital

1.27.15 allocate_voice
----------------------

int allocate_voice(const SAMPLE *spl);
     Allocates a sound card voice and prepares it for playing the
     specified sample, setting up sensible default parameters (maximum
     volume, centre pan, no change of pitch, no looping).  When you are
     finished with the voice you must free it by calling
     deallocate_voice() or release_voice().  Allegro can manage up to
     256 simultaneous voices, but that limit may be lower due to
     hardware reasons.

     Returns the voice number, or -1 if no voices are available.

See also:
*Note Voice control::.
*Note deallocate_voice::.
*Note reallocate_voice::.
*Note release_voice::.
*Note load_sample::.
*Note SAMPLE::.


File: allegro.info,  Node: deallocate_voice,  Next: reallocate_voice,  Prev: allocate_voice,  Up: Digital

1.27.16 deallocate_voice
------------------------

void deallocate_voice(int voice);
     Frees a sound card voice, stopping it from playing and releasing
     whatever resources it is using.

See also:
*Note allocate_voice::.
*Note voice_stop::.


File: allegro.info,  Node: reallocate_voice,  Next: release_voice,  Prev: deallocate_voice,  Up: Digital

1.27.17 reallocate_voice
------------------------

void reallocate_voice(int voice, const SAMPLE *spl);
     Switches an already-allocated voice to use a different sample.
     Calling reallocate_voice(voice, sample) is equivalent to:

          deallocate_voice(voice);
          voice = allocate_voice(sample);

See also:
*Note allocate_voice::.
*Note deallocate_voice::.
*Note load_sample::.
*Note SAMPLE::.


File: allegro.info,  Node: release_voice,  Next: voice_start,  Prev: reallocate_voice,  Up: Digital

1.27.18 release_voice
---------------------

void release_voice(int voice);
     Releases a sound card voice, indicating that you are no longer
     interested in manipulating it.  The sound will continue to play,
     and any resources that it is using will automatically be freed when
     it finishes.  This is essentially the same as deallocate_voice(),
     but it waits for the sound to stop playing before taking effect.

See also:
*Note allocate_voice::.
*Note deallocate_voice::.


File: allegro.info,  Node: voice_start,  Next: voice_stop,  Prev: release_voice,  Up: Digital

1.27.19 voice_start
-------------------

void voice_start(int voice);
     Activates a voice, using whatever parameters have been set for it.

See also:
*Note Voice control::.
*Note allocate_voice::.
*Note voice_stop::.
*Note release_voice::.
*Note exstream::.


File: allegro.info,  Node: voice_stop,  Next: voice_set_priority,  Prev: voice_start,  Up: Digital

1.27.20 voice_stop
------------------

void voice_stop(int voice);
     Stops a voice, storing the current position and state so that it
     may later be resumed by calling voice_start().

See also:
*Note voice_start::.
*Note deallocate_voice::.
*Note release_voice::.
*Note exstream::.


File: allegro.info,  Node: voice_set_priority,  Next: voice_check,  Prev: voice_stop,  Up: Digital

1.27.21 voice_set_priority
--------------------------

void voice_set_priority(int voice, int priority);
     Sets the priority of a voice (range 0-255).  This is used to decide
     which voices should be chopped off, if you attempt to play more
     than the sound card driver can handle.

See also:
*Note Voice control::.


File: allegro.info,  Node: voice_check,  Next: voice_get_position,  Prev: voice_set_priority,  Up: Digital

1.27.22 voice_check
-------------------

SAMPLE *voice_check(int voice);
     Checks whether a voice is currently allocated.

     Returns a pointer to the sample that the voice is using, or NULL if
     the voice is inactive (ie.  it has been deallocated, or the
     release_voice() function has been called and the sample has then
     finished playing).

See also:
*Note allocate_voice::.
*Note voice_start::.
*Note voice_get_position::.
*Note SAMPLE::.


File: allegro.info,  Node: voice_get_position,  Next: voice_set_position,  Prev: voice_check,  Up: Digital

1.27.23 voice_get_position
--------------------------

int voice_get_position(int voice);
     Returns the current position of a voice, in sample units, or -1 if
     it has finished playing.

See also:
*Note Voice control::.
*Note voice_set_position::.


File: allegro.info,  Node: voice_set_position,  Next: voice_set_playmode,  Prev: voice_get_position,  Up: Digital

1.27.24 voice_set_position
--------------------------

void voice_set_position(int voice, int position);
     Sets the position of a voice, in sample units.

See also:
*Note Voice control::.
*Note voice_get_position::.
*Note voice_set_playmode::.


File: allegro.info,  Node: voice_set_playmode,  Next: voice_get_volume,  Prev: voice_set_position,  Up: Digital

1.27.25 voice_set_playmode
--------------------------

void voice_set_playmode(int voice, int playmode);
     Adjusts the loop status of the specified voice.  This can be done
     while the voice is playing, so you can start a sample in looped
     mode (having set the loop start and end positions to the
     appropriate values), and then clear the loop flag when you want to
     end the sound, which will cause it to continue past the loop end,
     play the subsequent part of the sample, and finish in the normal
     way.  The mode parameter is a bitfield containing the following
     values:

        * PLAYMODE_PLAY
          Plays the sample a single time.  This is the default if you
          don't set the loop flag.
        * PLAYMODE_LOOP
          Loops repeatedly through the sample, jumping back to the loop
          start position upon reaching the loop end.
        * PLAYMODE_FORWARD
          Plays the sample from beginning to end.  This is the default
          if you don't set the backward flag.
        * PLAYMODE_BACKWARD
          Reverses the direction of the sample.  If you combine this
          with the loop flag, the sample jumps to the loop end position
          upon reaching the loop start (ie.  you do not need to reverse
          the loop start and end values when you play the sample in
          reverse).
        * PLAYMODE_BIDIR
          When used in combination with the loop flag, causes the sample
          to change direction each time it reaches one of the loop
          points, so it alternates between playing forwards and in
          reverse.

See also:
*Note Voice control::.


File: allegro.info,  Node: voice_get_volume,  Next: voice_set_volume,  Prev: voice_set_playmode,  Up: Digital

1.27.26 voice_get_volume
------------------------

int voice_get_volume(int voice);
     Returns the current volume of the voice, range 0-255.  Otherwise it
     returns -1 if that cannot be determined (because it has finished or
     been preempted by a different sound).

See also:
*Note Voice control::.
*Note voice_set_volume::.


File: allegro.info,  Node: voice_set_volume,  Next: voice_ramp_volume,  Prev: voice_get_volume,  Up: Digital

1.27.27 voice_set_volume
------------------------

void voice_set_volume(int voice, int volume);
     Sets the volume of the voice, range 0-255.

See also:
*Note Voice control::.
*Note voice_get_volume::.
*Note voice_ramp_volume::.


File: allegro.info,  Node: voice_ramp_volume,  Next: voice_stop_volumeramp,  Prev: voice_set_volume,  Up: Digital

1.27.28 voice_ramp_volume
-------------------------

void voice_ramp_volume(int voice, int time, int endvol);
     Starts a volume ramp (crescendo or diminuendo) from the current
     volume to the specified ending volume, lasting for time
     milliseconds.  The volume is a value in the range 0-255.

See also:
*Note Voice control::.
*Note voice_set_volume::.


File: allegro.info,  Node: voice_stop_volumeramp,  Next: voice_get_frequency,  Prev: voice_ramp_volume,  Up: Digital

1.27.29 voice_stop_volumeramp
-----------------------------

void voice_stop_volumeramp(int voice);
     Interrupts a volume ramp operation.

See also:
*Note voice_ramp_volume::.


File: allegro.info,  Node: voice_get_frequency,  Next: voice_set_frequency,  Prev: voice_stop_volumeramp,  Up: Digital

1.27.30 voice_get_frequency
---------------------------

int voice_get_frequency(int voice);
     Returns the current pitch of the voice, in Hz.

See also:
*Note Voice control::.
*Note voice_set_frequency::.


File: allegro.info,  Node: voice_set_frequency,  Next: voice_sweep_frequency,  Prev: voice_get_frequency,  Up: Digital

1.27.31 voice_set_frequency
---------------------------

void voice_set_frequency(int voice, int frequency);
     Sets the pitch of the voice, in Hz.

See also:
*Note Voice control::.
*Note voice_get_frequency::.
*Note voice_sweep_frequency::.


File: allegro.info,  Node: voice_sweep_frequency,  Next: voice_stop_frequency_sweep,  Prev: voice_set_frequency,  Up: Digital

1.27.32 voice_sweep_frequency
-----------------------------

void voice_sweep_frequency(int voice, int time, int endfreq);
     Starts a frequency sweep (glissando) from the current pitch to the
     specified ending pitch, lasting for time milliseconds.

See also:
*Note Voice control::.
*Note voice_set_frequency::.


File: allegro.info,  Node: voice_stop_frequency_sweep,  Next: voice_get_pan,  Prev: voice_sweep_frequency,  Up: Digital

1.27.33 voice_stop_frequency_sweep
----------------------------------

void voice_stop_frequency_sweep(int voice);
     Interrupts a frequency sweep operation.

See also:
*Note voice_sweep_frequency::.


File: allegro.info,  Node: voice_get_pan,  Next: voice_set_pan,  Prev: voice_stop_frequency_sweep,  Up: Digital

1.27.34 voice_get_pan
---------------------

int voice_get_pan(int voice);
     Returns the current pan position, from 0 (left) to 255 (right).

See also:
*Note Voice control::.
*Note voice_set_pan::.


File: allegro.info,  Node: voice_set_pan,  Next: voice_sweep_pan,  Prev: voice_get_pan,  Up: Digital

1.27.35 voice_set_pan
---------------------

void voice_set_pan(int voice, int pan);
     Sets the pan position, ranging from 0 (left) to 255 (right).

See also:
*Note Voice control::.
*Note voice_get_pan::.
*Note voice_sweep_pan::.


File: allegro.info,  Node: voice_sweep_pan,  Next: voice_stop_pan_sweep,  Prev: voice_set_pan,  Up: Digital

1.27.36 voice_sweep_pan
-----------------------

void voice_sweep_pan(int voice, int time, int endpan);
     Starts a pan sweep (left <-> right movement) from the current
     position to the specified ending position, lasting for time
     milliseconds.

See also:
*Note Voice control::.
*Note voice_set_pan::.


File: allegro.info,  Node: voice_stop_pan_sweep,  Next: voice_set_echo,  Prev: voice_sweep_pan,  Up: Digital

1.27.37 voice_stop_pan_sweep
----------------------------

void voice_stop_pan_sweep(int voice);
     Interrupts a pan sweep operation.

See also:
*Note voice_sweep_pan::.


File: allegro.info,  Node: voice_set_echo,  Next: voice_set_tremolo,  Prev: voice_stop_pan_sweep,  Up: Digital

1.27.38 voice_set_echo
----------------------

void voice_set_echo(int voice, int strength, int delay);
     Sets the echo parameters for a voice (not currently implemented).

See also:
*Note Voice control::.


File: allegro.info,  Node: voice_set_tremolo,  Next: voice_set_vibrato,  Prev: voice_set_echo,  Up: Digital

1.27.39 voice_set_tremolo
-------------------------

void voice_set_tremolo(int voice, int rate, int depth);
     Sets the tremolo parameters for a voice (not currently
     implemented).

See also:
*Note Voice control::.


File: allegro.info,  Node: voice_set_vibrato,  Next: load_midi,  Prev: voice_set_tremolo,  Up: Digital

1.27.40 voice_set_vibrato
-------------------------

void voice_set_vibrato(int voice, int rate, int depth);
     Sets the vibrato parameters for a voice (not currently
     implemented).

See also:
*Note Voice control::.


File: allegro.info,  Node: Music,  Next: Audio,  Prev: Digital,  Up: API

1.28 Music routines (MIDI)
==========================

Allegro allows you to play MIDI files.  MIDI files basically contain
notes and the type of instrument that is meant to play them, so they are
usually very small in size.  However, it's up to the sound card of the
end user to play the notes, and sound cards have been historically known
to have poor MIDI performance (at least those oriented to the consumer
market).  Few consumer cards feature decent MIDI playback.  Still, as a
game creator you can never be sure if the music of your game will be
played as you meant it, because it totally depends on the hardware of
the user.

For this reason Allegro also provides a DIGMID driver.  This is a
software implementation of the so called Wavetable synthesis.  Sound
cards featuring this store digital samples of real instruments at
different pitches, interpolating those that are not recorded, thus
achieving a high sound quality.  Implementing this in software makes you
sure that the quality you hear on your computer is that which will be
heard by end users using the same driver.

The disadvantage of the DIGMID driver is that it uses more CPU than
simple MIDI playback, and it steals some hardware voices from the sound
card, which might be more critical for the end user experience than the
background music.  At the Allegro homepage
(http://alleg.sourceforge.net/) you can find more information about
DIGMID and where to download digital samples for your MIDI files.

* Menu:

* load_midi::
* destroy_midi::
* lock_midi::
* play_midi::
* play_looped_midi::
* stop_midi::
* midi_pause::
* midi_resume::
* midi_seek::
* get_midi_length::
* midi_out::
* load_midi_patches::
* midi_pos::
* midi_time::
* midi_loop_start::
* midi_msg_callback::
* load_ibk::


File: allegro.info,  Node: load_midi,  Next: destroy_midi,  Prev: voice_set_vibrato,  Up: Music

1.28.1 load_midi
----------------

MIDI *load_midi(const char *filename);
     Loads a MIDI file (handles both format 0 and format 1).  Example:

          MIDI *music;
          music = load_midi("backmus.mid");
          if (!music)
             abort_on_error("Couldn't load background music!");

     Returns a pointer to a MIDI structure, or NULL on error.  Remember
     to free this MIDI file later to avoid memory leaks.

See also:
*Note destroy_midi::.
*Note play_midi::.
*Note get_midi_length::.
*Note exmidi::.
*Note MIDI::.


File: allegro.info,  Node: destroy_midi,  Next: lock_midi,  Prev: load_midi,  Up: Music

1.28.2 destroy_midi
-------------------

void destroy_midi(MIDI *midi);
     Destroys a MIDI structure when you are done with it.  It is safe to
     call this even when the MIDI file might be playing, because it
     checks and will kill it off if it is active.  Use this to avoid
     memory leaks in your program.

See also:
*Note load_midi::.
*Note exmidi::.
*Note MIDI::.


File: allegro.info,  Node: lock_midi,  Next: play_midi,  Prev: destroy_midi,  Up: Music

1.28.3 lock_midi
----------------

void lock_midi(MIDI *midi);
     Under DOS, locks all the memory used by a MIDI file.  You don't
     normally need to call this function because load_midi() does it for
     you.

See also:
*Note load_midi::.
*Note MIDI::.


File: allegro.info,  Node: play_midi,  Next: play_looped_midi,  Prev: lock_midi,  Up: Music

1.28.4 play_midi
----------------

int play_midi(MIDI *midi, int loop);
     Starts playing the specified MIDI file, first stopping whatever
     music was previously playing.  If the loop flag is set to non-zero,
     the data will be repeated until replaced with something else,
     otherwise it will stop at the end of the file.  Passing a NULL
     pointer will stop whatever music is currently playing.

     Returns non-zero if an error occurs (this may happen if a
     patch-caching wavetable driver is unable to load the required
     samples, or at least it might in the future when somebody writes
     some patch-caching wavetable drivers :-)

See also:
*Note install_sound::.
*Note load_midi::.
*Note play_looped_midi::.
*Note stop_midi::.
*Note midi_pause::.
*Note midi_seek::.
*Note midi_pos::.
*Note midi_time::.
*Note midi_msg_callback::.
*Note exmidi::.
*Note MIDI::.


File: allegro.info,  Node: play_looped_midi,  Next: stop_midi,  Prev: play_midi,  Up: Music

1.28.5 play_looped_midi
-----------------------

int play_looped_midi(MIDI *midi, int loop_start, int loop_end);
     Starts playing a MIDI file with a user-defined loop position.  When
     the player reaches the loop end position or the end of the file
     (loop_end may be -1 to only loop at EOF), it will wind back to the
     loop start point.  Both positions are specified in the same beat
     number format as the midi_pos variable.

     The return value has the same meaning as that of play_midi():
     non-zero if an error occurs, zero otherwise.

See also:
*Note play_midi::.
*Note midi_pos::.
*Note midi_loop_start::.
*Note MIDI::.


File: allegro.info,  Node: stop_midi,  Next: midi_pause,  Prev: play_looped_midi,  Up: Music

1.28.6 stop_midi
----------------

void stop_midi();
     Stops whatever music is currently playing.  This is the same thing
     as calling play_midi(NULL, FALSE).

See also:
*Note play_midi::.
*Note midi_pause::.


File: allegro.info,  Node: midi_pause,  Next: midi_resume,  Prev: stop_midi,  Up: Music

1.28.7 midi_pause
-----------------

void midi_pause();
     Pauses the MIDI player.

See also:
*Note play_midi::.
*Note stop_midi::.
*Note midi_resume::.
*Note midi_seek::.
*Note exmidi::.


File: allegro.info,  Node: midi_resume,  Next: midi_seek,  Prev: midi_pause,  Up: Music

1.28.8 midi_resume
------------------

void midi_resume();
     Resumes playback of a paused MIDI file.

See also:
*Note midi_pause::.
*Note exmidi::.


File: allegro.info,  Node: midi_seek,  Next: get_midi_length,  Prev: midi_resume,  Up: Music

1.28.9 midi_seek
----------------

int midi_seek(int target);
     Seeks to the given midi_pos in the current MIDI file.  If the
     target is earlier in the file than the current midi_pos it seeks
     from the beginning; otherwise it seeks from the current position.

     Returns zero if it could successfully seek to the requested
     position.  Otherwise, a return value of 1 means it stopped playing,
     and midi_pos is set to the negative length of the MIDI file (so you
     can use this function to determine the length of a MIDI file).  A
     return value of 2 means the MIDI file looped back to the start.

See also:
*Note play_midi::.
*Note midi_pos::.


File: allegro.info,  Node: get_midi_length,  Next: midi_out,  Prev: midi_seek,  Up: Music

1.28.10 get_midi_length
-----------------------

int get_midi_length(MIDI *midi);
     This function will simulate playing the given MIDI, from start to
     end, to determine how long it takes to play.  After calling this
     function, midi_pos will contain the negative number of beats, and
     midi_time the length of the midi, in seconds.

     Note that any currently playing midi is stopped when you call this
     function.  Usually you would call it before play_midi, to get the
     length of the midi to be played, like in this example:

          length = get_midi_length(my_midi);
          play_midi(my_midi);
          do {
             pos = midi_time;
             textprintf_ex(screen, font, 0, 0, c, -1, "%d:%02d / %d:%02d\n",
                pos / 60, pos % 60, length / 60, length % 60);
             rest(100);
          } while(pos <= length);

     Returns the value of midi_time, the length of the midi.

See also:
*Note load_midi::.
*Note midi_time::.
*Note midi_pos::.
*Note exmidi::.
*Note MIDI::.


File: allegro.info,  Node: midi_out,  Next: load_midi_patches,  Prev: get_midi_length,  Up: Music

1.28.11 midi_out
----------------

void midi_out(unsigned char *data, int length);
     Streams a block of MIDI commands into the player in real-time,
     allowing you to trigger notes, jingles, etc, over the top of
     whatever MIDI file is currently playing.

See also:
*Note install_sound::.
*Note load_midi_patches::.
*Note midi_recorder::.


File: allegro.info,  Node: load_midi_patches,  Next: midi_pos,  Prev: midi_out,  Up: Music

1.28.12 load_midi_patches
-------------------------

int load_midi_patches();
     Forces the MIDI driver to load the entire set of patches ready for
     use.  You will not normally need to call this, because Allegro
     automatically loads whatever data is required for the current MIDI
     file, but you must call it before sending any program change
     messages via the midi_out() command.

     Returns non-zero if an error occurred.

See also:
*Note install_sound::.
*Note midi_out::.


File: allegro.info,  Node: midi_pos,  Next: midi_time,  Prev: load_midi_patches,  Up: Music

1.28.13 midi_pos
----------------

extern volatile long midi_pos;
     Stores the current position (beat number) in the MIDI file, or
     contains a negative number if no music is currently playing.
     Useful for synchronising animations with the music, and for
     checking whether a MIDI file has finished playing.

See also:
*Note play_midi::.
*Note midi_msg_callback::.
*Note exmidi::.


File: allegro.info,  Node: midi_time,  Next: midi_loop_start,  Prev: midi_pos,  Up: Music

1.28.14 midi_time
-----------------

extern volatile long midi_time;
     Contains the position in seconds in the currently playing midi.
     This is useful if you want to display the current song position in
     seconds, not as beat number.

See also:
*Note play_midi::.
*Note midi_pos::.
*Note get_midi_length::.
*Note exmidi::.


File: allegro.info,  Node: midi_loop_start,  Next: midi_msg_callback,  Prev: midi_time,  Up: Music

1.28.15 midi_loop_start
-----------------------

extern long midi_loop_start;
extern long midi_loop_end;
     The loop start and end points, set by the play_looped_midi()
     function.  These may safely be altered while the music is playing,
     but you should be sure they are always set to sensible values
     (start < end).  If you are changing them both at the same time,
     make sure to alter them in the right order in case a MIDI interrupt
     happens to occur in between your two writes!  Setting these values
     to -1 represents the start and end of the file respectively.

See also:
*Note play_looped_midi::.


File: allegro.info,  Node: midi_msg_callback,  Next: load_ibk,  Prev: midi_loop_start,  Up: Music

1.28.16 midi_msg_callback
-------------------------

extern void (*midi_msg_callback)(int msg, int byte1, int byte2);
extern void (*midi_meta_callback)(int type, const unsigned char *data, int length);
extern void (*midi_sysex_callback)(const unsigned char *data, int length);
     Hook functions allowing you to intercept MIDI player events.  If
     set to anything other than NULL, these routines will be called for
     each MIDI message, meta-event, and system exclusive data block
     respectively.  They will execute in an interrupt handler context,
     so all the code and data they use should be locked, and they must
     not call any operating system functions.  In general you just use
     these routines to set some flags and respond to them later in your
     mainline code.

See also:
*Note play_midi::.


File: allegro.info,  Node: load_ibk,  Next: play_audio_stream,  Prev: midi_msg_callback,  Up: Music

1.28.17 load_ibk
----------------

int load_ibk(char *filename, int drums);
     Reads in a .IBK patch definition file for use by the Adlib driver.
     If drums is set, it will load it as a percussion patch set,
     otherwise it will use it as a replacement set of General MIDI
     instruments.  You may call this before or after initialising the
     sound code, or can simply set the ibk_file and ibk_drum_file
     variables in the configuration file to have the data loaded
     automatically.  Note that this function has no effect on any
     drivers other than the Adlib one!

     Returns non-zero on error.

See also:
*Note install_sound::.


File: allegro.info,  Node: Audio,  Next: Recording,  Prev: Music,  Up: API

1.29 Audio stream routines
==========================

The audio stream functions are for playing digital sounds that are too
big to fit in a regular SAMPLE structure, either because they are huge
files that you want to load in pieces as the data is required, or
because you are doing something clever like generating the waveform on
the fly.

You can think of an AUDIOSTREAM structure as a wrapper around two audio
buffers.  The first thing you do is fill both buffers with sound data
and let Allegro play them.  Once the first buffer has been played, the
second starts, and Allegro lets you know you have to fill the other one
(i.e.  graphics double buffering applied to sounds too big to fit into
memory).

The implementation of the sound buffers uses normal SAMPLE structures,
so you can use all the voice_*() functions to modify the audio streams.
Read chapter "Digital sample routines", section "Voice control" for a
list of additional functions you can use.  Read chapter "Structures and
types defined by Allegro" for the internals of the AUDIOSTREAM
structure.

* Menu:

* play_audio_stream::
* stop_audio_stream::
* get_audio_stream_buffer::
* free_audio_stream_buffer::


File: allegro.info,  Node: play_audio_stream,  Next: stop_audio_stream,  Prev: load_ibk,  Up: Audio

1.29.1 play_audio_stream
------------------------

AUDIOSTREAM *play_audio_stream(int len, int bits, int stereo, int freq, int vol, int pan);
     This function creates a new audio stream and starts playing it.
     The length is the size of each transfer buffer in sample frames
     (not bytes), where a sample frame is a single sample value for mono
     data or a pair of interleaved sample values (left first) for stereo
     data.  The length should normally be (but doesn't have to be) a
     power of 2 somewhere around 1k in size.  Larger buffers are more
     efficient and require fewer updates, but result in more latency
     between you providing the data and it actually being played.

     The 'bits' parameter must be 8 or 16.  'freq' is the sample rate of
     the data in Hertz.  The 'vol' and 'pan' values use the same 0-255
     ranges as the regular sample playing functions.  The 'stereo'
     parameter should be set to 1 for stereo streams, or 0 otherwise.

     If you want to adjust the pitch, volume, or panning of a stream
     once it is playing, you can use the regular voice_*() functions
     with stream->voice as a parameter.  The format of the sample data
     is described in the SAMPLE entry of the "Structures and types
     defined by Allegro" chapter.  The formula to get the size of the
     buffers in bytes could be:

          bytes = length * (bits / 8) * (stereo ? 2 : 1)

     Example:

          /* Create a 22KHz 8bit mono audio stream. */
          stream = play_audio_stream(1024, 8, FALSE, 22050, 255, 128);
          if (!stream)
             abort_on_error("Error creating audio stream!\n");

     This function returns a pointer to the audio stream or NULL if it
     could not be created.

See also:
*Note install_sound::.
*Note get_audio_stream_buffer::.
*Note stop_audio_stream::.
*Note AUDIOSTREAM::.
*Note Voice control::.
*Note exstream::.
*Note AUDIOSTREAM::.


File: allegro.info,  Node: stop_audio_stream,  Next: get_audio_stream_buffer,  Prev: play_audio_stream,  Up: Audio

1.29.2 stop_audio_stream
------------------------

void stop_audio_stream(AUDIOSTREAM *stream);
     Destroys an audio stream when it is no longer required.

See also:
*Note play_audio_stream::.
*Note exstream::.
*Note AUDIOSTREAM::.


File: allegro.info,  Node: get_audio_stream_buffer,  Next: free_audio_stream_buffer,  Prev: stop_audio_stream,  Up: Audio

1.29.3 get_audio_stream_buffer
------------------------------

void *get_audio_stream_buffer(AUDIOSTREAM *stream);
     You must call this function at regular intervals while an audio
     stream is playing, to provide the next buffer of sample data (the
     smaller the stream buffer size, the more often it must be called).
     This function should not be called from a timer handler.  Example:

          void *mem_chunk;
          ...
          while (TRUE) {
             ...
             mem_chunk = get_audio_stream_buffer(buffer);
             if (mem_chunk != NULL) {
                /* Refill the stream buffer. */
             }
          }

     If it returns NULL, the stream is still playing the previous lot of
     data, so you don't need to do anything.  If it returns a value,
     that is the location of the next buffer to be played, and you
     should load the appropriate number of samples (however many you
     specified when creating the stream) to that address, for example
     using an fread() from a disk file.  After filling the buffer with
     data, call free_audio_stream_buffer() to indicate that the new data
     is now valid.

See also:
*Note play_audio_stream::.
*Note free_audio_stream_buffer::.
*Note exstream::.
*Note AUDIOSTREAM::.


File: allegro.info,  Node: free_audio_stream_buffer,  Next: install_sound_input,  Prev: get_audio_stream_buffer,  Up: Audio

1.29.4 free_audio_stream_buffer
-------------------------------

void free_audio_stream_buffer(AUDIOSTREAM *stream);
     Call this function after get_audio_stream_buffer() returns a
     non-NULL address, to indicate that you have loaded a new block of
     samples to that location and the data is now ready to be played.
     Example:

          mem_chunk = get_audio_stream_buffer(buffer);
          if (mem_chunk != NULL) {
             /* Refill the stream buffer. */
             ...
             free_audio_stream_buffer(buffer);
          }

See also:
*Note get_audio_stream_buffer::.
*Note exstream::.
*Note AUDIOSTREAM::.


File: allegro.info,  Node: Recording,  Next: File,  Prev: Audio,  Up: API

1.30 Recording routines
=======================

Allegro provides routines to capture sound from the sound card, be it
digital samples or MIDI notes.  Ideally this would allow you to create
games where basic speech recognition could be implemented, or voice
messages in multiplayer games over a network.  However, many old sound
cards are not full duplex.  This means, that the sound device can only
be playing or recording, but not both at the same time.

Any Windows 2000 or better machine comes with a full duplex sound card
and updated drivers.  All MacOS X machines allow full duplex recording.
Under Unix your mileage may vary: you can have the right hardware for
the task, but the drivers might not support this feature.  Under DOS you
should forget about full duplex altogether.

To find out if your system allows this feature, use the akaitest
program, distributed along with Allegro, in the 'tests' directory.

* Menu:

* install_sound_input::
* remove_sound_input::
* get_sound_input_cap_bits::
* get_sound_input_cap_stereo::
* get_sound_input_cap_rate::
* get_sound_input_cap_parm::
* set_sound_input_source::
* start_sound_input::
* stop_sound_input::
* read_sound_input::
* digi_recorder::
* midi_recorder::


File: allegro.info,  Node: install_sound_input,  Next: remove_sound_input,  Prev: free_audio_stream_buffer,  Up: Recording

1.30.1 install_sound_input
--------------------------

int install_sound_input(int digi, int midi);
     Initialises the sound recorder module.  You must install the normal
     sound playback system before calling this routine.  The two card
     parameters should use the same constants as install_sound(),
     including DIGI_NONE and MIDI_NONE to disable parts of the module,
     or DIGI_AUTODETECT and MIDI_AUTODETECT to guess the hardware.

     This function returns zero on success, and any other value if the
     machine or driver doesn't support sound recording.

See also:
*Note install_sound::.
*Note start_sound_input::.
*Note midi_recorder::.
*Note Standard config variables::.
*Note DIGI_*/DOS::.
*Note DIGI_*/Windows::.
*Note DIGI_*/Unix::.
*Note DIGI_*/BeOS::.
*Note DIGI_*/QNX::.
*Note DIGI_*/MacOSX::.
*Note MIDI_*/DOS::.
*Note MIDI_*/Windows::.
*Note MIDI_*/Unix::.
*Note MIDI_*/BeOS::.
*Note MIDI_*/QNX::.
*Note MIDI_*/MacOSX::.


File: allegro.info,  Node: remove_sound_input,  Next: get_sound_input_cap_bits,  Prev: install_sound_input,  Up: Recording

1.30.2 remove_sound_input
-------------------------

void remove_sound_input();
     Cleans up after you are finished with the sound input routines.
     You don't normally need to call this, because remove_sound() and/or
     allegro_exit() will do it for you.

See also:
*Note install_sound_input::.
*Note remove_sound::.
*Note allegro_exit::.


File: allegro.info,  Node: get_sound_input_cap_bits,  Next: get_sound_input_cap_stereo,  Prev: remove_sound_input,  Up: Recording

1.30.3 get_sound_input_cap_bits
-------------------------------

int get_sound_input_cap_bits();
     Checks which sample formats are supported by the current audio
     input driver, returning one of the bitfield values:

          0 = audio input not supported
          8 = eight bit audio input is supported
          16 = sixteen bit audio input is supported
          24 = both eight and sixteen bit audio input are supported

     Example:

          cap = get_sound_input_cap_bits();
          if (cap == 0) {
             /* Ugh, no audio input supported? */
          } else {
             if (cap & 8) {
                /* We have eight bit audio input. */
             }
             if (cap & 16) {
                /* We have sixteen bit audio input. */
             }
          }

See also:
*Note start_sound_input::.
*Note get_sound_input_cap_parm::.
*Note get_sound_input_cap_rate::.
*Note get_sound_input_cap_stereo::.


File: allegro.info,  Node: get_sound_input_cap_stereo,  Next: get_sound_input_cap_rate,  Prev: get_sound_input_cap_bits,  Up: Recording

1.30.4 get_sound_input_cap_stereo
---------------------------------

int get_sound_input_cap_stereo();
     Checks whether the current audio input driver is capable of stereo
     recording.

     Returns non-zero if the driver is capable of stereo recording.

See also:
*Note start_sound_input::.
*Note get_sound_input_cap_parm::.
*Note get_sound_input_cap_bits::.
*Note get_sound_input_cap_rate::.


File: allegro.info,  Node: get_sound_input_cap_rate,  Next: get_sound_input_cap_parm,  Prev: get_sound_input_cap_stereo,  Up: Recording

1.30.5 get_sound_input_cap_rate
-------------------------------

int get_sound_input_cap_rate(int bits, int stereo);
     Returns the maximum possible sample frequency for recording in the
     specified format, or zero if these settings are not supported.  The
     bits parameter is the number of bits of the audio, and stereo is a
     boolean parameter.  Pass zero for mono, non-zero for stereo input.
     Example:

          int max_freq;
          ...
          /* What frequency can we record 8 bits mono at? */
          max_freq = get_sound_input_cap_rate(8, 0);
          if (max_freq > 22000) {
             /* Ok, 22KHz and above is good enough. */
          }

See also:
*Note start_sound_input::.
*Note get_sound_input_cap_parm::.
*Note get_sound_input_cap_bits::.
*Note get_sound_input_cap_stereo::.


File: allegro.info,  Node: get_sound_input_cap_parm,  Next: set_sound_input_source,  Prev: get_sound_input_cap_rate,  Up: Recording

1.30.6 get_sound_input_cap_parm
-------------------------------

int get_sound_input_cap_parm(int rate, int bits, int stereo);
     Checks whether the specified recording frequency, number of bits,
     and mono/stereo mode are supported (and how) by the current audio
     driver.

     The function returns one of the following possible values:

          0  = It is impossible to record in this format.
          1  = Recording is possible, but audio output
               will be suspended.
          2  = Recording is possible at the same time as
               playing other sounds (full duplex sound card).
          -n = Sampling rate not supported, but rate 'n'
               would work instead.

See also:
*Note start_sound_input::.
*Note get_sound_input_cap_bits::.
*Note get_sound_input_cap_rate::.
*Note get_sound_input_cap_stereo::.


File: allegro.info,  Node: set_sound_input_source,  Next: start_sound_input,  Prev: get_sound_input_cap_parm,  Up: Recording

1.30.7 set_sound_input_source
-----------------------------

int set_sound_input_source(int source);
     Selects the audio input source.  The parameter should be one of the
     values:

          SOUND_INPUT_MIC
          SOUND_INPUT_LINE
          SOUND_INPUT_CD

     The function returns zero on success, or -1 if the hardware does
     not provide an input select register (ie.  you have no control over
     the input source).

See also:
*Note start_sound_input::.


File: allegro.info,  Node: start_sound_input,  Next: stop_sound_input,  Prev: set_sound_input_source,  Up: Recording

1.30.8 start_sound_input
------------------------

int start_sound_input(int rate, int bits, int stereo);
     Starts recording in the specified format, suspending audio playback
     as necessary if the card is not full duplex.

     Returns the buffer size in bytes if successful, or zero on error.

See also:
*Note install_sound_input::.
*Note read_sound_input::.
*Note stop_sound_input::.
*Note digi_recorder::.
*Note set_sound_input_source::.
*Note get_sound_input_cap_parm::.
*Note get_sound_input_cap_bits::.
*Note get_sound_input_cap_rate::.
*Note get_sound_input_cap_stereo::.


File: allegro.info,  Node: stop_sound_input,  Next: read_sound_input,  Prev: start_sound_input,  Up: Recording

1.30.9 stop_sound_input
-----------------------

void stop_sound_input();
     Stops audio recording, switching the card back into the normal
     playback mode.

See also:
*Note start_sound_input::.


File: allegro.info,  Node: read_sound_input,  Next: digi_recorder,  Prev: stop_sound_input,  Up: Recording

1.30.10 read_sound_input
------------------------

int read_sound_input(void *buffer);
     Retrieves the most recently recorded audio buffer into the
     specified location.  The buffer size can be obtained by checking
     the return value from start_sound_input().  You must be sure to
     call this function at regular intervals during the recording
     (typically around 100 times a second), or some data will be lost.
     If you are unable to do this often enough from the mainline code,
     use the digi_recorder() callback to store the waveform into a
     larger buffer of your own.

     Note: many cards produce a click or popping sound when switching
     between record and playback modes, so it is often a good idea to
     discard the first buffer after you start a recording.  The waveform
     is always stored in unsigned format, with stereo data consisting of
     alternate left/right samples.

     The function will return non-zero if a buffer has been copied or
     zero if no new data is yet available (you were too fast checking
     the input).

See also:
*Note start_sound_input::.


File: allegro.info,  Node: digi_recorder,  Next: midi_recorder,  Prev: read_sound_input,  Up: Recording

1.30.11 digi_recorder
---------------------

extern void (*digi_recorder)();
     If set, this function is called by the input driver whenever a new
     sample buffer becomes available, at which point you can use
     read_sound_input() to copy the data into a more permanent location.
     It runs in an interrupt context, so it must execute very quickly,
     the code and all memory that it touches must be locked, and you
     cannot call any operating system routines or access disk files.
     This currently works only under DOS.

See also:
*Note install_sound_input::.
*Note start_sound_input::.


File: allegro.info,  Node: midi_recorder,  Next: get_executable_name,  Prev: digi_recorder,  Up: Recording

1.30.12 midi_recorder
---------------------

extern void (*midi_recorder)(unsigned char data);
     If set, this function is called by the MIDI input driver whenever a
     new byte of MIDI data becomes available.  It runs in an interrupt
     context, so it must execute very quickly and all the code/data must
     be locked.  This currently works only under DOS and Windows.

See also:
*Note install_sound_input::.
*Note midi_out::.


File: allegro.info,  Node: File,  Next: Datafile,  Prev: Recording,  Up: API

1.31 File and compression routines
==================================

The following routines implement a fast buffered file I/O system, which
supports the reading and writing of compressed files using a ring buffer
algorithm based on the LZSS compressor by Haruhiko Okumura.  This does
not achieve quite such good compression as programs like zip and lha,
but unpacking is very fast and it does not require much memory.  Packed
files always begin with the 32-bit value F_PACK_MAGIC, and autodetect
files with the value F_NOPACK_MAGIC.

The following FA_* flags are guaranteed to work:

     FA_NONE           - Exclude files that have any attribute set
     FA_RDONLY         - Directory entries that are unwritable for current user
     FA_HIDDEN         - Hidden flag
     FA_DIREC          - Directories
     FA_SYSTEM         - Files with system flag set (DOS/Windows only)
     FA_LABEL          - Files with volume label flag set (DOS/Windows only)
     FA_ARCH           - Files with archive flag set (DOS/Windows only)
     FA_ALL            - Match all attributes

Do not use any other flags from DOS/Windows or your code will not
compile on another platform.  FA_RDONLY is for directory entries with
read-only flag on DOS-like systems or unwritable by current user on
Unix-like systems.  Hidden files are directory entries that have the
hidden flag set (DOS/Windows) or have names starting with '.'  (UNIX,
excluding '.'  and '..').  Flags can be combined using '|' (binary OR
operator).

When passed to the functions as the 'attrib' parameter, these flags
represent an upper set in which the actual flag set of a matching file
must be included.  That is, in order for a file to be matching, its
attributes may contain any of the specified flags but must not contain
any of the unspecified flags.  In other words, you explicitly exclude
the flags that you do not specify.  Thus if you pass 'FA_DIREC |
FA_RDONLY', normal files and directories will be included as well as
read-only files and directories, but not hidden files and directories.
Similarly, if you pass 'FA_ARCH' then both archived and non-archived
files will be included.  If FA_NONE is passed all attributes are
excluded and only files with no attributes are returned.  Conversely, if
you pass FA_ALL, no attributes are excluded so all files are returned
(which is what you would usually want).

Functions which accept wildcards as file names support the meta
characters '*' (which means, zero or any quantity of characters) and '?'
(which means any character, but only one).

* Menu:

* get_executable_name::
* fix_filename_case::
* fix_filename_slashes::
* canonicalize_filename::
* make_absolute_filename::
* make_relative_filename::
* is_relative_filename::
* replace_filename::
* replace_extension::
* append_filename::
* get_filename::
* get_extension::
* put_backslash::
* set_filename_encoding::
* get_filename_encoding::
* file_exists::
* exists::
* file_size_ex::
* file_time::
* delete_file::
* for_each_file_ex::
* al_findfirst::
* al_findnext::
* al_findclose::
* al_ffblk_get_size::
* find_allegro_resource::
* set_allegro_resource_path::
* packfile_password::
* pack_fopen::
* pack_fopen_vtable::
* pack_fclose::
* pack_fseek::
* pack_feof::
* pack_ferror::
* pack_getc::
* pack_ungetc::
* pack_putc::
* pack_igetw::
* pack_iputw::
* pack_igetl::
* pack_iputl::
* pack_mgetw::
* pack_mputw::
* pack_mgetl::
* pack_mputl::
* pack_fread::
* pack_fwrite::
* pack_fgets::
* pack_fputs::
* pack_fopen_chunk::
* pack_fclose_chunk::
* create_lzss_pack_data::
* free_lzss_pack_data::
* lzss_write::
* create_lzss_unpack_data::
* free_lzss_unpack_data::
* lzss_read::


File: allegro.info,  Node: get_executable_name,  Next: fix_filename_case,  Prev: midi_recorder,  Up: File

1.31.1 get_executable_name
--------------------------

void get_executable_name(char *buf, int size);
     Fills 'buf' with the full path to the current executable, writing
     at most 'size' bytes.  This generally comes from 'argv[0]' but on
     Unix systems it tries to get the information from the '/proc'
     filesystem first, searching the directories specified in '$PATH' if
     necessary.  If this fails too, it tries to find the executable name
     from the output of the 'ps' command, using 'argv[0]' only as a last
     resort if all other options fail.  Example:

          char name[200];
          ...
          get_executable_name(name, sizeof(name));
          allegro_message("Running `%s'\n", name);


File: allegro.info,  Node: fix_filename_case,  Next: fix_filename_slashes,  Prev: get_executable_name,  Up: File

1.31.2 fix_filename_case
------------------------

char *fix_filename_case(char *path);
     Converts the filename stored in 'path' to a standardised case.  On
     DOS platforms, they will be entirely uppercase.  On other platforms
     this function doesn't do anything.  Example:

          get_executable_name(name, sizeof(name));
          fix_filename_case(name);
          allegro_message("Running `%s'\n", name);

     Returns a copy of the 'path' parameter.

See also:
*Note fix_filename_slashes::.
*Note canonicalize_filename::.


File: allegro.info,  Node: fix_filename_slashes,  Next: canonicalize_filename,  Prev: fix_filename_case,  Up: File

1.31.3 fix_filename_slashes
---------------------------

char *fix_filename_slashes(char *path);
     Converts all the directory separators in the filename stored in
     'path' to a standard character.  On DOS and Windows platforms, this
     is a backslash.  On most other platforms this is a slash.  Example:

          char buf[200] = "c:/dos\\backup/weirdo\\test";
          ...
          fix_filename_slashes(buf);
          /* Under DOS we would have c:\dos\backup\weirdo\test.
             Under Unix we would have c:/dos/backup/weirdo/test. */

     Returns a copy of the 'path' parameter.

See also:
*Note fix_filename_case::.
*Note canonicalize_filename::.


File: allegro.info,  Node: canonicalize_filename,  Next: make_absolute_filename,  Prev: fix_filename_slashes,  Up: File

1.31.4 canonicalize_filename
----------------------------

char *canonicalize_filename(char *dest, const char *filename, int size);
     Converts any filename into its canonical form, i.e.  the minimal
     absolute filename describing the same file and fixing incorrect
     forward/backward slashes for the current platform, storing at most
     'size' bytes into the 'dest' buffer.  You can use the same buffer
     both as input and output because Allegro internally works on a copy
     of the input before touching 'dest'.  Example:

          char buf[256];
          ...
          canonicalize_filename(buf, "~/../s22/..\\t3st///hi.c",
                                sizeof(buf));
          /* Running this under Unix would
             return: /home/t3st/hi.c */

     Note that this function won't work as expected if the path to
     canonicalize comes from another platform (eg.  a "c:\something"
     path will canonicalize into something really wrong under Unix:
     "/current/path/c:/something").

     Returns a copy of the 'dest' parameter.

See also:
*Note fix_filename_case::.
*Note fix_filename_slashes::.


File: allegro.info,  Node: make_absolute_filename,  Next: make_relative_filename,  Prev: canonicalize_filename,  Up: File

1.31.5 make_absolute_filename
-----------------------------

char *make_absolute_filename(char *dest, const char *path, const char *filename, int size);
     Makes an absolute filename from an absolute path and a relative
     filename, storing at most 'size' bytes into the 'dest' buffer.
     This is like calling replace_filename() and then
     canonicalize_filename().  Example:

          char buf[256];
          ...
          make_absolute_filename(buf, "/usr/games/",
                                 "../temp.txt", sizeof(buf));
          /* This would create /usr/temp.txt */

     Returns a copy of the 'dest' parameter.

See also:
*Note make_relative_filename::.
*Note is_relative_filename::.
*Note replace_filename::.
*Note canonicalize_filename::.


File: allegro.info,  Node: make_relative_filename,  Next: is_relative_filename,  Prev: make_absolute_filename,  Up: File

1.31.6 make_relative_filename
-----------------------------

char *make_relative_filename(char *dest, const char *path, const char *filename, int size);
     Attempts to make a relative filename from an absolute path and an
     absolute filename, storing at most 'size' bytes into the 'dest'
     buffer.  This function won't work if the paths are not canonical
     under the current platform (see canonicalize_filename()).  Also,
     'dest' cannot be used as input value for 'path' or 'filename'.
     Example:

          char base[] = "/long/absolute/path/program.exe";
          char user_input[] = "/nice/and/short.txt";
          ...
          make_relative_filename(buf, base, user_input, sizeof(buf));
          /* Under Unix buf would contain:
             ../../../nice/and/short.txt */

     Returns a copy of the 'dest' parameter if it succeeds or NULL if it
     fails (eg.  under DOS, one path starts with "C:\" and another with
     "A:\").

See also:
*Note make_absolute_filename::.
*Note is_relative_filename::.
*Note canonicalize_filename::.


File: allegro.info,  Node: is_relative_filename,  Next: replace_filename,  Prev: make_relative_filename,  Up: File

1.31.7 is_relative_filename
---------------------------

int is_relative_filename(const char *filename);
     Returns TRUE if the filename is relative or FALSE if it is
     absolute.  Note that an absolute filename under DOS (with a device
     separator) will be considered as relative under Unix, because there
     absolute paths always start with a slash.

See also:
*Note make_absolute_filename::.
*Note make_relative_filename::.


File: allegro.info,  Node: replace_filename,  Next: replace_extension,  Prev: is_relative_filename,  Up: File

1.31.8 replace_filename
-----------------------

char *replace_filename(char *dest, const char *path, const char *filename, int size);
     Replaces the specified path+filename with a new filename tail,
     storing at most 'size' bytes into the 'dest' buffer.  You can use
     the same buffer both as input and output because Allegro internally
     works on a copy of the input before touching 'dest'.  Example:

          char name[200];
          ...
          get_executable_name(name, sizeof(name));
          replace_filename(name, name, "sound.dat", sizeof(name));

     Returns a copy of the 'dest' parameter.

See also:
*Note get_filename::.
*Note replace_extension::.
*Note append_filename::.
*Note Available Allegro examples: Available.


File: allegro.info,  Node: replace_extension,  Next: append_filename,  Prev: replace_filename,  Up: File

1.31.9 replace_extension
------------------------

char *replace_extension(char *dest, const char *filename, const char *ext, int size);
     Replaces the specified filename+extension with a new extension
     tail, storing at most 'size' bytes into the 'dest' buffer.  If the
     filename doesn't have any extension at all, 'ext' will be appended
     to it, adding a dot character if needed.  You can use the same
     buffer both as input and output because Allegro internally works on
     a copy of the input before touching 'dest'.  Example:

          replace_extension(buf, "C:\\game\\prog.exe",
                            "dat", sizeof(buf));

     Returns a copy of the 'dest' parameter.

See also:
*Note get_extension::.
*Note replace_filename::.


File: allegro.info,  Node: append_filename,  Next: get_filename,  Prev: replace_extension,  Up: File

1.31.10 append_filename
-----------------------

char *append_filename(char *dest, const char *path, const char *filename, int size);
     Concatenates the specified filename onto the end of the specified
     path, storing at most 'size' bytes into the 'dest' buffer.  If
     'path' doesn't have a trailing path separator, the function will
     append one if needed.  You can use the same buffer both as input
     and output because Allegro internally works on a copy of the input
     before touching 'dest'.  Example:

          append_filename(buf, "/home/user",
                          "prog.bin", sizeof(buf));

     Returns a copy of the 'dest' parameter.

See also:
*Note replace_filename::.


File: allegro.info,  Node: get_filename,  Next: get_extension,  Prev: append_filename,  Up: File

1.31.11 get_filename
--------------------

char *get_filename(const char *path);
     Finds out the filename portion of a completely specified file path.
     Both '\' and '/' are recognized as directory separators under DOS
     and Windows.  However, only '/' is recognized as directory
     separator under other platforms.  Example:

          get_executable_name(name, sizeof(name));
          allegro_message("Running `%s'\n", get_filename(name));

     Note that Allegro won't perform any IO operations during the
     verification.  This means that if you have '/a/path/like/this/',
     which doesn't have a filename, the function will return a pointer
     to the trailing null character.  However, if you have
     '/a/path/like/this', Allegro will return a pointer to 'this', even
     if it is a valid directory.

     Returns a pointer to the portion of 'path' where the filename
     starts, or the beginning of 'path' if no valid filename is found
     (eg.  you are processing a path with backslashes under Unix).

See also:
*Note get_extension::.
*Note put_backslash::.
*Note replace_filename::.
*Note exmidi::.


File: allegro.info,  Node: get_extension,  Next: put_backslash,  Prev: get_filename,  Up: File

1.31.12 get_extension
---------------------

char *get_extension(const char *filename);
     Finds out the extension of the filename (with or without path
     information).  Example:

          get_executable_name(name, sizeof(name));
          allegro_message("The binary has the extension `%s'\n",
                          get_extension(name));

     Returns a pointer to the portion of 'filename' where the extension
     starts, or a pointer to the trailing null character if there is no
     filename or it doesn't have extension.

See also:
*Note get_filename::.
*Note put_backslash::.
*Note replace_extension::.


File: allegro.info,  Node: put_backslash,  Next: set_filename_encoding,  Prev: get_extension,  Up: File

1.31.13 put_backslash
---------------------

void put_backslash(char *filename);
     If the last character of the filename is not a '\', '/', '#' or a
     device separator (ie.  ':' under DOS), this routine will
     concatenate either a '\' or '/' on to it (depending on the
     platform).  Note: ignore the function name, it's out of date.

See also:
*Note get_extension::.
*Note get_filename::.


File: allegro.info,  Node: set_filename_encoding,  Next: get_filename_encoding,  Prev: put_backslash,  Up: File

1.31.14 set_filename_encoding
-----------------------------

void set_filename_encoding(int encoding)
     Sets the encoding to use for filenames.  By default, UTF-8 is
     assumed.

See also:
*Note get_filename_encoding::.


File: allegro.info,  Node: get_filename_encoding,  Next: file_exists,  Prev: set_filename_encoding,  Up: File

1.31.15 get_filename_encoding
-----------------------------

int get_filename_encoding(void)
     Returns the encoding currently assumed for filenames.

See also:
*Note set_filename_encoding::.


File: allegro.info,  Node: file_exists,  Next: exists,  Prev: get_filename_encoding,  Up: File

1.31.16 file_exists
-------------------

int file_exists(const char *filename, int attrib, int *aret);
     Checks whether a file matching the given name and attributes (see
     beginning of this chapter) exists.  If 'aret' is not NULL, it will
     be set to the attributes of the matching file.  Example:

          /* Check for a normal file. */
          if (file_exists("franken.dat", 0, NULL))
             allegro_message("It is alive!\n");

     Returns non-zero if the file exists, or zero if it doesn't or the
     specified attributes mask it out.

See also:
*Note exists::.
*Note file_size_ex::.
*Note file_time::.


File: allegro.info,  Node: exists,  Next: file_size_ex,  Prev: file_exists,  Up: File

1.31.17 exists
--------------

int exists(const char *filename);
     Shortcut version of file_exists(), which checks for normal files,
     which may have the archive or read-only bits set, but are not
     hidden, directories, system files, etc.

     Returns non-zero if the file exists, or zero if it doesn't.

See also:
*Note file_exists::.
*Note file_size_ex::.
*Note file_time::.


File: allegro.info,  Node: file_size_ex,  Next: file_time,  Prev: exists,  Up: File

1.31.18 file_size_ex
--------------------

uint64_t file_size_ex(const char *filename);
     Returns the size of a file, in bytes.  If the file does not exist
     or an error occurs, it will return zero and store the system error
     code in errno.

See also:
*Note file_exists::.
*Note file_time::.
*Note expackf::.


File: allegro.info,  Node: file_time,  Next: delete_file,  Prev: file_size_ex,  Up: File

1.31.19 file_time
-----------------

time_t file_time(const char *filename);
     Returns the modification time (number of seconds since 00:00:00 GMT
     1/1/1970) of a file.  If the file does not exist or an error
     occurs, it will return zero and store the system error code in
     errno.

See also:
*Note file_exists::.
*Note file_size_ex::.


File: allegro.info,  Node: delete_file,  Next: for_each_file_ex,  Prev: file_time,  Up: File

1.31.20 delete_file
-------------------

int delete_file(const char *filename);
     Removes a file from the disk.  You can't delete directories,
     though.

     Returns zero on success, non-zero on failure.


File: allegro.info,  Node: for_each_file_ex,  Next: al_findfirst,  Prev: delete_file,  Up: File

1.31.21 for_each_file_ex
------------------------

int for_each_file_ex(const char *name, int in_attrib, int out_attrib, int (*callback)(const char *filename, int attrib, void *param), void *param);
     Finds all the files on disk which match the given wildcard
     specification and file attributes, and executes callback() once for
     each.  Basically, this is a convenient wrapper around
     al_findfirst(), al_findnext() and al_findclose().  'in_attrib' is a
     bitmask specifying the attributes the files must carry,
     'out_attrib' is a bitmask specifying the attributes the files must
     not carry; attributes which are not specified in either bitmasks
     are not taken into account for deciding whether callback() is
     invoked or not.

     The callback function will be passed three arguments: the first is
     a string which contains the completed filename (exactly the same
     string you passed to for_each_file_ex() but with meta characters),
     the second is the actual attributes of the file, and the third is a
     void pointer which is simply a copy of 'param' (you can use this
     for whatever you like).  The callback must return zero to let the
     enumeration proceed, or any non-zero value to stop it.  If an error
     occurs, the error code will be stored in 'errno' but the
     enumeration won't stop.  Example:

          int show_name(const char *filename, int attrib, void *param)
          {
             allegro_message("Caught `%s', attribs %d\n",
                             filename, attrib);
             return 0;
          }
          ...
             count = for_each_file_ex("data/level*", FA_DIREC,
                                      0, show_name, 0);
             allegro_message("%d game directories\n", count);

     Returns the number of successful calls made to callback(), that is,
     the number of times callback() was called and returned 0.

See also:
*Note al_findfirst::.
*Note al_findnext::.
*Note al_findclose::.


File: allegro.info,  Node: al_findfirst,  Next: al_findnext,  Prev: for_each_file_ex,  Up: File

1.31.22 al_findfirst
--------------------

int al_findfirst(const char *pattern, struct al_ffblk *info, int attrib);
     Low-level function for searching files.  This function finds the
     first file which matches the given wildcard specification and file
     attributes (see above).  The information about the file (if any)
     will be put in the al_ffblk structure which you have to provide.
     The al_ffblk structure looks like:

          struct al_ffblk
          {
             int attrib;       - actual attributes of the file found
             time_t time;      - modification time of file
             char name[512];   - name of file
          };

     There is some other stuff in the structure as well, but it is there
     for internal use only.  Example:

          struct al_ffblk info;

          if (al_findfirst("*.pcx", &info, FA_ALL) != 0) {
             /* Tell user there are no PCX files. */
             return;
          }

     The function returns non-zero if no match is found or if an error
     occurred and, in the latter case, sets 'errno' accordingly.  It
     returns zero if a match is found, allocating some memory for
     internal use in the structure.  Therefore you have to close your
     search when you are finished to avoid memory leaks in your program.

See also:
*Note al_findnext::.
*Note al_findclose::.
*Note al_ffblk_get_size::.
*Note al_ffblk::.


File: allegro.info,  Node: al_findnext,  Next: al_findclose,  Prev: al_findfirst,  Up: File

1.31.23 al_findnext
-------------------

int al_findnext(struct al_ffblk *info);
     This finds the next file in a search started by al_findfirst().
     Example:

          if (al_findfirst("*.pcx", &info, 0) != 0)
             return;

          do {
             /* Do something useful here with info.name. */
          } while (al_findnext(&info) == 0);

          al_findclose(&info);

     Returns zero if a match is found, non-zero if none is found or if
     an error occurred and, in the latter case, sets errno accordingly.

See also:
*Note al_findfirst::.
*Note al_findclose::.
*Note al_ffblk::.


File: allegro.info,  Node: al_findclose,  Next: al_ffblk_get_size,  Prev: al_findnext,  Up: File

1.31.24 al_findclose
--------------------

void al_findclose(struct al_ffblk *info);
     This closes a previously opened search with al_findfirst().  You
     need to call this on all successfully opened searches to avoid
     memory leaks in your program.

See also:
*Note al_findfirst::.
*Note al_findnext::.
*Note al_ffblk::.


File: allegro.info,  Node: al_ffblk_get_size,  Next: find_allegro_resource,  Prev: al_findclose,  Up: File

1.31.25 al_ffblk_get_size
-------------------------

uint64_t al_ffblk_get_size(struct al_ffblk *info);
     This returns the size of the file returned by al_findfirst or
     al_findnext.

See also:
*Note al_findfirst::.
*Note al_findnext::.
*Note al_ffblk::.
*Note al_ffblk::.


File: allegro.info,  Node: find_allegro_resource,  Next: set_allegro_resource_path,  Prev: al_ffblk_get_size,  Up: File

1.31.26 find_allegro_resource
-----------------------------

int find_allegro_resource(char *dest, const char *resource, const char *ext, const char *datafile, const char *objectname, const char *envvar, const char *subdir, int size);
     Searches for a support file, eg.  'allegro.cfg' or 'language.dat'.
     Passed a resource string describing what you are looking for, along
     with extra optional information such as the default extension, what
     datafile to look inside, what the datafile object name is likely to
     be, any special environment variable to check, and any subdirectory
     that you would like to check as well as the default location, this
     function looks in a hell of a lot of different places :-).  Pass
     NULL for the parameters you are not using.

     Check the documentation chapter specific to your platform for
     information on additional paths this function might search for.
     Also, don't forget about set_allegro_resource_path() to extend the
     searches.  Example:

          char path[256];
          int ret;
          ret = find_allegro_resource(path, "scores.cfg", NULL, NULL,
                                      NULL, NULL, NULL, sizeof(path));
          if (ret == 0) {
             /* Found system wide scores file. */
          } else {
             /* No previous scores, create our own file. */
          }

     Returns zero on success, and stores a full path to the file (at
     most size bytes) into the dest buffer.

See also:
*Note set_allegro_resource_path::.


File: allegro.info,  Node: set_allegro_resource_path,  Next: packfile_password,  Prev: find_allegro_resource,  Up: File

1.31.27 set_allegro_resource_path
---------------------------------

int set_allegro_resource_path(int priority, const char *path);
     Sometimes Allegro doesn't look in enough places to find a resource.
     For those special cases, you can call this function before loading
     your resource with additional paths to search for.  You set up the
     priorities, higher numbers are searched for first.  To modify an
     already setup path, call this function with the same priority and
     the new path.  To remove an already setup path, call this function
     with the priority of the path and NULL as the path parameter.
     Example:

          set_allegro_resource_path(10, "my_game/configs");
          set_allegro_resource_path(0, "users/configs/");
          set_allegro_resource_path(-45, "temp");

     These custom paths will be valid until you call allegro_exit().
     You can call this function before install_allegro(), but after
     set_uformat() if you want to use a text encoding format other than
     the default.

     Returns non-zero on success, zero if the path could not be added or
     you wanted to remove a path and the priority used didn't have any
     associated path.  Modification of existing paths always succeeds.

See also:
*Note find_allegro_resource::.


File: allegro.info,  Node: packfile_password,  Next: pack_fopen,  Prev: set_allegro_resource_path,  Up: File

1.31.28 packfile_password
-------------------------

void packfile_password(const char *password);
     Sets the encryption password to be used for all read/write
     operations on files opened in future using Allegro's packfile
     functions (whether they are compressed or not), including all the
     save, load and config routines.  Files written with an encryption
     password cannot be read unless the same password is selected, so be
     careful: if you forget the key, nobody can make your data come back
     again!  Pass NULL or an empty string to return to the normal,
     non-encrypted mode.  If you are using this function to prevent
     people getting access to your datafiles, be careful not to store an
     obvious copy of the password in your executable: if there are any
     strings like "I'm the password for the datafile", it would be
     fairly easy to get access to your data :-)

     Note #1: when writing a packfile, you can change the password to
     whatever you want after opening the file, without affecting the
     write operation.  On the contrary, when writing a sub-chunk of a
     packfile, you must make sure that the password that was active at
     the time the sub-chunk was opened is still active before closing
     the sub-chunk.  This is guaranteed to be true if you didn't call
     the packfile_password() routine in the meantime.  Read operations,
     either on packfiles or sub-chunks, have no such restriction.

     Note #2: as explained above, the password is used for all
     read/write operations on files, including for several functions of
     the library that operate on files without explicitly using
     packfiles (e.g.  load_bitmap()).  The unencrypted mode is mandatory
     in order for those functions to work.  Therefore remember to call
     packfile_password(NULL) before using them if you previously changed
     the password.  As a rule of thumb, always call
     packfile_password(NULL) when you are done with operations on
     packfiles.  The only exception to this is custom packfiles created
     with pack_fopen_vtable().

See also:
*Note pack_fopen::.
*Note load_datafile::.
*Note pack_fopen_vtable::.


File: allegro.info,  Node: pack_fopen,  Next: pack_fopen_vtable,  Prev: packfile_password,  Up: File

1.31.29 pack_fopen
------------------

PACKFILE *pack_fopen(const char *filename, const char *mode);
     Opens a file according to mode, which may contain any of the flags:

        * 'r' - open file for reading.
        * 'w' - open file for writing, overwriting any existing data.
        * 'p' - open file in packed mode.  Data will be compressed as it
          is written to the file, and automatically uncompressed during
          read operations.  Files created in this mode will produce
          garbage if they are read without this flag being set.
        * '!'  - open file for writing in normal, unpacked mode, but add
          the value F_NOPACK_MAGIC to the start of the file, so that it
          can later be opened in packed mode and Allegro will
          automatically detect that the data does not need to be
          decompressed.

     Instead of these flags, one of the constants F_READ, F_WRITE,
     F_READ_PACKED, F_WRITE_PACKED or F_WRITE_NOPACK may be used as the
     mode parameter.

     The packfile functions also understand several "magic" filenames
     that are used for special purposes.  These are:

        * '#' - read data that has been appended to your executable file
          with the exedat utility, as if it was a regular independent
          disk file.
        * 'filename.dat#object_name' - open a specific object from a
          datafile, and read from it as if it was a regular file.  You
          can treat nested datafiles exactly like a normal directory
          structure, for example you could open
          'filename.dat#graphics/level1/mapdata'.
        * '#object_name' - combination of the above, reading an object
          from a datafile that has been appended onto your executable.

     With these special filenames, the contents of a datafile object or
     appended file can be read in an identical way to a normal disk
     file, so any of the file access functions in Allegro (eg.
     load_pcx() and set_config_file()) can be used to read from them.
     Note that you can't write to these special files, though: the fake
     file is read only.  Also, you must save your datafile uncompressed
     or with per-object compression if you are planning on loading
     individual objects from it (otherwise there will be an excessive
     amount of seeking when it is read).

     Finally, be aware that the special Allegro object types aren't the
     same format as the files you import the data from.  When you import
     data like bitmaps or samples into the grabber, they are converted
     into a special Allegro-specific format, but the '#' marker file
     syntax reads the objects as raw binary chunks.  This means that if,
     for example, you want to use load_pcx() to read an image from a
     datafile, you should import it as a binary block rather than as a
     BITMAP object.

     Example:

          PACKFILE *input_file;

          input_file = pack_fopen("scores.dat", "rp");
          if (!input_file)
             abort_on_error("Couldn't read `scores.dat'!");

     On success, pack_fopen() returns a pointer to a PACKFILE structure,
     and on error it returns NULL and stores an error code in 'errno'.
     An attempt to read a normal file in packed mode will cause 'errno'
     to be set to EDOM.

See also:
*Note pack_fclose::.
*Note pack_fopen_chunk::.
*Note packfile_password::.
*Note pack_fread::.
*Note pack_getc::.
*Note file_select_ex::.
*Note pack_fopen_vtable::.
*Note expackf::.
*Note PACKFILE::.


File: allegro.info,  Node: pack_fopen_vtable,  Next: pack_fclose,  Prev: pack_fopen,  Up: File

1.31.30 pack_fopen_vtable
-------------------------

PACKFILE *pack_fopen_vtable(const PACKFILE_VTABLE *vtable, void *userdata);
     Creates a new packfile structure that uses the functions specified
     in the vtable instead of the standard functions.  The data pointer
     by 'vtable' and 'userdata' must remain available for the lifetime
     of the created packfile.

     While the created packfile structure can be used with other Allegro
     functions, there are two limitations.  First, opening chunks using
     pack_fopen_chunk() on top of the returned packfile is not possible
     at this time.  And packfile_password() does not have any effect on
     packfiles opened with pack_fopen_vtable().

     On success, it returns a pointer to a PACKFILE structure, and on
     error it returns NULL and stores an error code in 'errno'.

See also:
*Note pack_fopen::.
*Note pack_fopen_chunk::.
*Note packfile_password::.
*Note expackf::.
*Note PACKFILE::.
*Note PACKFILE_VTABLE::.


File: allegro.info,  Node: pack_fclose,  Next: pack_fseek,  Prev: pack_fopen_vtable,  Up: File

1.31.31 pack_fclose
-------------------

int pack_fclose(PACKFILE *f);
     Closes the stream 'f' previously opened with pack_fopen() or
     pack_fopen_vtable().  After you have closed the stream, performing
     operations on it will yield errors in your application (e.g.  crash
     it) or even block your OS.

     Returns zero on success.  On error, returns an error code which is
     also stored in 'errno'.  This function can fail only when writing
     to files: if the file was opened in read mode, it will always
     succeed.

See also:
*Note pack_fopen::.
*Note pack_fopen_vtable::.
*Note packfile_password::.
*Note expackf::.
*Note PACKFILE::.


File: allegro.info,  Node: pack_fseek,  Next: pack_feof,  Prev: pack_fclose,  Up: File

1.31.32 pack_fseek
------------------

int pack_fseek(PACKFILE *f, int offset);
     Moves the position indicator of the stream 'f'.  Unlike the
     standard fseek() function, this only supports forward movements
     relative to the current position and in read-only streams, so don't
     use negative offsets.  Note that seeking is very slow when reading
     compressed files, and so should be avoided unless you are sure that
     the file is not compressed.  Example:

          input_file = pack_fopen("data.bin", "r");
          if (!input_file)
             abort_on_error("Couldn't open binary data!");
          /* Skip some useless header before reading data. */
          pack_fseek(input_file, 32);

     Returns zero on success or a negative number on error, storing the
     error code in 'errno'.

See also:
*Note pack_fopen::.
*Note pack_fopen_chunk::.
*Note expackf::.
*Note PACKFILE::.


File: allegro.info,  Node: pack_feof,  Next: pack_ferror,  Prev: pack_fseek,  Up: File

1.31.33 pack_feof
-----------------

int pack_feof(PACKFILE *f);
     Finds out if you have reached the end of the file.  It does not
     wait for you to attempt to read beyond the end of the file,
     contrary to the ISO C feof() function.  The only way to know
     whether you have read beyond the end of the file is to check the
     return value of the read operation you use (and be wary of
     pack_*getl() as EOF is also a valid return value with these
     functions).

     Returns non-zero if you are at the end of the file, zero otherwise.

See also:
*Note pack_fopen::.
*Note pack_fopen_chunk::.
*Note pack_ferror::.
*Note PACKFILE::.


File: allegro.info,  Node: pack_ferror,  Next: pack_getc,  Prev: pack_feof,  Up: File

1.31.34 pack_ferror
-------------------

int pack_ferror(PACKFILE *f);
     Since EOF is used to report errors by some functions, it's often
     better to use the pack_feof() function to check explicitly for end
     of file and pack_ferror() to check for errors.  Both functions
     check indicators that are part of the internal state of the stream
     to detect correctly the different situations.

     Returns nonzero if the error indicator for the stream is set,
     meaning that an error has occurred during a previous operation on
     the stream.

See also:
*Note pack_fopen::.
*Note pack_fopen_chunk::.
*Note PACKFILE::.


File: allegro.info,  Node: pack_getc,  Next: pack_ungetc,  Prev: pack_ferror,  Up: File

1.31.35 pack_getc
-----------------

int pack_getc(PACKFILE *f);
     Returns the next character from the stream 'f', or EOF if the end
     of the file has been reached.

See also:
*Note pack_fopen::.
*Note pack_fopen_chunk::.
*Note PACKFILE::.


File: allegro.info,  Node: pack_ungetc,  Next: pack_putc,  Prev: pack_getc,  Up: File

1.31.36 pack_ungetc
-------------------

int pack_ungetc(int c, PACKFILE *f);
     Puts a character back to the file's input buffer.  Like with ungetc
     from libc, only a single push back is guaranteed.

     Note: pack_fgets internally uses pack_ungetc, so never use
     pack_ungetc directly after using pack_fgets on a PACKFILE.

     Returns c on success, or EOF on error.

See also:
*Note pack_getc::.
*Note pack_fgets::.
*Note PACKFILE::.


File: allegro.info,  Node: pack_putc,  Next: pack_igetw,  Prev: pack_ungetc,  Up: File

1.31.37 pack_putc
-----------------

int pack_putc(int c, PACKFILE *f);
     Puts a character in the stream f.

     Returns the character written on success, or EOF on error.

See also:
*Note pack_fopen::.
*Note pack_fopen_chunk::.
*Note PACKFILE::.


File: allegro.info,  Node: pack_igetw,  Next: pack_iputw,  Prev: pack_putc,  Up: File

1.31.38 pack_igetw
------------------

int pack_igetw(PACKFILE *f);
     Like pack_getc, but reads a 16-bit word from a file, using Intel
     byte ordering (least significant byte first, a.k.a.
     little-endian).

See also:
*Note pack_getc::.
*Note PACKFILE::.


File: allegro.info,  Node: pack_iputw,  Next: pack_igetl,  Prev: pack_igetw,  Up: File

1.31.39 pack_iputw
------------------

int pack_iputw(int c, PACKFILE *f);
     Like pack_putc, but writes a 16-bit word to a file, using Intel
     byte ordering (least significant byte first, a.k.a.
     little-endian).

See also:
*Note pack_putc::.
*Note PACKFILE::.


File: allegro.info,  Node: pack_igetl,  Next: pack_iputl,  Prev: pack_iputw,  Up: File

1.31.40 pack_igetl
------------------

long pack_igetl(PACKFILE *f);
     Like pack_getc, but reads a 32-bit long from a file, using Intel
     byte ordering (least significant byte first, a.k.a.
     little-endian).

See also:
*Note pack_getc::.
*Note PACKFILE::.


File: allegro.info,  Node: pack_iputl,  Next: pack_mgetw,  Prev: pack_igetl,  Up: File

1.31.41 pack_iputl
------------------

long pack_iputl(long c, PACKFILE *f);
     Like pack_putc, but writes a 32-bit long to a file, using Intel
     byte ordering (least significant byte first, a.k.a.
     little-endian).

See also:
*Note pack_putc::.
*Note PACKFILE::.


File: allegro.info,  Node: pack_mgetw,  Next: pack_mputw,  Prev: pack_iputl,  Up: File

1.31.42 pack_mgetw
------------------

int pack_mgetw(PACKFILE *f);
     Like pack_getc, but reads a 16-bit word from a file, using Motorola
     byte ordering (most significant byte first, a.k.a.  big-endian).

See also:
*Note pack_getc::.
*Note PACKFILE::.


File: allegro.info,  Node: pack_mputw,  Next: pack_mgetl,  Prev: pack_mgetw,  Up: File

1.31.43 pack_mputw
------------------

int pack_mputw(int c, PACKFILE *f);
     Like pack_putc, but writes a 16-bit word to a file, using Motorola
     byte ordering (most significant byte first, a.k.a.  big-endian).

See also:
*Note pack_putc::.
*Note PACKFILE::.


File: allegro.info,  Node: pack_mgetl,  Next: pack_mputl,  Prev: pack_mputw,  Up: File

1.31.44 pack_mgetl
------------------

long pack_mgetl(PACKFILE *f);
     Like pack_getc, but reads a 32-bit long from a file, using Motorola
     byte ordering (most significant byte first, a.k.a.  big-endian).

See also:
*Note pack_getc::.
*Note PACKFILE::.


File: allegro.info,  Node: pack_mputl,  Next: pack_fread,  Prev: pack_mgetl,  Up: File

1.31.45 pack_mputl
------------------

long pack_mputl(long c, PACKFILE *f);
     Like pack_putc, but writes a 32-bit long to a file, using Motorola
     byte ordering (most significant byte first, a.k.a.  big-endian).

See also:
*Note pack_putc::.
*Note PACKFILE::.


File: allegro.info,  Node: pack_fread,  Next: pack_fwrite,  Prev: pack_mputl,  Up: File

1.31.46 pack_fread
------------------

long pack_fread(void *p, long n, PACKFILE *f);
     Reads 'n' bytes from the stream 'f', storing them at the memory
     location pointed to by 'p'.  Example:

          unsigned char buf[256];
          ...
          if (pack_fread(buf, 256, input_file) != 256)
             abort_on_error("Truncated input file!");

     Returns the number of bytes read, which will be less than 'n' if
     EOF is reached or an error occurs.  Error codes are stored in
     errno.

See also:
*Note pack_fopen::.
*Note pack_fopen_chunk::.
*Note pack_feof::.
*Note expackf::.
*Note PACKFILE::.


File: allegro.info,  Node: pack_fwrite,  Next: pack_fgets,  Prev: pack_fread,  Up: File

1.31.47 pack_fwrite
-------------------

long pack_fwrite(const void *p, long n, PACKFILE *f);
     Writes 'n' bytes to the stream 'f' from memory location pointed to
     by 'p'.

     Returns the number of bytes written, which will be less than n if
     an error occurs.  Error codes are stored in errno.

See also:
*Note pack_fopen::.
*Note pack_fopen_chunk::.
*Note pack_feof::.
*Note PACKFILE::.


File: allegro.info,  Node: pack_fgets,  Next: pack_fputs,  Prev: pack_fwrite,  Up: File

1.31.48 pack_fgets
------------------

char *pack_fgets(char *p, int max, PACKFILE *f);
     Reads a line from the stream 'f', storing it at location pointed to
     by 'p'.  Stops when a linefeed is encountered, or 'max' bytes have
     been read.  The end of line is handled by detecting the right
     combination of characters for the platform.  This supports CR-LF
     (DOS/Windows), LF (Unix), and CR (Mac) formats.  However, the
     trailing carriage return is not included in the returned string, in
     order to provide easy code portability across platforms.  If you
     need the carriage return, use pack_fread() and/or pack_getc()
     instead.

     Note: This function internally may make calls to pack_ungetc, so
     you cannot use pack_ungetc directly afterwards.

     Example:

          char buf[256];
          ...
          while (pack_fgets(buf, sizeof(buf), input_file)) {
             /* Process input line. */
          }
          fclose(input_file);

     Returns the pointer 'p' on success, or NULL on error.

See also:
*Note pack_fopen::.
*Note pack_fopen_chunk::.
*Note pack_fread::.
*Note pack_getc::.
*Note pack_ungetc::.
*Note PACKFILE::.


File: allegro.info,  Node: pack_fputs,  Next: pack_fopen_chunk,  Prev: pack_fgets,  Up: File

1.31.49 pack_fputs
------------------

int pack_fputs(const char *p, PACKFILE *f);
     Writes a string to the stream 'f'.  The input string is converted
     from the current text encoding format to UTF-8 before writing.
     Newline characters are written as '\r\n' on DOS and Windows
     platforms.  If you don't want this behaviour, use pack_fwrite()
     and/or pack_putc() instead.

     Returns zero on success or a negative number on error.

See also:
*Note pack_fopen::.
*Note pack_fopen_chunk::.
*Note pack_fwrite::.
*Note pack_putc::.
*Note PACKFILE::.


File: allegro.info,  Node: pack_fopen_chunk,  Next: pack_fclose_chunk,  Prev: pack_fputs,  Up: File

1.31.50 pack_fopen_chunk
------------------------

PACKFILE *pack_fopen_chunk(PACKFILE *f, int pack);
     Opens a sub-chunk of a file.  Chunks are primarily intended for use
     by the datafile code, but they may also be useful for your own file
     routines.  A chunk provides a logical view of part of a file, which
     can be compressed as an individual entity and will automatically
     insert and check length counts to prevent reading past the end of
     the chunk.  The PACKFILE parameter is a previously opened file, and
     'pack' is a boolean parameter which will turn compression on for
     the sub-chunk if it is non-zero.  Example:

          PACKFILE *output = pack_fopen("out.raw", "w!");
          ...
          /* Create a sub-chunk with compression. */
          output = pack_fopen_chunk(output, 1);
          if (!output)
             abort_on_error("Error saving data!");
          /* Write some data to the sub-chunk. */
          ...
          /* Close the sub-chunk, recovering parent file. */
          output = pack_fclose_chunk(output);

     The data written to the chunk will be prefixed with two length
     counts (32-bit, a.k.a.  big-endian).  For uncompressed chunks these
     will both be set to the size of the data in the chunk.  For
     compressed chunks (created by setting the 'pack' flag), the first
     length will be the raw size of the chunk, and the second will be
     the negative size of the uncompressed data.

     To read the chunk, use the following code:

          PACKFILE *input = pack_fopen("out.raw", "rp");
          ...
          input = pack_fopen_chunk(input, 1);
          /* Read data from the sub-chunk and close it. */
          ...
          input = pack_fclose_chunk(input);

     This sequence will read the length counts created when the chunk
     was written, and automatically decompress the contents of the chunk
     if it was compressed.  The length will also be used to prevent
     reading past the end of the chunk (Allegro will return EOF if you
     attempt this), and to automatically skip past any unread chunk data
     when you call pack_fclose_chunk().

     Chunks can be nested inside each other by making repeated calls to
     pack_fopen_chunk().  When writing a file, the compression status is
     inherited from the parent file, so you only need to set the pack
     flag if the parent is not compressed but you want to pack the chunk
     data.  If the parent file is already open in packed mode, setting
     the pack flag will result in data being compressed twice: once as
     it is written to the chunk, and again as the chunk passes it on to
     the parent file.

     Returns a pointer to the sub-chunked PACKFILE, or NULL if there was
     some error (eg.  you are using a custom PACKFILE vtable).

See also:
*Note pack_fclose_chunk::.
*Note pack_fopen::.
*Note PACKFILE::.


File: allegro.info,  Node: pack_fclose_chunk,  Next: create_lzss_pack_data,  Prev: pack_fopen_chunk,  Up: File

1.31.51 pack_fclose_chunk
-------------------------

PACKFILE *pack_fclose_chunk(PACKFILE *f);
     Closes a sub-chunk of a file, previously obtained by calling
     pack_fopen_chunk().

     Returns a pointer to the parent of the sub-chunk you just closed.
     Returns NULL if there was some error (eg.  you tried to close a
     PACKFILE which wasn't sub-chunked).

See also:
*Note pack_fopen_chunk::.
*Note PACKFILE::.


File: allegro.info,  Node: create_lzss_pack_data,  Next: free_lzss_pack_data,  Prev: pack_fclose_chunk,  Up: File

1.31.52 create_lzss_pack_data
-----------------------------

LZSS_PACK_DATA *create_lzss_pack_data(void);
     Creates an LZSS_PACK_DATA structure, which can be used for LZSS
     compression with PACKFILEs.

     Returns a pointer to the structure, or NULL if there was an error.

See also:
*Note free_lzss_pack_data::.
*Note LZSS_PACK_DATA::.


File: allegro.info,  Node: free_lzss_pack_data,  Next: lzss_write,  Prev: create_lzss_pack_data,  Up: File

1.31.53 free_lzss_pack_data
---------------------------

void free_lzss_pack_data(LZSS_PACK_DATA *dat);
     Frees an LZSS_PACK_DATA structure created with
     create_lzss_pack_data().

See also:
*Note create_lzss_pack_data::.
*Note LZSS_PACK_DATA::.


File: allegro.info,  Node: lzss_write,  Next: create_lzss_unpack_data,  Prev: free_lzss_pack_data,  Up: File

1.31.54 lzss_write
------------------

int lzss_write(PACKFILE *file, LZSS_PACK_DATA *dat, int size, unsigned char *buf, int last);
     Packs 'size' bytes from 'buf', using the pack information contained
     in 'dat'.  The compressed bytes will be stored in 'file'.

     Returns 0 on success, or EOF if there was an error.

See also:
*Note create_lzss_pack_data::.
*Note free_lzss_pack_data::.
*Note PACKFILE::.
*Note LZSS_PACK_DATA::.


File: allegro.info,  Node: create_lzss_unpack_data,  Next: free_lzss_unpack_data,  Prev: lzss_write,  Up: File

1.31.55 create_lzss_unpack_data
-------------------------------

LZSS_UNPACK_DATA *create_lzss_unpack_data(void);
     Creates an LZSS_UNPACK_DATA structure, which can be used for LZSS
     decompression reading PACKFILEs.

     Returns a pointer to the structure, or NULL if there was an error.

See also:
*Note free_lzss_unpack_data::.
*Note LZSS_UNPACK_DATA::.


File: allegro.info,  Node: free_lzss_unpack_data,  Next: lzss_read,  Prev: create_lzss_unpack_data,  Up: File

1.31.56 free_lzss_unpack_data
-----------------------------

void free_lzss_unpack_data(LZSS_UNPACK_DATA *dat);
     Frees an LZSS_UNPACK_DATA structure created with
     create_lzss_pack_data.

See also:
*Note create_lzss_unpack_data::.
*Note LZSS_UNPACK_DATA::.


File: allegro.info,  Node: lzss_read,  Next: load_datafile,  Prev: free_lzss_unpack_data,  Up: File

1.31.57 lzss_read
-----------------

int lzss_read(PACKFILE *file, LZSS_UNPACK_DATA *dat, int s, unsigned char *buf);
     Unpacks from 'dat' into 'buf', until either EOF is reached or 's'
     bytes have been extracted from 'file'.

     Returns the number of bytes added to the buffer 'buf'.

See also:
*Note free_lzss_unpack_data::.
*Note PACKFILE::.
*Note LZSS_UNPACK_DATA::.


File: allegro.info,  Node: Datafile,  Next: Fixed,  Prev: File,  Up: API

1.32 Datafile routines
======================

Datafiles are created by the grabber utility (see grabber.txt for more
information), and have a '.dat' extension.  They can contain bitmaps,
palettes, fonts, samples, MIDI music, FLI/FLC animations, and any other
binary data that you import.  You could distribute your bitmaps and
samples in a myriad of separate files, but packing them in a few '.dat'
binaries has a few advantages:

   * On some platforms loading a single big datafile at once is faster
     than loading individual resources one by one.
   * Instead of several loops for your resources, you can write a single
     line of code with just a single point of failure to take care of.
   * You can potentially reduce the size of your data by enabling
     compression on your datafiles.  Less download time for your end
     users, less wait during loading screens!
   * If you don't need to load the whole datafile at once, you can still
     enable individual file compression.  It is slightly worse than
     global compression, but it is very fast with loading times because
     Allegro can easily seek inside the datafile to find a specific
     object.
   * Even without encryption, most end users of your application won't
     be able to look at or modify the resources for your game.  A
     missing sound file or a modified bitmap could potentially crash the
     game if you haven't considered this in your loading code!
   * It looks much more professional and convenient to distribute
     levels!  For example, if you found a bug in a level of your game,
     just distribute your new 'level4.dat' and tell users to overwrite
     their old version.

Allegro allows you to load datafiles once and forget about them.  But if
you have many levels it can be wise to load only the resources required
for the current level.  You can accomplish the later by separating
levels in different datafiles, or using functions like
load_datafile_object() to avoid loading everything at once.  You can
even read directly from a specific datafile object with the pack_fopen()
function.

On some platforms you can attach datafiles to your binary, potentially
reducing your game distribution down to a single executable file.  Try
the example exexedat on your platform to see if this is possible.
However, this is not recommended for big programs: a single update to
your code or binary data would force end users to download again a
potentially big file, no matter how small your change is.  The same
warning goes for the tools dat2s or dat2c, which convert datafiles into
assembler and C code respectively, prepared to be included directly in
your binary.

Remember that with Allegro truecolor images can only be loaded after you
have set a graphics mode.  This is true for datafiles too.  Load all
your data after you have set the graphics mode, otherwise the pixel
format (RGB or BGR) will not be known and the datafile may be converted
wrongly.  Oh, and read carefully the warning of fixup_datafile() if you
plan on switching resolutions during runtime.

Note: even though Allegro datafiles provide encryption, you should
consider it weak, so don't plan on hiding there the plans for a Death
Star or something.  Determinate knowledgeable users will be able to rip
your resources no matter how hard you try to hide them!  Use the
encryption only as a slight deterrent towards unwanted tampering of your
data.  How to crack an encrypted datafile is left as an exercise to the
reader, though.

Using datafiles once they are loaded is quite simple: you access the
elements of the DATAFILE as a normal array.  Read below the section
"Using datafiles" below for several examples on how to access their
data.

* Menu:

* load_datafile::
* load_datafile_callback::
* unload_datafile::
* load_datafile_object::
* unload_datafile_object::
* find_datafile_object::
* create_datafile_index::
* load_datafile_object_indexed::
* destroy_datafile_index::
* get_datafile_property::
* register_datafile_object::
* fixup_datafile::
* DAT_ID::
* Using datafiles::
* Custom datafile objects::


File: allegro.info,  Node: load_datafile,  Next: load_datafile_callback,  Prev: lzss_read,  Up: Datafile

1.32.1 load_datafile
--------------------

DATAFILE *load_datafile(const char *filename);
     Loads a datafile into memory in one go.  If the datafile has been
     encrypted, you must first call packfile_password() to set the
     appropriate key.  If the datafile contains truecolor graphics, you
     must set the video mode or call set_color_conversion() before
     loading it.  Example:

          /* Load the resources for our game. */
          DATAFILE *dat = load_datafile("game.dat");
          if (!dat)
             abort_on_error("Couldn't load sound resources!");
          /* Use resources. */
          ...
          /* Destroy them when we don't need them any more. */
          unload_datafile(dat);

     Returns a pointer to the DATAFILE, or NULL on error.  Remember to
     free this DATAFILE later to avoid memory leaks.

See also:
*Note load_datafile_callback::.
*Note unload_datafile::.
*Note load_datafile_object::.
*Note set_color_conversion::.
*Note fixup_datafile::.
*Note packfile_password::.
*Note find_datafile_object::.
*Note register_datafile_object::.
*Note Using datafiles::.
*Note excustom::.
*Note exdata::.
*Note exexedat::.
*Note exgui::.
*Note exsprite::.
*Note exunicod::.
*Note DATAFILE::.


File: allegro.info,  Node: load_datafile_callback,  Next: unload_datafile,  Prev: load_datafile,  Up: Datafile

1.32.2 load_datafile_callback
-----------------------------

DATAFILE *load_datafile_callback(const char *filename, void (*callback)(DATAFILE *d));
     Loads a datafile into memory, calling the specified hook function
     once for each object in the file, passing it a pointer to the
     object just read.  You can use this to implement very simple
     loading screens where every time the hook is called, the screen is
     updated to let the user know your program is still loading from
     disk:

          void load_callback(DATAFILE *dat_obj)
          {
             static const char indicator[] = "-\\|/-.oOXOo.";
             static int current = 0;

             /* Show a different character every time. */
             textprintf_ex(screen, font, 0, 0, makecol(0, 0, 0),
                           makecol(255, 255, 255), "%c Loading %c",
                           indicator[current], indicator[current]);
             /* Increase index and check if we need to reset it. */
             current++;
             if (!indicator[current])
                current = 0;
          }
             ...
             dat = load_datafile_callback("data.dat", load_callback);

     Returns a pointer to the DATAFILE or NULL on error.  Remember to
     free this DATAFILE later to avoid memory leaks.

See also:
*Note load_datafile::.
*Note unload_datafile::.
*Note load_datafile_object::.
*Note set_color_conversion::.
*Note fixup_datafile::.
*Note packfile_password::.
*Note find_datafile_object::.
*Note register_datafile_object::.
*Note DATAFILE::.


File: allegro.info,  Node: unload_datafile,  Next: load_datafile_object,  Prev: load_datafile_callback,  Up: Datafile

1.32.3 unload_datafile
----------------------

void unload_datafile(DATAFILE *dat);
     Frees all the objects in a datafile.  Use this to avoid memory
     leaks in your program.

See also:
*Note load_datafile::.
*Note excustom::.
*Note exdata::.
*Note exexedat::.
*Note exgui::.
*Note exsprite::.
*Note exunicod::.
*Note DATAFILE::.


File: allegro.info,  Node: load_datafile_object,  Next: unload_datafile_object,  Prev: unload_datafile,  Up: Datafile

1.32.4 load_datafile_object
---------------------------

DATAFILE *load_datafile_object(const char *filename, const char *objectname);
     Loads a specific object from a datafile.  This won't work if you
     strip the object names from the file, and it will be very slow if
     you save the file with global compression.  Example:

          /* Load only the music from the datafile. */
          music_object = load_datafile_object("datafile.dat",
                                              "MUSIC");
          /* Play it and wait a moment for it. */
          play_midi(music_object->dat);
          ...
          /* Destroy unneeded music. */
          unload_datafile_object(music_object);

     Returns a pointer to a single DATAFILE element whose 'dat' member
     points to the object, or NULL if there was an error or there was no
     object with the requested name.  Remember to free this DATAFILE
     later to avoid memory leaks, but use the correct unloading
     function!

See also:
*Note unload_datafile_object::.
*Note load_datafile::.
*Note set_color_conversion::.
*Note find_datafile_object::.
*Note register_datafile_object::.
*Note Using datafiles::.
*Note DATAFILE::.


File: allegro.info,  Node: unload_datafile_object,  Next: find_datafile_object,  Prev: load_datafile_object,  Up: Datafile

1.32.5 unload_datafile_object
-----------------------------

void unload_datafile_object(DATAFILE *dat);
     Frees an object previously loaded by load_datafile_object().  Use
     this to avoid memory leaks in your program.

See also:
*Note load_datafile_object::.
*Note DATAFILE::.


File: allegro.info,  Node: find_datafile_object,  Next: create_datafile_index,  Prev: unload_datafile_object,  Up: Datafile

1.32.6 find_datafile_object
---------------------------

DATAFILE *find_datafile_object(const DATAFILE *dat, const char *objectname);
     Searches an already loaded datafile for an object with the
     specified name.  In the name you can use '/' and '#' separators for
     nested datafile paths.  Example:

          char level_name[10];
          DATAFILE *dat, *level;
          ...
          uszprintf(level_name, sizeof(buffer),
                    "LEVEL_%02d", level_number);
          level = find_datafile_object(dat, level_name);
          if (!level)
             abort_on_error("That level doesn't exist!");

     Returns a pointer to a single DATAFILE element whose 'dat' member
     points to the object, or NULL if the object could not be found.

See also:
*Note load_datafile::.
*Note load_datafile_object::.
*Note DATAFILE::.


File: allegro.info,  Node: create_datafile_index,  Next: load_datafile_object_indexed,  Prev: find_datafile_object,  Up: Datafile

1.32.7 create_datafile_index
----------------------------

DATAFILE_INDEX *create_datafile_index(const char *filename);
     Creates an index for a datafile, to speed up loading single objects
     out of it.  This is mostly useful for big datafiles, which you
     don't want to load as a whole.  The index will store the offset of
     all objects inside the datafile, and then you can load it quickly
     with "load_datafile_object_indexed" later.  Use
     destroy_datafile_index to free the memory used by it again.

     Note: If the datafile uses global compression, there is no
     performance gain from using an index, because seeking to the offset
     still requires to uncompress the whole datafile up to that offset.
     Example:

          DATAFILE_INDEX *index = create_datafile_index("huge.dat");
          DATAFILE *object = load_datafile_object_indexed(index, 1234);
          ...
          unload_datafile_object(object);
          destroy_datafile_index(index);

     A pointer value which you can pass to load_datafile_object_indexed.

See also:
*Note destroy_datafile_index::.
*Note load_datafile_object_indexed::.
*Note Using datafiles::.


File: allegro.info,  Node: load_datafile_object_indexed,  Next: destroy_datafile_index,  Prev: create_datafile_index,  Up: Datafile

1.32.8 load_datafile_object_indexed
-----------------------------------

DATAFILE *load_datafile_object_indexed(const DATAFILE_INDEX *index, int item)
     This loads a single object, using the index created previously with
     create_datafile_index.  See create_datafile_index for an example.

     Returns a pointer to a single DATAFILE element whose "dat" member
     points to the object, or NULL if the object could not be loaded.

See also:
*Note create_datafile_index::.
*Note load_datafile_object::.
*Note unload_datafile_object::.
*Note DATAFILE::.


File: allegro.info,  Node: destroy_datafile_index,  Next: get_datafile_property,  Prev: load_datafile_object_indexed,  Up: Datafile

1.32.9 destroy_datafile_index
-----------------------------

void destroy_datafile_index(DATAFILE_INDEX *index)
     This function frees the memory used by a datafile index created
     with create_datafile_index earlier.

See also:
*Note create_datafile_index::.


File: allegro.info,  Node: get_datafile_property,  Next: register_datafile_object,  Prev: destroy_datafile_index,  Up: Datafile

1.32.10 get_datafile_property
-----------------------------

const char *get_datafile_property(const DATAFILE *dat, int type);
     Finds the property type of a DATAFILE object.  The type parameter
     must be a value created with the DAT_ID() macro.  Example:

          const char *name;
          ...
          name = get_datafile_property(game_data,
                                       DAT_ID('N','A','M','E'));
          if (name == empty_string)
             abort_on_error("Object doesn't have a name!");

     Returns a pointer to the text string for the object, or a pointer
     to the variable empty_string if the property isn't present.

See also:
*Note Using datafiles::.
*Note DAT_ID::.
*Note empty_string::.
*Note DATAFILE::.


File: allegro.info,  Node: register_datafile_object,  Next: fixup_datafile,  Prev: get_datafile_property,  Up: Datafile

1.32.11 register_datafile_object
--------------------------------

void register_datafile_object(int id, void *(*load)(PACKFILE *f, long size), void (*destroy)(void *data));
     Used to add custom object types, specifying functions to load and
     destroy objects of this type.

See also:
*Note load_datafile::.
*Note load_datafile_object::.
*Note DAT_ID::.
*Note Custom datafile objects::.
*Note PACKFILE::.


File: allegro.info,  Node: fixup_datafile,  Next: DAT_ID,  Prev: register_datafile_object,  Up: Datafile

1.32.12 fixup_datafile
----------------------

void fixup_datafile(DATAFILE *data);
     If you are using compiled datafiles (produced by the dat2s and
     dat2c utilities) on a platform that doesn't support constructors
     (currently any non GCC-based platform), or if the datafiles contain
     truecolor images, you must call this function once after your set
     the video mode that you will be using.  This will ensure the
     datafiles are properly initialised in the first case and convert
     the color values into the appropriate format in the second case.
     It handles flipping between RGB and BGR formats, and converting
     between different color depths whenever that can be done without
     changing the size of the image (ie.  changing 15<->16-bit hicolor
     for both bitmaps and RLE sprites, and 24<->32-bit truecolor for RLE
     sprites).

     Note that you can only call this once and expect it to work
     correctly, because after the call the DATAFILE you fixed up is
     permanently converted to whatever is the current component ordering
     for your screen mode.  If you call fixup_datafile again, the
     function assumes you have a freshly loaded datafile.  It cannot
     "undo" the previous conversion.

     If your program supports changing resolution and/or color depth
     during runtime, you have two choices: either call fixup_datafile()
     just once and hope that the component ordering and bit depth
     doesn't change when the screen mode changes (unlikely).  Or, you
     can reload your datafiles when the screen mode changes.

See also:
*Note set_gfx_mode::.
*Note set_color_conversion::.
*Note Differences between platforms: Differences.
*Note DATAFILE::.


File: allegro.info,  Node: DAT_ID,  Next: Using datafiles,  Prev: fixup_datafile,  Up: Datafile

1.32.13 DAT_ID
--------------

Macro DAT_ID(a, b, c, d);
     Every object or property in a datafile is identified by a 4 letter
     ID, which can be created with this macro.  For example, to access
     the NAME property of a datafile object, you could use:

          get_datafile_property(datob, DAT_ID('N','A','M','E'));

See also:
*Note register_datafile_object::.
*Note get_datafile_property::.
*Note Custom datafile objects::.
*Note Using datafiles::.


File: allegro.info,  Node: Using datafiles,  Next: Custom datafile objects,  Prev: DAT_ID,  Up: Datafile

1.32.14 Using datafiles
-----------------------

In order to access the contents of a datafile, you will need to know
where each object is located.  The easiest way to do this is by integer
index, using an automatically generated header file.  With the grabber,
type a name into the "Header:" field, and the object indexes will be
written to this file whenever the datafile is saved.  With the dat
utility, use the '-h' option, eg.  "dat filename.dat -h filename.h".
The header will define C preprocessor symbols for each object in the
datafile, for example:

     #define SOME_DATA                        0        /* DATA */
     #define SOME_MORE_DATA                   1        /* DATA */

To prevent name conflicts, you can specify a prefix string for these
definitions by typing it into the "Prefix:" field in the grabber or
using the '-p' option to dat.

To load a datafile into memory, call the function:

     DATAFILE *load_datafile(char *filename);

This will load the entire file, returning a pointer to it, or NULL on
error.  When the data is no longer required, the entire thing can be
destroyed by calling:

     void unload_datafile(DATAFILE *dat);

When you load a datafile, you will obtain a pointer to an array of
DATAFILE structures:

     typedef struct DATAFILE
     {
        void *dat;                    - pointer to the actual data
        int type;                     - object type ID
        long size;                    - size of the data, in bytes
        DATAFILE_PROPERTY *prop;      - list of object properties
     } DATAFILE;

The only really important piece of information here is the 'dat' field,
which points to the contents of the object.  What type of data this is
will depend on the type of object: for bitmaps it will be an Allegro
BITMAP structure, for RLE sprites an RLE_SPRITE, for fonts a FONT
structure, etc.  If you are programming in C you can pass this pointer
directly to the relevant Allegro library functions, but if you are using
C++ you will need to cast it to the appropriate type to prevent the
compiler giving a warning.

For example, if you have a datafile called 'myfile.dat', which contains
a bitmap called COOL_PICTURE, and you have used it to produce a header
called 'myfile.h', you could display the bitmap with the code:

     #include "myfile.h"

     void show_the_bitmap()
     {
        DATAFILE *dat;
        BITMAP *bmp;

        dat = load_datafile("myfile.dat");
        if (!dat) {
           /* report an error! */
           return;
        }

        bmp = (BITMAP *)dat[COOL_PICTURE].dat;
        blit(bmp, screen, 0, 0, 0, 0, bmp->w, bmp->h);
        unload_datafile(dat);
     }

If a datafile contains nested child datafiles, the header will prefix
the names of objects in the sub-files with the name of their parent
datafile.  It will also define a count of the number of objects in the
child file, which may be useful if for example the child datafile
contains several bitmaps which form a 'run' animation, and you want your
code to automatically adjust to the number of frames in the datafile.

For example, the following datafile:

     "FILE" - NESTED_FILE
              |- "BMP" - A_BITMAP
              |- "FONT" - A_FONT
     "DATA" - SOME_DATA
     "DATA" - SOME_MORE_DATA

Will produce the header:

     #define NESTED_FILE                      0        /* FILE */

     #define NESTED_FILE_A_BITMAP             0        /* BMP  */
     #define NESTED_FILE_A_FONT               1        /* FONT */
     #define NESTED_FILE_COUNT                2

     #define SOME_DATA                        1        /* DATA */
     #define SOME_MORE_DATA                   2        /* DATA */

The main datafile contains three objects (NESTED_FILE, SOME_DATA, and
SOME_MORE_DATA) with consecutive indexes, while the child datafile
contains the two objects A_BITMAP and A_FONT. To access these objects
you need to reference both the parent and child datafiles, eg:

     DATAFILE *dat = load_datafile("whatever.dat");
     DATAFILE *nested = (DATAFILE *)dat[NESTED_FILE].dat;
     FONT *thefont = (FONT *)nested[NESTED_FILE_A_FONT].dat;

If you need to access object property strings from within your program,
you can use the function:

     char *get_datafile_property(DATAFILE *dat, int type);

This will return a pointer to the property string if it can be found,
and an empty string (not null!)  if it does not exist.  One possible use
of this function is to locate objects by name, rather than using the
indexes from a header file.  The datafile array is ended by an object of
type DAT_END, so to search the datafile dat for the object "my_object"
you could use the code:

     const int name_type = DAT_ID('N','A','M','E');
     for (i=0; dat[i].type != DAT_END; i++) {
        if (stricmp(get_datafile_property(dat+i, name_type),
                    "my_object") == 0) {
           /* found the object at index i */
        }
     }
     /* not found... */

If you prefer to access objects by name rather than index number, you
can use the function:

     DATAFILE *find_datafile_object(DATAFILE *dat, char *objectname);

This will search an already loaded datafile for an object with the
specified name, returning a pointer to it, or NULL if the object cannot
be found.  It understands '/' and '#' separators for nested datafile
paths.

It is also possible to selectively load individual objects from a
datafile, with the function:

     DATAFILE *load_datafile_object(char *filename, char *objectname);

This searches the datafile for an object with the specified name, so
obviously it won't work if you strip the name properties out of the
file.  Because this function needs to seek through the data, it will be
extremely slow if you have saved the file with global compression.  If
you are planning to load objects individually, you should save the file
uncompressed or with individual compression per-object.  Because the
returned datafile points to a single object rather than an array of
objects, you should access it with the syntax datafile->dat, rather than
datafile[index].dat, and when you are done you should free the object
with the function:

     void unload_datafile_object(DATAFILE *dat);

Example:

     music_object = load_datafile_object("datafile.dat", "MUSIC");
     play_midi(music_object->dat);
     ...
     unload_datafile_object(music_object);

Alternatively, the packfile functions can open and read directly from
the contents of a datafile object.  You do this by calling pack_fopen()
with a fake filename in the form "filename.dat#object_name".  The
contents of the object can then be read in an identical way to a normal
disk file, so any of the file access functions in Allegro (eg.
load_pcx() and set_config_file()) can be used to read from datafile
objects.  Note that you can't write to datafiles in this way: the fake
file is read only.  Also, you should save the file uncompressed or with
per-object compression if you are planning on using this feature.
Finally, be aware that the special Allegro object types aren't the same
format as the files you import the data from, so if for example you want
to use load_pcx to read an image from a datafile, you should import it
as a binary data chunk rather than as a BITMAP object.

If you have appended a datafile to the end of your executable with the
exedat utility, use load_datafile("#") to read the entire thing into
memory, load_datafile_object("#", "object_name") to load a specific
object, and pack_fopen("#object_name", F_READ) to read one of the
objects directly with your own code.  Note that unless you use the
previous functions to load the appended data, the OS will not load it
into memory just because you are running the program, so you shouldn't
have problems attaching datafiles to your binary larger than the
available system memory.

By default, all graphic objects loaded from a datafile will be converted
into the current color depth.  This conversion may be both lossy and
very slow, particularly when reducing from truecolor to 256 color
formats, so you may wish to disable it by calling
set_color_conversion(COLORCONV_NONE) or
set_color_conversion(COLORCONV_PARTIAL) before your call to
load_datafile().


File: allegro.info,  Node: Custom datafile objects,  Next: itofix,  Prev: Using datafiles,  Up: Datafile

1.32.15 Custom datafile objects
-------------------------------

Some of the objects in a datafile, for example palettes and FLI
animations, are simply treated as blocks of binary data, but others are
loaded into special formats such as bitmap structures or compiled
sprites.  It is possible to extend the datafile system to support your
own custom object types, eg.  map objects for a tile based engine, or
level data for a platform game.  Obviously the grabber has no way of
understanding this data, but it will allow you to import binary data
from external files, so you can grab information produced by your own
utilities.  If you are happy with the data being loaded as a simple
binary block, that is all you need to do, but if you need to load it
into a specific structure, read on...

Your custom objects must be given a unique type ID, which is formed from
four ASCII characters (by convention all uppercase A-Z). If you don't
use all four characters, the string should be padded with spaces (ASCII
32).  You should use this ID when creating the objects in the grabber
(select New/Other and type in the ID string), and in your code you
should define an identifier for the type, eg:

     #define DAT_MAPDATA  DAT_ID('M','A','P','D')

You then need to write functions for loading and destroying objects of
this type, in the form:

     void *load_mapdata(PACKFILE *f, long size)
     {
        /* Allegro will call this function whenever an object of your custom
         * type needs to be loaded from a datafile. It will be passed a
         * pointer to the file from which the data is to be read, and the size
         * of the object in bytes. It should return a pointer to the loaded
         * data, which will be stored in the dat field of the datafile object
         * structure, or NULL if an error occurs. The file will have been
         * opened as a sub-chunk of the main datafile, so it is safe to read
         * past the end of the object (if you attempt this, Allegro will
         * return EOF), and it is also safe to return before reading all the
         * data in the chunk (if you do this, Allegro will skip any unused
         * bytes before starting to read the next object). You should _not_
         * close the file when you are done: this will be handled by the
         * calling function. To clarify how all this works, here's an example
         * implementation of a null-terminated string object:
         */

        #define MAX_LEN  256

        char buf[MAX_LEN];
        char *p;
        int i, c;

        for (i=0; i<;MAX_LEN-1; i++) {
           if ((c = pack_getc(f)) == EOF)
              break;

           buf[i] = c;
        }

        buf[i] = 0;

        p = malloc(i+1);
        strcpy(p, buf);

        return p;
     }

     void destroy_mapdata(void *data)
     {
        /* Allegro will call this function whenever an object of your custom
         * type needs to be destroyed. It will be passed a pointer to the
         * object (as returned by the load function), and should free whatever
         * memory the object is using. For example, the simple string object
         * returned by the above loader could be destroyed with the code:
         */

        if (data)
           free(data);
     }

Finally, before you load your datafile you must tell Allegro about the
custom format, by calling:

     register_datafile_object(DAT_MAPDATA, load_mapdata, destroy_mapdata);

It is also possible to integrate support for custom object types
directly into the grabber and dat utilities, by copying some special
files into the tools/plugins directory.  This can be used to add whole
new object types and menu commands, or to provide additional
import/export routines for the existing formats.  See
'tools/plugins/plugins.txt' for an overview of how to write your own
grabber plugins.


File: allegro.info,  Node: Fixed,  Next: 3D,  Prev: Datafile,  Up: API

1.33 Fixed point math routines
==============================

Allegro provides some routines for working with fixed point numbers, and
defines the type 'fixed' to be a signed 32-bit integer.  The high word
is used for the integer part and the low word for the fraction, giving a
range of -32768 to 32767 and an accuracy of about four or five decimal
places.  Fixed point numbers can be assigned, compared, added,
subtracted, negated and shifted (for multiplying or dividing by powers
of two) using the normal integer operators, but you should take care to
use the appropriate conversion routines when mixing fixed point with
integer or floating point values.  Writing 'fixed_point_1 +
fixed_point_2' is OK, but 'fixed_point + integer' is not.

Unfortunately the only advantage of fixed point math routines is that
you don't require a floating point coprocessor to use them.  This was
great in the time period of i386 and i486 machines, but stopped being so
useful with the coming of the Pentium class of processors.  From Pentium
onwards, CPUs have increased their strength in floating point
operations, equaling or even surpassing integer math performance.

Depending on the type of operations your program may need, using
floating point types may be faster than fixed types if you are targeting
a specific machine class.  Allegro comes with a test program in the
'allegro/tests' directory.  Its 'Misc' menu contains a basic profile
test which can give you an idea of the speed difference between fixed
and float types for a few basic operations on your machine.  However,
don't forget to profile your program in real life conditions, tight loop
benchmarks are after all artificial.

Fixed point math is considered "add-on" material and is kept only for
backwards compatibility.  Whenever a future release of Allegro breaks
backwards compatibility, fixed point math will likely be moved to a
separate add-on package for the very few users who still find it
convenient and useful, and Allegro functions using fixed point math will
use other types.

* Menu:

* itofix::
* fixtoi::
* fixfloor::
* fixceil::
* ftofix::
* fixtof::
* fixmul::
* fixdiv::
* fixadd::
* fixsub::
* Fixed point trig::
* fixtorad_r::
* radtofix_r::
* fixsin::
* fixcos::
* fixtan::
* fixasin::
* fixacos::
* fixatan::
* fixatan2::
* fixsqrt::
* fixhypot::
* Fix class::


File: allegro.info,  Node: itofix,  Next: fixtoi,  Prev: Custom datafile objects,  Up: Fixed

1.33.1 itofix
-------------

fixed itofix(int x);
     Converts an integer to fixed point.  This is the same thing as
     x<<16.  Remember that overflows (trying to convert an integer
     greater than 32767) and underflows (trying to convert an integer
     lesser than -32768) are not detected even in debug builds!  The
     values simply "wrap around".  Example:

          fixed number;
          /* This conversion is OK. */
          number = itofix(100);
          ASSERT(fixtoi(number) == 100);
          number = itofix(64000);
          /* This check will fail in debug builds. */
          ASSERT(fixtoi(number) == 64000);

     Returns the value of the integer converted to fixed point ignoring
     overflows.

See also:
*Note fixtoi::.
*Note ftofix::.
*Note fixtof::.
*Note ex12bit::.
*Note ex3buf::.
*Note ex3d::.
*Note exblend::.
*Note excustom::.
*Note exfixed::.
*Note exlights::.
*Note exspline::.
*Note exsprite::.
*Note exstars::.
*Note fixed::.


File: allegro.info,  Node: fixtoi,  Next: fixfloor,  Prev: itofix,  Up: Fixed

1.33.2 fixtoi
-------------

int fixtoi(fixed x);
     Converts fixed point to integer, rounding as required to the
     nearest integer.  Example:

          int result;
          /* This will put 33 into `result'. */
          result = fixtoi(itofix(100) / 3);
          /* But this will round up to 17. */
          result = fixtoi(itofix(100) / 6);

See also:
*Note itofix::.
*Note ftofix::.
*Note fixtof::.
*Note fixfloor::.
*Note fixceil::.
*Note ex12bit::.
*Note ex3buf::.
*Note ex3d::.
*Note exblend::.
*Note excustom::.
*Note exlights::.
*Note exspline::.
*Note exstars::.
*Note exupdate::.
*Note fixed::.


File: allegro.info,  Node: fixfloor,  Next: fixceil,  Prev: fixtoi,  Up: Fixed

1.33.3 fixfloor
---------------

int fixfloor(fixed x);
     Returns the greatest integer not greater than x.  That is, it
     rounds towards negative infinity.  Example:

          int result;
          /* This will put 33 into `result'. */
          result = fixfloor(itofix(100) / 3);
          /* And this will round down to 16. */
          result = fixfloor(itofix(100) / 6);

See also:
*Note fixtoi::.
*Note fixceil::.
*Note fixed::.


File: allegro.info,  Node: fixceil,  Next: ftofix,  Prev: fixfloor,  Up: Fixed

1.33.4 fixceil
--------------

int fixceil(fixed x);
     Returns the smallest integer not less than x.  That is, it rounds
     towards positive infinity.  Example:

          int result;
          /* This will put 34 into `result'. */
          result = fixceil(itofix(100) / 3);
          /* This will round up to 17. */
          result = fixceil(itofix(100) / 6);

See also:
*Note fixtoi::.
*Note fixfloor::.
*Note fixed::.


File: allegro.info,  Node: ftofix,  Next: fixtof,  Prev: fixceil,  Up: Fixed

1.33.5 ftofix
-------------

fixed ftofix(double x);
     Converts a floating point value to fixed point.  Unlike itofix(),
     this function clamps values which could overflow the type
     conversion, setting 'errno' to ERANGE in the process if this
     happens.  Example:

          fixed number;
          number = itofix(-40000);
          ASSERT(fixfloor(number) == -32768);
          number = itofix(64000);
          ASSERT(fixfloor(number) == 32767);
          ASSERT(!errno); /* This will fail. */

     Returns the value of the floating point value converted to fixed
     point clamping overflows (and setting 'errno').

See also:
*Note fixtof::.
*Note itofix::.
*Note fixtoi::.
*Note exfixed::.
*Note exrotscl::.
*Note exspline::.
*Note exupdate::.
*Note fixed::.


File: allegro.info,  Node: fixtof,  Next: fixmul,  Prev: ftofix,  Up: Fixed

1.33.6 fixtof
-------------

double fixtof(fixed x);
     Converts fixed point to floating point.  Example:

          float result;

          /* This will put 33.33333 into `result'. */
          result = fixtof(itofix(100) / 3);
          /* This will put 16.66666 into `result'. */
          result = fixtof(itofix(100) / 6);

See also:
*Note ftofix::.
*Note itofix::.
*Note fixtoi::.
*Note exfixed::.
*Note exspline::.
*Note exstars::.
*Note fixed::.


File: allegro.info,  Node: fixmul,  Next: fixdiv,  Prev: fixtof,  Up: Fixed

1.33.7 fixmul
-------------

fixed fixmul(fixed x, fixed y);
     A fixed point value can be multiplied or divided by an integer with
     the normal '*' and '/' operators.  To multiply two fixed point
     values, though, you must use this function.

     If an overflow occurs, 'errno' will be set and the maximum possible
     value will be returned, but 'errno' is not cleared if the operation
     is successful.  This means that if you are going to test for
     overflow you should set 'errno=0' before calling fixmul().
     Example:

          fixed result;

          /* This will put 30000 into `result'. */
          result = fixmul(itofix(10), itofix(3000));
          /* But this overflows, and sets `errno'. */
          result = fixmul(itofix(100), itofix(3000));
          ASSERT(!errno);

     Returns the clamped result of multiplying 'x' by 'y', setting
     'errno' to ERANGE if there was an overflow.

See also:
*Note fixadd::.
*Note fixsub::.
*Note fixdiv::.
*Note ex3buf::.
*Note excustom::.
*Note exfixed::.
*Note exspline::.
*Note exstars::.
*Note exupdate::.
*Note fixed::.


File: allegro.info,  Node: fixdiv,  Next: fixadd,  Prev: fixmul,  Up: Fixed

1.33.8 fixdiv
-------------

fixed fixdiv(fixed x, fixed y);
     A fixed point value can be divided by an integer with the normal
     '/' operator.  To divide two fixed point values, though, you must
     use this function.  If a division by zero occurs, 'errno' will be
     set and the maximum possible value will be returned, but 'errno' is
     not cleared if the operation is successful.  This means that if you
     are going to test for division by zero you should set 'errno=0'
     before calling fixdiv().  Example:

          fixed result;
          /* This will put 0.06060 `result'. */
          result = fixdiv(itofix(2), itofix(33));
          /* This will put 0 into `result'. */
          result = fixdiv(0, itofix(-30));
          /* Sets `errno' and puts -32768 into `result'. */
          result = fixdiv(itofix(-100), itofix(0));
          ASSERT(!errno); /* This will fail. */

     Returns the result of dividing 'x' by 'y'.  If 'y' is zero, returns
     the maximum possible fixed point value and sets 'errno' to ERANGE.

See also:
*Note fixadd::.
*Note fixsub::.
*Note fixmul::.
*Note exfixed::.
*Note fixed::.


File: allegro.info,  Node: fixadd,  Next: fixsub,  Prev: fixdiv,  Up: Fixed

1.33.9 fixadd
-------------

fixed fixadd(fixed x, fixed y);
     Although fixed point numbers can be added with the normal '+'
     integer operator, that doesn't provide any protection against
     overflow.  If overflow is a problem, you should use this function
     instead.  It is slower than using integer operators, but if an
     overflow occurs it will set 'errno' and clamp the result, rather
     than just letting it wrap.  Example:

          fixed result;
          /* This will put 5035 into `result'. */
          result = fixadd(itofix(5000), itofix(35));
          /* Sets `errno' and puts -32768 into `result'. */
          result = fixadd(itofix(-31000), itofix(-3000));
          ASSERT(!errno); /* This will fail. */

     Returns the clamped result of adding 'x' to 'y', setting 'errno' to
     ERANGE if there was an overflow.

See also:
*Note fixsub::.
*Note fixmul::.
*Note fixdiv::.
*Note fixed::.


File: allegro.info,  Node: fixsub,  Next: Fixed point trig,  Prev: fixadd,  Up: Fixed

1.33.10 fixsub
--------------

fixed fixsub(fixed x, fixed y);
     Although fixed point numbers can be subtracted with the normal '-'
     integer operator, that doesn't provide any protection against
     overflow.  If overflow is a problem, you should use this function
     instead.  It is slower than using integer operators, but if an
     overflow occurs it will set 'errno' and clamp the result, rather
     than just letting it wrap.  Example:

          fixed result;
          /* This will put 4965 into `result'. */
          result = fixsub(itofix(5000), itofix(35));
          /* Sets `errno' and puts -32768 into `result'. */
          result = fixsub(itofix(-31000), itofix(3000));
          ASSERT(!errno); /* This will fail. */

     Returns the clamped result of subtracting 'y' from 'x', setting
     'errno' to ERANGE if there was an overflow.

See also:
*Note fixadd::.
*Note fixmul::.
*Note fixdiv::.
*Note fixed::.


File: allegro.info,  Node: Fixed point trig,  Next: fixtorad_r,  Prev: fixsub,  Up: Fixed

1.33.11 Fixed point trig
------------------------

The fixed point square root, sin, cos, tan, inverse sin, and inverse cos
functions are implemented using lookup tables, which are very fast but
not particularly accurate.  At the moment the inverse tan uses an
iterative search on the tan table, so it is a lot slower than the
others.  Note that on machines with very good floating point processors
using these functions could be slower in real life code due to cache
misses: it may be faster to wait a few extra cycles for a floating point
sine result rather than wait for the CPU to fetch the precalculated
table from main memory.  Always profile your code.

Angles are represented in a binary format with 256 equal to a full
circle, 64 being a right angle and so on.  This has the advantage that a
simple bitwise 'and' can be used to keep the angle within the range zero
to a full circle, eliminating all those tiresome 'if (angle >= 360)'
checks.


File: allegro.info,  Node: fixtorad_r,  Next: radtofix_r,  Prev: Fixed point trig,  Up: Fixed

1.33.12 fixtorad_r
------------------

extern const fixed fixtorad_r;
     This constant gives a ratio which can be used to convert a fixed
     point number in binary angle format to a fixed point number in
     radians.  Example:

          fixed rad_angle, binary_angle;
          /* Set the binary angle to 90 degrees. */
          binary_angle = 64;
          /* Now convert to radians (about 1.57). */
          rad_angle = fixmul(binary_angle, fixtorad_r);

See also:
*Note fixmul::.
*Note radtofix_r::.
*Note fixed::.


File: allegro.info,  Node: radtofix_r,  Next: fixsin,  Prev: fixtorad_r,  Up: Fixed

1.33.13 radtofix_r
------------------

extern const fixed radtofix_r;
     This constant gives a ratio which can be used to convert a fixed
     point number in radians to a fixed point number in binary angle
     format.  Example:

          fixed rad_angle, binary_angle;
          ...
          binary_angle = fixmul(rad_angle, radtofix_r);

See also:
*Note fixmul::.
*Note fixtorad_r::.
*Note fixed::.


File: allegro.info,  Node: fixsin,  Next: fixcos,  Prev: radtofix_r,  Up: Fixed

1.33.14 fixsin
--------------

fixed fixsin(fixed x);
     This function finds the sine of a value using a lookup table.  The
     input value must be a fixed point binary angle.  Example:

          fixed angle;
          int result;

          /* Set the binary angle to 90 degrees. */
          angle = itofix(64);
          /* The sine of 90 degrees is one. */
          result = fixtoi(fixsin(angle));
          ASSERT(result == 1);

     Returns the sine of a fixed point binary format angle.  The return
     value will be in radians.

See also:
*Note Fixed point trig::.
*Note ex12bit::.
*Note ex3buf::.
*Note exblend::.
*Note excustom::.
*Note exspline::.
*Note exupdate::.
*Note fixed::.


File: allegro.info,  Node: fixcos,  Next: fixtan,  Prev: fixsin,  Up: Fixed

1.33.15 fixcos
--------------

fixed fixcos(fixed x);
     This function finds the cosine of a value using a lookup table.
     The input value must be a fixed point binary angle.  Example:

          fixed angle;
          float result;

          /* Set the binary angle to 45 degrees. */
          angle = itofix(32);
          /* The cosine of 45 degrees is about 0.7071. */
          result = fixtof(fixcos(angle));
          ASSERT(result > 0.7 && result < 0.71);

     Returns the cosine of a fixed point binary format angle.  The
     return value will be in radians.

See also:
*Note Fixed point trig::.
*Note ex12bit::.
*Note ex3buf::.
*Note exblend::.
*Note excustom::.
*Note exspline::.
*Note exupdate::.
*Note fixed::.


File: allegro.info,  Node: fixtan,  Next: fixasin,  Prev: fixcos,  Up: Fixed

1.33.16 fixtan
--------------

fixed fixtan(fixed x);
     This function finds the tangent of a value using a lookup table.
     The input value must be a fixed point binary angle.  Example:

          fixed angle, res_a, res_b;
          float dif;

          angle = itofix(37);
          /* Prove that tan(angle) == sin(angle) / cos(angle). */
          res_a = fixdiv(fixsin(angle), fixcos(angle));
          res_b = fixtan(angle);
          dif = fixtof(fixsub(res_a, res_b));
          allegro_message("Precision error: %f\n", dif);

     Returns the tangent of a fixed point binary format angle.  The
     return value will be in radians.

See also:
*Note Fixed point trig::.
*Note fixed::.


File: allegro.info,  Node: fixasin,  Next: fixacos,  Prev: fixtan,  Up: Fixed

1.33.17 fixasin
---------------

fixed fixasin(fixed x);
     This function finds the inverse sine of a value using a lookup
     table.  The input value must be a fixed point value.  The inverse
     sine is defined only in the domain from '-1' to '1'.  Outside of
     this input range, the function will set 'errno' to EDOM and return
     zero.  Example:

          float angle;
          fixed val;

          /* Sets `val' to a right binary angle (`64'). */
          val = fixasin(itofix(1));
          /* Sets `angle' to 0.2405. */
          angle = fixtof(fixmul(fixasin(ftofix(0.238)), fixtorad_r));
          /* This will trigger the assert. */
          val = fixasin(ftofix(-1.09));
          ASSERT(!errno);

     Returns the inverse sine of a fixed point value, measured as fixed
     point binary format angle, or zero if the input was out of the
     range.  All return values of this function will be in the range
     '-64' to '64'.

See also:
*Note Fixed point trig::.
*Note fixed::.


File: allegro.info,  Node: fixacos,  Next: fixatan,  Prev: fixasin,  Up: Fixed

1.33.18 fixacos
---------------

fixed fixacos(fixed x);
     This function finds the inverse cosine of a value using a lookup
     table.  The input value must be a fixed point radian.  The inverse
     cosine is defined only in the domain from '-1' to '1'.  Outside of
     this input range, the function will set 'errno' to EDOM and return
     zero.  Example:

          fixed result;

          /* Sets `result' to binary angle 128. */
          result = fixacos(itofix(-1));

     Returns the inverse sine of a fixed point value, measured as fixed
     point binary format angle, or zero if the input was out of range.
     All return values of this function will be in the range '0' to
     '128'.

See also:
*Note Fixed point trig::.
*Note fixed::.


File: allegro.info,  Node: fixatan,  Next: fixatan2,  Prev: fixacos,  Up: Fixed

1.33.19 fixatan
---------------

fixed fixatan(fixed x);
     This function finds the inverse tangent of a value using a lookup
     table.  The input value must be a fixed point radian.  The inverse
     tangent is the value whose tangent is 'x'.  Example:

          fixed result;

          /* Sets `result' to binary angle 13. */
          result = fixatan(ftofix(0.326));

     Returns the inverse tangent of a fixed point value, measured as a
     fixed point binary format angle.

See also:
*Note Fixed point trig::.
*Note fixed::.


File: allegro.info,  Node: fixatan2,  Next: fixsqrt,  Prev: fixatan,  Up: Fixed

1.33.20 fixatan2
----------------

fixed fixatan2(fixed y, fixed x);
     This is a fixed point version of the libc atan2() routine.  It
     computes the arc tangent of 'y / x', but the signs of both
     arguments are used to determine the quadrant of the result, and 'x'
     is permitted to be zero.  This function is useful to convert
     Cartesian coordinates to polar coordinates.  Example:

          fixed result;

          /* Sets `result' to binary angle 64. */
          result = fixatan2(itofix(1), 0);
          /* Sets `result' to binary angle -109. */
          result = fixatan2(itofix(-1), itofix(-2));
          /* Fails the assert. */
          result = fixatan2(0, 0);
          ASSERT(!errno);

     Returns the arc tangent of 'y / x' in fixed point binary format
     angle, from '-128' to '128'.  If both 'x' and 'y' are zero, returns
     zero and sets 'errno' to EDOM.

See also:
*Note Fixed point trig::.
*Note exlights::.
*Note exspline::.
*Note fixed::.


File: allegro.info,  Node: fixsqrt,  Next: fixhypot,  Prev: fixatan2,  Up: Fixed

1.33.21 fixsqrt
---------------

fixed fixsqrt(fixed x);
     This finds out the non negative square root of 'x'.  If 'x' is
     negative, 'errno' is set to EDOM and the function returns zero.

See also:
*Note Fixed point trig::.
*Note exfixed::.
*Note exlights::.
*Note exspline::.
*Note fixed::.


File: allegro.info,  Node: fixhypot,  Next: Fix class,  Prev: fixsqrt,  Up: Fixed

1.33.22 fixhypot
----------------

fixed fixhypot(fixed x, fixed y);
     Fixed point hypotenuse (returns the square root of 'x*x + y*y').
     This should be better than calculating the formula yourself
     manually, since the error is much smaller.

See also:
*Note Fixed point trig::.
*Note fixed::.


File: allegro.info,  Node: Fix class,  Next: identity_matrix,  Prev: fixhypot,  Up: Fixed

1.33.23 Fix class
-----------------

If you are programming in C++ you can ignore all the above and use the
fix class instead, which overloads a lot of operators to provide
automatic conversion to and from integer and floating point values, and
calls the above routines as they are required.  You should not mix the
fix class with the fixed typedef though, because the compiler will
mistake the fixed values for regular integers and insert unnecessary
conversions.  For example, if x is an object of class fix, calling
fixsqrt(x) will return the wrong result.  You should use the overloaded
sqrt(x) or x.sqrt() instead.

On top of that, the Fix class may be slower than using directly the C
functions because of implicit internal conversions from one type to
another which you otherwise could avoid or minimise.  Finally, this is
the only bit of C++ in the whole Allegro library, and the developers are
certainly going to move it into add-on space in the next version of
Allegro which breaks source backwards compatibility.


File: allegro.info,  Node: 3D,  Next: Quaternion,  Prev: Fixed,  Up: API

1.34 3D math routines
=====================

Allegro contains some 3d helper functions for manipulating vectors,
constructing and using transformation matrices, and doing perspective
projections from 3d space onto the screen.  It is not, and never will
be, a fully fledged 3d library (the goal is to supply generic support
routines, not shrink-wrapped graphics code :-) but these functions may
be useful for developing your own 3d code.

Allegro uses a right-handed coordinate system, i.e.  if you point the
thumb of your right hand along the x axis, and the index finger along
the y axis, your middle finger points in the direction of the z axis.

Allegro's world coordinate system typically has the positive x axis
right, the positive y axis up, and the positive z axis out of the
screen.  What all this means is this: Assume, the viewer is located at
the origin (0/0/0) in world space, looks along the negative z axis
(0/0/-1), and is oriented so up is along the positive y axis (0/1/0).
Then something located at (100/200/-300) will be 100 to the right, 200
above, and 300 in front of the viewer.  Just like in OpenGL. (Of course,
both OpenGL and Allegro allow to use a different system.)  Here's a
short piece of code demonstrating the transformation pipeline of a point
from world space to the screen.


     /* First, set up the projection viewport. */
     set_projection_viewport (0, 0, SCREEN_W, SCREEN_H);

     /* Next, get a camera matrix, depending on the
      * current viewer position and orientation.
      */
     get_camera_matrix_f (&m,
        0, 0, 0,  /* Viewer position, in this case, 0/0/0. */
        0, 0, -1, /* Viewer direction, in this case along negative z. */
        0, 1, 0,  /* Up vector, in this case positive y. */
        32,       /* The FOV, here 45. */
        (float)SCREEN_W / (float)SCREEN_H)); /* Aspect ratio. */

     /* Applying the matrix transforms the point 100/200/-300
      * from world space into camera space. The transformation
      * moves and rotates the point so it is relative to the
      * camera, scales it according to the FOV and aspect
      * parameters, and also flips up and front direction -
      * ready to project the point to the viewport.
      */
     apply_matrix_f (&m, 100, 200, -300, &x, &y, &z);

     /* Finally, the point is projected from
      * camera space to the screen.
      */
     persp_project_f (cx, cy, cz, &sx, &sy);

For more details, look at the function descriptions of
set_projection_viewport(), get_camera_matrix(), and persp_project(), as
well as the relevant example programs.

All the 3d math functions are available in two versions: one which uses
fixed point arithmetic, and another which uses floating point.  The
syntax for these is identical, but the floating point functions and
structures are postfixed with '_f', eg.  the fixed point function
cross_product() has a floating point equivalent cross_product_f().  If
you are programming in C++, Allegro also overloads these functions for
use with the 'fix' class.

3d transformations are accomplished by the use of a modelling matrix.
This is a 4x4 array of numbers that can be multiplied with a 3d point to
produce a different 3d point.  By putting the right values into the
matrix, it can be made to do various operations like translation,
rotation, and scaling.  The clever bit is that you can multiply two
matrices together to produce a third matrix, and this will have the same
effect on points as applying the original two matrices one after the
other.  For example, if you have one matrix that rotates a point and
another that shifts it sideways, you can combine them to produce a
matrix that will do the rotation and the shift in a single step.  You
can build up extremely complex transformations in this way, while only
ever having to multiply each point by a single matrix.

Allegro actually cheats in the way it implements the matrix structure.
Rotation and scaling of a 3d point can be done with a simple 3x3 matrix,
but in order to translate it and project it onto the screen, the matrix
must be extended to 4x4, and the point extended into 4d space by the
addition of an extra coordinate, w=1.  This is a bad thing in terms of
efficiency, but fortunately an optimisation is possible.  Given the 4x4
matrix:

     ( a, b, c, d )
     ( e, f, g, h )
     ( i, j, k, l )
     ( m, n, o, p )

a pattern can be observed in which parts of it do what.  The top left
3x3 grid implements rotation and scaling.  The three values in the top
right column (d, h, and l) implement translation, and as long as the
matrix is only used for affine transformations, m, n and o will always
be zero and p will always be 1.  If you don't know what affine means,
read Foley & Van Damme: basically it covers scaling, translation, and
rotation, but not projection.  Since Allegro uses a separate function
for projection, the matrix functions only need to support affine
transformations, which means that there is no need to store the bottom
row of the matrix.  Allegro implicitly assumes that it contains
(0,0,0,1), and optimises the matrix manipulation functions accordingly.
Read chapter "Structures and types defined by Allegro" for an internal
view of the MATRIX/_f structures.

* Menu:

* identity_matrix::
* get_translation_matrix::
* get_scaling_matrix::
* get_x_rotate_matrix::
* get_y_rotate_matrix::
* get_z_rotate_matrix::
* get_rotation_matrix::
* get_align_matrix::
* get_align_matrix_f::
* get_vector_rotation_matrix::
* get_transformation_matrix::
* get_transformation_matrix_f::
* get_camera_matrix::
* get_camera_matrix_f::
* qtranslate_matrix::
* qscale_matrix::
* matrix_mul::
* vector_length::
* normalize_vector::
* dot_product::
* cross_product::
* polygon_z_normal::
* apply_matrix::
* set_projection_viewport::
* persp_project::


File: allegro.info,  Node: identity_matrix,  Next: get_translation_matrix,  Prev: Fix class,  Up: 3D

1.34.1 identity_matrix
----------------------

extern MATRIX identity_matrix;
extern MATRIX_f identity_matrix_f;
     Global variables containing the 'do nothing' identity matrix.
     Multiplying by the identity matrix has no effect.

*Note MATRIX::.
*Note MATRIX_f::.


File: allegro.info,  Node: get_translation_matrix,  Next: get_scaling_matrix,  Prev: identity_matrix,  Up: 3D

1.34.2 get_translation_matrix
-----------------------------

void get_translation_matrix(MATRIX *m, fixed x, fixed y, fixed z);
void get_translation_matrix_f(MATRIX_f *m, float x, float y, float z);
     Constructs a translation matrix, storing it in m.  When applied to
     the point (px, py, pz), this matrix will produce the point (px+x,
     py+y, pz+z).  In other words, it moves things sideways.

See also:
*Note apply_matrix::.
*Note get_transformation_matrix::.
*Note qtranslate_matrix::.
*Note exstars::.
*Note fixed::.
*Note MATRIX::.
*Note MATRIX_f::.


File: allegro.info,  Node: get_scaling_matrix,  Next: get_x_rotate_matrix,  Prev: get_translation_matrix,  Up: 3D

1.34.3 get_scaling_matrix
-------------------------

void get_scaling_matrix(MATRIX *m, fixed x, fixed y, fixed z);
void get_scaling_matrix_f(MATRIX_f *m, float x, float y, float z);
     Constructs a scaling matrix, storing it in m.  When applied to the
     point (px, py, pz), this matrix will produce the point (px*x, py*y,
     pz*z).  In other words, it stretches or shrinks things.

See also:
*Note apply_matrix::.
*Note get_transformation_matrix::.
*Note qscale_matrix::.
*Note fixed::.
*Note MATRIX::.
*Note MATRIX_f::.


File: allegro.info,  Node: get_x_rotate_matrix,  Next: get_y_rotate_matrix,  Prev: get_scaling_matrix,  Up: 3D

1.34.4 get_x_rotate_matrix
--------------------------

void get_x_rotate_matrix(MATRIX *m, fixed r);
void get_x_rotate_matrix_f(MATRIX_f *m, float r);
     Construct X axis rotation matrices, storing them in m.  When
     applied to a point, these matrices will rotate it about the X axis
     by the specified angle (given in binary, 256 degrees to a circle
     format).

See also:
*Note apply_matrix::.
*Note get_rotation_matrix::.
*Note get_y_rotate_matrix::.
*Note get_z_rotate_matrix::.
*Note fixed::.
*Note MATRIX::.
*Note MATRIX_f::.


File: allegro.info,  Node: get_y_rotate_matrix,  Next: get_z_rotate_matrix,  Prev: get_x_rotate_matrix,  Up: 3D

1.34.5 get_y_rotate_matrix
--------------------------

void get_y_rotate_matrix(MATRIX *m, fixed r);
void get_y_rotate_matrix_f(MATRIX_f *m, float r);
     Construct Y axis rotation matrices, storing them in m.  When
     applied to a point, these matrices will rotate it about the Y axis
     by the specified angle (given in binary, 256 degrees to a circle
     format).

See also:
*Note apply_matrix::.
*Note get_rotation_matrix::.
*Note get_x_rotate_matrix::.
*Note get_z_rotate_matrix::.
*Note fixed::.
*Note MATRIX::.
*Note MATRIX_f::.


File: allegro.info,  Node: get_z_rotate_matrix,  Next: get_rotation_matrix,  Prev: get_y_rotate_matrix,  Up: 3D

1.34.6 get_z_rotate_matrix
--------------------------

void get_z_rotate_matrix(MATRIX *m, fixed r);
void get_z_rotate_matrix_f(MATRIX_f *m, float r);
     Construct Z axis rotation matrices, storing them in m.  When
     applied to a point, these matrices will rotate it about the Z axis
     by the specified angle (given in binary, 256 degrees to a circle
     format).

See also:
*Note apply_matrix::.
*Note get_rotation_matrix::.
*Note get_x_rotate_matrix::.
*Note get_y_rotate_matrix::.
*Note fixed::.
*Note MATRIX::.
*Note MATRIX_f::.


File: allegro.info,  Node: get_rotation_matrix,  Next: get_align_matrix,  Prev: get_z_rotate_matrix,  Up: 3D

1.34.7 get_rotation_matrix
--------------------------

void get_rotation_matrix(MATRIX *m, fixed x, fixed y, fixed z);
void get_rotation_matrix_f(MATRIX_f *m, float x, float y, float z);
     Constructs a transformation matrix which will rotate points around
     all three axes by the specified amounts (given in binary, 256
     degrees to a circle format).  The direction of rotation can simply
     be found out with the right-hand rule: Point the dumb of your right
     hand towards the origin along the axis of rotation, and the fingers
     will curl in the positive direction of rotation.  E.g.  if you
     rotate around the y axis, and look at the scene from above, a
     positive angle will rotate in clockwise direction.

See also:
*Note apply_matrix::.
*Note get_transformation_matrix::.
*Note get_vector_rotation_matrix::.
*Note get_x_rotate_matrix::.
*Note get_y_rotate_matrix::.
*Note get_z_rotate_matrix::.
*Note get_align_matrix::.
*Note ex12bit::.
*Note exquat::.
*Note exstars::.
*Note fixed::.
*Note MATRIX::.
*Note MATRIX_f::.


File: allegro.info,  Node: get_align_matrix,  Next: get_align_matrix_f,  Prev: get_rotation_matrix,  Up: 3D

1.34.8 get_align_matrix
-----------------------

void get_align_matrix(MATRIX *m, fixed xfront, yfront, zfront, fixed xup, fixed yup, fixed zup);
     Rotates a matrix so that it is aligned along the specified
     coordinate vectors (they need not be normalized or perpendicular,
     but the up and front must not be equal).  A front vector of 0,0,-1
     and up vector of 0,1,0 will return the identity matrix.

See also:
*Note apply_matrix::.
*Note get_camera_matrix::.
*Note fixed::.
*Note MATRIX::.


File: allegro.info,  Node: get_align_matrix_f,  Next: get_vector_rotation_matrix,  Prev: get_align_matrix,  Up: 3D

1.34.9 get_align_matrix_f
-------------------------

void get_align_matrix_f(MATRIX *m, float xfront, yfront, zfront, float xup, yup, zup);
     Floating point version of get_align_matrix().

See also:
*Note get_align_matrix::.
*Note MATRIX::.


File: allegro.info,  Node: get_vector_rotation_matrix,  Next: get_transformation_matrix,  Prev: get_align_matrix_f,  Up: 3D

1.34.10 get_vector_rotation_matrix
----------------------------------

void get_vector_rotation_matrix(MATRIX *m, fixed x, y, z, fixed a);
void get_vector_rotation_matrix_f(MATRIX_f *m, float x, y, z, float a);
     Constructs a transformation matrix which will rotate points around
     the specified x,y,z vector by the specified angle (given in binary,
     256 degrees to a circle format).

See also:
*Note apply_matrix::.
*Note get_rotation_matrix::.
*Note get_align_matrix::.
*Note excamera::.
*Note fixed::.
*Note MATRIX::.
*Note MATRIX_f::.


File: allegro.info,  Node: get_transformation_matrix,  Next: get_transformation_matrix_f,  Prev: get_vector_rotation_matrix,  Up: 3D

1.34.11 get_transformation_matrix
---------------------------------

void get_transformation_matrix(MATRIX *m, fixed scale, fixed xrot, yrot, zrot, x, y, z);
     Constructs a transformation matrix which will rotate points around
     all three axes by the specified amounts (given in binary, 256
     degrees to a circle format), scale the result by the specified
     amount (pass 1 for no change of scale), and then translate to the
     requested x, y, z position.

See also:
*Note apply_matrix::.
*Note get_rotation_matrix::.
*Note get_scaling_matrix::.
*Note get_translation_matrix::.
*Note ex3d::.
*Note exstars::.
*Note fixed::.
*Note MATRIX::.


File: allegro.info,  Node: get_transformation_matrix_f,  Next: get_camera_matrix,  Prev: get_transformation_matrix,  Up: 3D

1.34.12 get_transformation_matrix_f
-----------------------------------

void get_transformation_matrix_f(MATRIX_f *m, float scale, float xrot, yrot, zrot, x, y, z);
     Floating point version of get_transformation_matrix().

See also:
*Note get_transformation_matrix::.
*Note exzbuf::.
*Note MATRIX_f::.


File: allegro.info,  Node: get_camera_matrix,  Next: get_camera_matrix_f,  Prev: get_transformation_matrix_f,  Up: 3D

1.34.13 get_camera_matrix
-------------------------

void get_camera_matrix(MATRIX *m, fixed x, y, z, xfront, yfront, zfront, fixed xup, yup, zup, fov, aspect);
     Constructs a camera matrix for translating world-space objects into
     a normalised view space, ready for the perspective projection.  The
     x, y, and z parameters specify the camera position, xfront, yfront,
     and zfront are the 'in front' vector specifying which way the
     camera is facing (this can be any length: normalisation is not
     required), and xup, yup, and zup are the 'up' direction vector.

     The fov parameter specifies the field of view (ie.  width of the
     camera focus) in binary, 256 degrees to the circle format.  For
     typical projections, a field of view in the region 32-48 will work
     well.  64 (90) applies no extra scaling - so something which is
     one unit away from the viewer will be directly scaled to the
     viewport.  A bigger FOV moves you closer to the viewing plane, so
     more objects will appear.  A smaller FOV moves you away from the
     viewing plane, which means you see a smaller part of the world.

     Finally, the aspect ratio is used to scale the Y dimensions of the
     image relative to the X axis, so you can use it to adjust the
     proportions of the output image (set it to 1 for no scaling - but
     keep in mind that the projection also performs scaling according to
     the viewport size).  Typically, you will pass (float)w/(float)h,
     where w and h are the parameters you passed to
     set_projection_viewport.

     Note that versions prior to 4.1.0 multiplied this aspect ratio by
     4/3.

See also:
*Note apply_matrix::.
*Note get_align_matrix::.
*Note set_projection_viewport::.
*Note persp_project::.
*Note fixed::.
*Note MATRIX::.


File: allegro.info,  Node: get_camera_matrix_f,  Next: qtranslate_matrix,  Prev: get_camera_matrix,  Up: 3D

1.34.14 get_camera_matrix_f
---------------------------

void get_camera_matrix_f(MATRIX_f *m, float x, y, z, xfront, yfront, zfront, float xup, yup, zup, fov, aspect);
     Floating point version of get_camera_matrix().

See also:
*Note get_camera_matrix::.
*Note excamera::.
*Note exquat::.
*Note MATRIX_f::.


File: allegro.info,  Node: qtranslate_matrix,  Next: qscale_matrix,  Prev: get_camera_matrix_f,  Up: 3D

1.34.15 qtranslate_matrix
-------------------------

void qtranslate_matrix(MATRIX *m, fixed x, fixed y, fixed z);
void qtranslate_matrix_f(MATRIX_f *m, float x, float y, float z);
     Optimised routine for translating an already generated matrix: this
     simply adds in the translation offset, so there is no need to build
     two temporary matrices and then multiply them together.

See also:
*Note get_translation_matrix::.
*Note fixed::.
*Note MATRIX::.
*Note MATRIX_f::.


File: allegro.info,  Node: qscale_matrix,  Next: matrix_mul,  Prev: qtranslate_matrix,  Up: 3D

1.34.16 qscale_matrix
---------------------

void qscale_matrix(MATRIX *m, fixed scale);
void qscale_matrix_f(MATRIX_f *m, float scale);
     Optimised routine for scaling an already generated matrix: this
     simply adds in the scale factor, so there is no need to build two
     temporary matrices and then multiply them together.

See also:
*Note get_scaling_matrix::.
*Note fixed::.
*Note MATRIX::.
*Note MATRIX_f::.


File: allegro.info,  Node: matrix_mul,  Next: vector_length,  Prev: qscale_matrix,  Up: 3D

1.34.17 matrix_mul
------------------

void matrix_mul(const MATRIX *m1, const MATRIX *m2, MATRIX *out);
void matrix_mul_f(const MATRIX_f *m1, const MATRIX_f *m2, MATRIX_f *out);
     Multiplies two matrices, storing the result in out (this may be a
     duplicate of one of the input matrices, but it is faster when the
     inputs and output are all different).  The resulting matrix will
     have the same effect as the combination of m1 and m2, ie.  when
     applied to a point p, (p * out) = ((p * m1) * m2).  Any number of
     transformations can be concatenated in this way.  Note that matrix
     multiplication is not commutative, ie.  matrix_mul(m1, m2) !=
     matrix_mul(m2, m1).

See also:
*Note apply_matrix::.
*Note exquat::.
*Note exscn3d::.
*Note MATRIX::.
*Note MATRIX_f::.


File: allegro.info,  Node: vector_length,  Next: normalize_vector,  Prev: matrix_mul,  Up: 3D

1.34.18 vector_length
---------------------

fixed vector_length(fixed x, fixed y, fixed z);
float vector_length_f(float x, float y, float z);
     Calculates the length of the vector (x, y, z), using that good 'ole
     Pythagoras theorem.

See also:
*Note normalize_vector::.
*Note fixed::.


File: allegro.info,  Node: normalize_vector,  Next: dot_product,  Prev: vector_length,  Up: 3D

1.34.19 normalize_vector
------------------------

void normalize_vector(fixed *x, fixed *y, fixed *z);
void normalize_vector_f(float *x, float *y, float *z);
     Converts the vector (*x, *y, *z) to a unit vector.  This points in
     the same direction as the original vector, but has a length of one.

See also:
*Note vector_length::.
*Note dot_product::.
*Note cross_product::.
*Note exstars::.
*Note fixed::.


File: allegro.info,  Node: dot_product,  Next: cross_product,  Prev: normalize_vector,  Up: 3D

1.34.20 dot_product
-------------------

fixed dot_product(fixed x1, y1, z1, x2, y2, z2);
float dot_product_f(float x1, y1, z1, x2, y2, z2);
     Calculates the dot product (x1, y1, z1) .  (x2, y2, z2), returning
     the result.

See also:
*Note cross_product::.
*Note normalize_vector::.
*Note exstars::.
*Note fixed::.


File: allegro.info,  Node: cross_product,  Next: polygon_z_normal,  Prev: dot_product,  Up: 3D

1.34.21 cross_product
---------------------

void cross_product(fixed x1, y1, z1, x2, y2, z2, *xout, *yout, *zout);
void cross_product_f(float x1, y1, z1, x2, y2, z2, *xout, *yout, *zout);
     Calculates the cross product (x1, y1, z1) x (x2, y2, z2), storing
     the result in (*xout, *yout, *zout).  The cross product is
     perpendicular to both of the input vectors, so it can be used to
     generate polygon normals.

See also:
*Note dot_product::.
*Note polygon_z_normal::.
*Note normalize_vector::.
*Note exstars::.
*Note fixed::.


File: allegro.info,  Node: polygon_z_normal,  Next: apply_matrix,  Prev: cross_product,  Up: 3D

1.34.22 polygon_z_normal
------------------------

fixed polygon_z_normal(const V3D *v1, const V3D *v2, const V3D *v3);
float polygon_z_normal_f(const V3D_f *v1, const V3D_f *v2, const V3D_f *v3);
     Finds the Z component of the normal vector to the specified three
     vertices (which must be part of a convex polygon).  This is used
     mainly in back-face culling.  The back-faces of closed polyhedra
     are never visible to the viewer, therefore they never need to be
     drawn.  This can cull on average half the polygons from a scene.
     If the normal is negative the polygon can safely be culled.  If it
     is zero, the polygon is perpendicular to the screen.

     However, this method of culling back-faces must only be used once
     the X and Y coordinates have been projected into screen space using
     persp_project() (or if an orthographic (isometric) projection is
     being used).  Note that this function will fail if the three
     vertices are co-linear (they lie on the same line) in 3D space.

See also:
*Note cross_product::.
*Note ex3d::.
*Note fixed::.
*Note V3D::.
*Note V3D_f::.


File: allegro.info,  Node: apply_matrix,  Next: set_projection_viewport,  Prev: polygon_z_normal,  Up: 3D

1.34.23 apply_matrix
--------------------

void apply_matrix(const MATRIX *m, fixed x, y, z, *xout, *yout, *zout);
void apply_matrix_f(const MATRIX_f *m, float x, y, z, *xout, *yout, *zout);
     Multiplies the point (x, y, z) by the transformation matrix m,
     storing the result in (*xout, *yout, *zout).

See also:
*Note matrix_mul::.
*Note ex12bit::.
*Note ex3d::.
*Note exstars::.
*Note fixed::.
*Note MATRIX::.
*Note MATRIX_f::.


File: allegro.info,  Node: set_projection_viewport,  Next: persp_project,  Prev: apply_matrix,  Up: 3D

1.34.24 set_projection_viewport
-------------------------------

void set_projection_viewport(int x, int y, int w, int h);
     Sets the viewport used to scale the output of the persp_project()
     function.  Pass the dimensions of the screen area you want to draw
     onto, which will typically be 0, 0, SCREEN_W, and SCREEN_H. Also
     don't forget to pass an appropriate aspect ratio to
     get_camera_matrix later.  The width and height you specify here
     will determine how big your viewport is in 3d space.  So if an
     object in your 3D space is w units wide, it will fill the complete
     screen when you run into it (i.e., if it has a distance of 1.0
     after the camera matrix was applied.  The fov and aspect-ratio
     parameters to get_camera_matrix also apply some scaling though, so
     this isn't always completely true).  If you pass -1/-1/2/2 as
     parameters, no extra scaling will be performed by the projection.

See also:
*Note persp_project::.
*Note get_camera_matrix::.
*Note ex3d::.
*Note excamera::.
*Note exquat::.
*Note exscn3d::.
*Note exstars::.
*Note exzbuf::.


File: allegro.info,  Node: persp_project,  Next: identity_quat,  Prev: set_projection_viewport,  Up: 3D

1.34.25 persp_project
---------------------

void persp_project(fixed x, fixed y, fixed z, fixed *xout, fixed *yout);
void persp_project_f(float x, float y, float z, float *xout, float *yout);
     Projects the 3d point (x, y, z) into 2d screen space, storing the
     result in (*xout, *yout) and using the scaling parameters
     previously set by calling set_projection_viewport().  This function
     projects from the normalized viewing pyramid, which has a camera at
     the origin and facing along the positive z axis.  The x axis runs
     left/right, y runs up/down, and z increases with depth into the
     screen.  The camera has a 90 degree field of view, ie.  points on
     the planes x=z and -x=z will map onto the left and right edges of
     the screen, and the planes y=z and -y=z map to the top and bottom
     of the screen.  If you want a different field of view or camera
     location, you should transform all your objects with an appropriate
     viewing matrix, eg.  to get the effect of panning the camera 10
     degrees to the left, rotate all your objects 10 degrees to the
     right.

See also:
*Note set_projection_viewport::.
*Note get_camera_matrix::.
*Note ex3d::.
*Note exstars::.
*Note fixed::.


File: allegro.info,  Node: Quaternion,  Next: GUI,  Prev: 3D,  Up: API

1.35 Quaternion math routines
=============================

Quaternions are an alternate way to represent the rotation part of a
transformation, and can be easier to manipulate than matrices.  As with
a matrix, you can encode a geometric transformations in one, concatenate
several of them to merge multiple transformations, and apply them to a
vector, but they can only store pure rotations.  The big advantage is
that you can accurately interpolate between two quaternions to get a
part-way rotation, avoiding the gimbal problems of the more conventional
Euler angle interpolation.

Quaternions only have floating point versions, without any _f suffix.
Other than that, most of the quaternion functions correspond with a
matrix function that performs a similar operation.

Quaternion means 'of four parts', and that's exactly what it is.  Here
is the structure:

     typedef struct QUAT
     {
        float w, x, y, z;
     }

You will have lots of fun figuring out what these numbers actually mean,
but that is beyond the scope of this documentation.  Quaternions do work
- trust me.

* Menu:

* identity_quat::
* get_x_rotate_quat::
* get_rotation_quat::
* get_vector_rotation_quat::
* quat_to_matrix::
* matrix_to_quat::
* quat_mul::
* apply_quat::
* quat_interpolate::
* quat_slerp::


File: allegro.info,  Node: identity_quat,  Next: get_x_rotate_quat,  Prev: persp_project,  Up: Quaternion

1.35.1 identity_quat
--------------------

extern QUAT identity_quat;
     Global variable containing the 'do nothing' identity quaternion.
     Multiplying by the identity quaternion has no effect.

*Note QUAT::.


File: allegro.info,  Node: get_x_rotate_quat,  Next: get_rotation_quat,  Prev: identity_quat,  Up: Quaternion

1.35.2 get_x_rotate_quat
------------------------

void get_x_rotate_quat(QUAT *q, float r);
void get_y_rotate_quat(QUAT *q, float r);
void get_z_rotate_quat(QUAT *q, float r);
     Construct axis rotation quaternions, storing them in q.  When
     applied to a point, these quaternions will rotate it about the
     relevant axis by the specified angle (given in binary, 256 degrees
     to a circle format).

*Note QUAT::.


File: allegro.info,  Node: get_rotation_quat,  Next: get_vector_rotation_quat,  Prev: get_x_rotate_quat,  Up: Quaternion

1.35.3 get_rotation_quat
------------------------

void get_rotation_quat(QUAT *q, float x, float y, float z);
     Constructs a quaternion that will rotate points around all three
     axes by the specified amounts (given in binary, 256 degrees to a
     circle format).

See also:
*Note exquat::.
*Note QUAT::.


File: allegro.info,  Node: get_vector_rotation_quat,  Next: quat_to_matrix,  Prev: get_rotation_quat,  Up: Quaternion

1.35.4 get_vector_rotation_quat
-------------------------------

void get_vector_rotation_quat(QUAT *q, float x, y, z, float a);
     Constructs a quaternion that will rotate points around the
     specified x,y,z vector by the specified angle (given in binary, 256
     degrees to a circle format).

*Note QUAT::.


File: allegro.info,  Node: quat_to_matrix,  Next: matrix_to_quat,  Prev: get_vector_rotation_quat,  Up: Quaternion

1.35.5 quat_to_matrix
---------------------

void quat_to_matrix(const QUAT *q, MATRIX_f *m);
     Constructs a rotation matrix from a quaternion.

See also:
*Note exquat::.
*Note MATRIX_f::.
*Note QUAT::.


File: allegro.info,  Node: matrix_to_quat,  Next: quat_mul,  Prev: quat_to_matrix,  Up: Quaternion

1.35.6 matrix_to_quat
---------------------

void matrix_to_quat(const MATRIX_f *m, QUAT *q);
     Constructs a quaternion from a rotation matrix.  Translation is
     discarded during the conversion.  Use get_align_matrix_f() if the
     matrix is not orthonormalized, because strange things may happen
     otherwise.

*Note MATRIX_f::.
*Note QUAT::.


File: allegro.info,  Node: quat_mul,  Next: apply_quat,  Prev: matrix_to_quat,  Up: Quaternion

1.35.7 quat_mul
---------------

void quat_mul(const QUAT *p, const QUAT *q, QUAT *out);
     Multiplies two quaternions, storing the result in out.  The
     resulting quaternion will have the same effect as the combination
     of p and q, ie.  when applied to a point, (point * out) = ((point *
     p) * q).  Any number of rotations can be concatenated in this way.
     Note that quaternion multiplication is not commutative, ie.
     quat_mul(p, q) != quat_mul(q, p).

*Note QUAT::.


File: allegro.info,  Node: apply_quat,  Next: quat_interpolate,  Prev: quat_mul,  Up: Quaternion

1.35.8 apply_quat
-----------------

void apply_quat(const QUAT *q, float x, y, z, *xout, *yout, *zout);
     Multiplies the point (x, y, z) by the quaternion q, storing the
     result in (*xout, *yout, *zout).  This is quite a bit slower than
     apply_matrix_f(), so only use it to translate a few points.  If you
     have many points, it is much more efficient to call
     quat_to_matrix() and then use apply_matrix_f().

*Note QUAT::.


File: allegro.info,  Node: quat_interpolate,  Next: quat_slerp,  Prev: apply_quat,  Up: Quaternion

1.35.9 quat_interpolate
-----------------------

void quat_interpolate(const QUAT *from, const QUAT *to, float t, QUAT *out);
     Constructs a quaternion that represents a rotation between from and
     to.  The argument t can be anything between 0 and 1 and represents
     where between from and to the result will be.  0 returns from, 1
     returns to, and 0.5 will return a rotation exactly in between.  The
     result is copied to out.  This function will create the short
     rotation (less than 180 degrees) between from and to.

See also:
*Note exquat::.
*Note QUAT::.


File: allegro.info,  Node: quat_slerp,  Next: d_clear_proc,  Prev: quat_interpolate,  Up: Quaternion

1.35.10 quat_slerp
------------------

void quat_slerp(const QUAT *from, const QUAT *to, float t, QUAT *out, int how);
     The same as quat_interpolate(), but allows more control over how
     the rotation is done.  The how parameter can be any one of the
     values:

          QUAT_SHORT  - like quat_interpolate(), use shortest path
          QUAT_LONG   - rotation will be greater than 180 degrees
          QUAT_CW     - rotate clockwise when viewed from above
          QUAT_CCW    - rotate counterclockwise when viewed from above
          QUAT_USER   - the quaternions are interpolated exactly as
                        given

*Note QUAT::.


File: allegro.info,  Node: GUI,  Next: Platform,  Prev: Quaternion,  Up: API

1.36 GUI routines
=================

Allegro contains an object-oriented dialog manager, which was originally
based on the Atari GEM system (form_do(), objc_draw(), etc: old ST
programmers will know what we are talking about :-) You can use the GUI
as-is to knock out simple interfaces for things like the test program
and grabber utility, or you can use it as a basis for more complicated
systems of your own.  Allegro lets you define your own object types by
writing new dialog procedures, so you can take complete control over the
visual aspects of the interface while still using Allegro to handle
input from the mouse, keyboard, joystick, etc.

A GUI dialog is stored as an array of DIALOG objects, read chapter
"Structures and types defined by Allegro" for an internal description of
the DIALOG structure.  The array should end with an object which has the
proc pointer set to NULL. Each object has a flags field which may
contain any combination of the bit flags:

     D_EXIT          - this object should close the dialog when it is
                       clicked
     D_SELECTED      - this object is selected
     D_GOTFOCUS      - this object has got the input focus
     D_GOTMOUSE      - the mouse is currently on top of this object
     D_HIDDEN        - this object is hidden and inactive
     D_DISABLED      - this object is greyed-out and inactive
     D_DIRTY         - this object needs to be redrawn
     D_INTERNAL      - don't use this! It is for internal use by the
                       library...
     D_USER          - any powers of two above this are free for your
                       own use

Each object is controlled by a dialog procedure, which is stored in the
proc pointer.  This will be called by the dialog manager whenever any
action concerning the object is required, or you can call it directly
with the object_message() function.  The dialog procedure should follow
the form:

     int foo(int msg, DIALOG *d, int c);

It will be passed a flag (msg) indicating what action it should perform,
a pointer to the object concerned (d), and if msg is MSG_CHAR or
MSG_XCHAR, the key that was pressed (c).  Note that d is a pointer to a
specific object, and not to the entire dialog.

The dialog procedure should return one of the values:

     D_O_K          - normal return status
     D_CLOSE        - tells the dialog manager to close the dialog
     D_REDRAW       - tells the dialog manager to redraw the entire
                      dialog
     D_REDRAWME     - tells the dialog manager to redraw the current
                      object
     D_WANTFOCUS    - requests that the input focus be given to this
                      object
     D_USED_CHAR    - MSG_CHAR and MSG_XCHAR return this if they used
                      the key

Dialog procedures may be called with any of the messages:

MSG_START:
Tells the object to initialise itself.  The dialog manager sends this to
all the objects in a dialog just before it displays the dialog.

MSG_END:
Sent to all objects when closing a dialog, allowing them to perform
whatever cleanup operations they require.

MSG_DRAW:
Tells the object to draw itself onto the screen.  The mouse pointer will
be turned off when this message is sent, so the drawing code does not
need to worry about it.

MSG_CLICK:
Informs the object that a mouse button has been clicked while the mouse
was on top of the object.  Typically an object will perform its own
mouse tracking as long as the button is held down, and only return from
this message handler when it is released.

If you process this message, use the functions gui_mouse_*() to read the
state of the mouse.

MSG_DCLICK:
Sent when the user double-clicks on an object.  A MSG_CLICK will be sent
when the button is first pressed, then MSG_DCLICK if it is released and
pressed again within a short space of time.

If you process this message, use the functions gui_mouse_*() to read the
state of the mouse.

MSG_KEY:
Sent when the keyboard shortcut for the object is pressed, or if enter,
space, or a joystick button is pressed while it has the input focus.

MSG_CHAR:
When a key is pressed, this message is sent to the object that has the
input focus, with a readkey() format character code (ASCII value in the
low byte, scancode in the high byte) as the c parameter.  If the object
deals with the keypress it should return D_USED_CHAR, otherwise it
should return D_O_K to allow the default keyboard interface to operate.
If you need to access Unicode character input, you should use MSG_UCHAR
instead of MSG_CHAR.

MSG_UCHAR:
If an object ignores the MSG_CHAR input, this message will be sent
immediately after it, passed the full Unicode key value as the c
parameter.  This enables you to read character codes greater than 255,
but cannot tell you anything about the scancode: if you need to know
that, use MSG_CHAR instead.  This handler should return D_USED_CHAR if
it processed the input, or D_O_K otherwise.

MSG_XCHAR:
When a key is pressed, Allegro will send a MSG_CHAR and MSG_UCHAR to the
object with the input focus.  If this object doesn't process the key
(ie.  it returns D_O_K rather than D_USED_CHAR), the dialog manager will
look for an object with a matching keyboard shortcut in the key field,
and send it a MSG_KEY. If this fails, it broadcasts a MSG_XCHAR to all
objects in the dialog, allowing them to respond to special keypresses
even when they don't have the input focus.  Normally you should ignore
this message (return D_O_K rather than D_USED_CHAR), in which case
Allegro will perform default actions such as moving the focus in
response to the arrow keys and closing the dialog if ESC is pressed.

MSG_WANTFOCUS:
Queries whether an object is willing to accept the input focus.  It
should return D_WANTFOCUS if it does, or D_O_K if it isn't interested in
getting user input.

MSG_GOTFOCUS:
MSG_LOSTFOCUS:
Sent whenever an object gains or loses the input focus.  These messages
will always be followed by a MSG_DRAW, to let objects display themselves
differently when they have the input focus.  If you return D_WANTFOCUS
in response to a MSG_LOSTFOCUS event, this will prevent your object from
losing the focus when the mouse moves off it onto the screen background
or some inert object, so it will only lose the input focus when some
other object is ready to take over the focus (this trick is used by the
d_edit_proc() object).

MSG_GOTMOUSE:
MSG_LOSTMOUSE:
Sent when the mouse moves on top of or away from an object.  Unlike the
focus messages, these are not followed by a MSG_DRAW, so if the object
is displayed differently when the mouse is on top of it, it is
responsible for redrawing itself in response to these messages.

MSG_IDLE:
Sent whenever the dialog manager has nothing better to do.

MSG_RADIO:
Sent by radio button objects to deselect other buttons in the same group
when they are clicked.  The group number is passed in the c message
parameter.

MSG_WHEEL:
Sent to the focused object whenever the mouse wheel moves.  The c
message parameter contains the number of clicks.

MSG_LPRESS, MSG_MPRESS, MSG_RPRESS:
Sent when the corresponding mouse button is pressed.

MSG_LRELEASE, MSG_MRELEASE, MSG_RRELEASE:
Sent when the corresponding mouse button is released.

MSG_USER:
The first free message value.  Any numbers from here on (MSG_USER,
MSG_USER+1, MSG_USER+2, ...  MSG_USER+n) are free to use for whatever
you like.

Allegro provides several standard dialog procedures.  You can use these
as they are to provide simple user interface objects, or you can call
them from within your own dialog procedures, resulting in a kind of OOP
inheritance.  For instance, you could make an object which calls
d_button_proc to draw itself, but handles the click message in a
different way, or an object which calls d_button_proc for everything
except drawing itself, so it would behave like a normal button but could
look completely different.

Since the release of Allegro version 3.9.33 (CVS), some GUI objects and
menus are being drawn differently unlike in previous Allegro versions.
The changes are the following:

   * Shadows under d_shadow_box_proc and d_button_proc are always black.
   * The most important (and immediately visible) change is, that some
     objects are being drawn smaller.  The difference is exactly one
     pixel in both height and width, when comparing to previous
     versions.  The reason is, that in previous versions these objects
     were too large on the screen - their size was d->w+1 and d->h+1
     pixels (and not d->w and d->h, as it should be).  This change
     affects the following objects :

          d_box_proc,
          d_shadow_box_proc,
          d_button_proc,
          d_check_proc,
          d_radio_proc,
          d_list_proc,
          d_text_list_proc and
          d_textbox_proc.

     When you want to convert old dialogs to look equally when compiling
     with the new Allegro version, just increase the size of the
     mentioned objects by one pixel in both width and height fields.
   * When a GUI menu item (not in a bar menu) has a child menu, there is
     a small arrow next to the child menu name, pointing to the right -
     so the user can immediately see that this menu item has a child
     menu - and there is no need to use such menu item names as for
     example "New...", to show that it has a child menu.  The submenu
     will be drawn to the right of the parent menu, trying not to
     overlap it.


Menus had been forgotten during the changes for 3.9.33 (CVS), so they
were still drawn too large until version 4.1.0.

* Menu:

* d_clear_proc::
* d_box_proc::
* d_bitmap_proc::
* d_text_proc::
* d_button_proc::
* d_check_proc::
* d_radio_proc::
* d_icon_proc::
* d_keyboard_proc::
* d_edit_proc::
* d_list_proc::
* d_text_list_proc::
* d_textbox_proc::
* d_slider_proc::
* d_menu_proc::
* d_yield_proc::
* GUI variables::
* gui_mouse_focus::
* gui_fg_color::
* gui_mg_color::
* gui_font_baseline::
* gui_mouse_x::
* GUI font::
* gui_textout_ex::
* gui_strlen::
* gui_set_screen::
* gui_get_screen::
* position_dialog::
* centre_dialog::
* set_dialog_color::
* find_dialog_focus::
* offer_focus::
* object_message::
* dialog_message::
* broadcast_dialog_message::
* do_dialog::
* popup_dialog::
* init_dialog::
* update_dialog::
* shutdown_dialog::
* active_dialog::
* GUI menus::
* do_menu::
* init_menu::
* update_menu::
* shutdown_menu::
* active_menu::
* gui_menu_draw_menu::
* alert::
* alert3::
* file_select_ex::
* gfx_mode_select::
* gfx_mode_select_ex::
* gfx_mode_select_filter::
* gui_shadow_box_proc::


File: allegro.info,  Node: d_clear_proc,  Next: d_box_proc,  Prev: quat_slerp,  Up: GUI

1.36.1 d_clear_proc
-------------------

int d_clear_proc(int msg, DIALOG *d, int c);
     This just clears the screen when it is drawn.  Useful as the first
     object in a dialog.

See also:
*Note excustom::.
*Note exgui::.
*Note DIALOG::.


File: allegro.info,  Node: d_box_proc,  Next: d_bitmap_proc,  Prev: d_clear_proc,  Up: GUI

1.36.2 d_box_proc
-----------------

int d_box_proc(int msg, DIALOG *d, int c);
int d_shadow_box_proc(int msg, DIALOG *d, int c);
     These draw boxes onto the screen, with or without a shadow.

See also:
*Note exgui::.
*Note exrgbhsv::.
*Note DIALOG::.


File: allegro.info,  Node: d_bitmap_proc,  Next: d_text_proc,  Prev: d_box_proc,  Up: GUI

1.36.3 d_bitmap_proc
--------------------

int d_bitmap_proc(int msg, DIALOG *d, int c);
     This draws a bitmap onto the screen, which should be pointed to by
     the dp field.

See also:
*Note exgui::.
*Note exrgbhsv::.
*Note DIALOG::.


File: allegro.info,  Node: d_text_proc,  Next: d_button_proc,  Prev: d_bitmap_proc,  Up: GUI

1.36.4 d_text_proc
------------------

int d_text_proc(int msg, DIALOG *d, int c);
int d_ctext_proc(int msg, DIALOG *d, int c);
int d_rtext_proc(int msg, DIALOG *d, int c);
     These draw text onto the screen.  The dp field should point to the
     string to display.  d_ctext_proc() centers the string horizontally,
     and d_rtext_proc() right aligns it.  Any '&' characters in the
     string will be replaced with lines underneath the following
     character, for displaying keyboard shortcuts (as in MS Windows).
     To display a single ampersand, put "&&".  To draw the text in
     something other than the default font, set the dp2 field to point
     to your custom font data.

See also:
*Note exgui::.
*Note exrgbhsv::.
*Note DIALOG::.


File: allegro.info,  Node: d_button_proc,  Next: d_check_proc,  Prev: d_text_proc,  Up: GUI

1.36.5 d_button_proc
--------------------

int d_button_proc(int msg, DIALOG *d, int c);
     A button object (the dp field points to the text string).  This
     object can be selected by clicking on it with the mouse or by
     pressing its keyboard shortcut.  If the D_EXIT flag is set,
     selecting it will close the dialog, otherwise it will toggle on and
     off.  Like d_text_proc(), ampersands can be used to display the
     keyboard shortcut of the button.

See also:
*Note excustom::.
*Note exgui::.
*Note DIALOG::.


File: allegro.info,  Node: d_check_proc,  Next: d_radio_proc,  Prev: d_button_proc,  Up: GUI

1.36.6 d_check_proc
-------------------

int d_check_proc(int msg, DIALOG *d, int c);
     This is an example of how you can derive objects from other
     objects.  Most of the functionality comes from d_button_proc(), but
     it displays itself as a check box.  If the d1 field is non-zero,
     the text will be printed to the right of the check, otherwise it
     will be on the left.

     Note: the object width should allow space for the text as well as
     the check box (which is square, with sides equal to the object
     height).

See also:
*Note excustom::.
*Note exgui::.
*Note DIALOG::.


File: allegro.info,  Node: d_radio_proc,  Next: d_icon_proc,  Prev: d_check_proc,  Up: GUI

1.36.7 d_radio_proc
-------------------

int d_radio_proc(int msg, DIALOG *d, int c);
     A radio button object.  A dialog can contain any number of radio
     button groups: selecting a radio button causes other buttons within
     the same group to be deselected.  The dp field points to the text
     string, d1 specifies the group number, and d2 is the button style
     (0=circle, 1=square).

See also:
*Note exgui::.
*Note DIALOG::.


File: allegro.info,  Node: d_icon_proc,  Next: d_keyboard_proc,  Prev: d_radio_proc,  Up: GUI

1.36.8 d_icon_proc
------------------

int d_icon_proc(int msg, DIALOG *d, int c);
     A bitmap button.  The fg color is used for the dotted line showing
     focus, and the bg color for the shadow used to fill in the top and
     left sides of the button when "pressed".  d1 is the "push depth",
     ie.  the number of pixels the icon will be shifted to the right and
     down when selected (default 2) if there is no "selected" image.  d2
     is the distance by which the dotted line showing focus is indented
     (default 2).  dp points to a bitmap for the icon, while dp2 and dp3
     are the selected and disabled images respectively (optional, may be
     NULL).

See also:
*Note exgui::.
*Note DIALOG::.


File: allegro.info,  Node: d_keyboard_proc,  Next: d_edit_proc,  Prev: d_icon_proc,  Up: GUI

1.36.9 d_keyboard_proc
----------------------

int d_keyboard_proc(int msg, DIALOG *d, int c);
     This is an invisible object for implementing keyboard shortcuts.
     You can put an ASCII code in the key field of the dialog object (a
     character such as 'a' to respond to a simple keypress, or a number
     1-26 to respond to a control key a-z), or you can put a keyboard
     scancode in the d1 and/or d2 fields.  When one of these keys is
     pressed, the object will call the function pointed to by dp.  This
     should return an int, which will be passed back to the dialog
     manager, so it can return D_O_K, D_REDRAW, D_CLOSE, etc.

See also:
*Note exgui::.
*Note DIALOG::.


File: allegro.info,  Node: d_edit_proc,  Next: d_list_proc,  Prev: d_keyboard_proc,  Up: GUI

1.36.10 d_edit_proc
-------------------

int d_edit_proc(int msg, DIALOG *d, int c);
     An editable text object (the dp field points to the string).  When
     it has the input focus (obtained by clicking on it with the mouse),
     text can be typed into this object.  The d1 field specifies the
     maximum number of characters that it will accept, and d2 is the
     text cursor position within the string.

     Note: dp must point to a buffer at least (d1 + 1) * 4 bytes long
     because, depending on the encoding format in use, a single
     character can occupy up to 4 bytes and room must be reserved for
     the terminating null character.

See also:
*Note excustom::.
*Note exgui::.
*Note DIALOG::.


File: allegro.info,  Node: d_list_proc,  Next: d_text_list_proc,  Prev: d_edit_proc,  Up: GUI

1.36.11 d_list_proc
-------------------

int d_list_proc(int msg, DIALOG *d, int c);
     A list box object.  This will allow the user to scroll through a
     list of items and to select one by clicking or with the arrow keys.
     If the D_EXIT flag is set, double clicking on a list item will
     close the dialog.  The index of the selected item is held in the d1
     field, and d2 is used to store how far it has scrolled through the
     list.  The dp field points to a function which will be called to
     obtain information about the contents of the list.  This should
     follow the form:

          char *foobar(int index, int *list_size);

     If index is zero or positive, the function should return a pointer
     to the string which is to be displayed at position index in the
     list.  If index is negative, it should return NULL and list_size
     should be set to the number of items in the list.

     To create a multiple selection listbox, set the dp2 field to an
     array of byte flags indicating the selection state of each list
     item (non-zero for selected entries).  This table must be at least
     as big as the number of objects in the list!

See also:
*Note exgui::.
*Note DIALOG::.


File: allegro.info,  Node: d_text_list_proc,  Next: d_textbox_proc,  Prev: d_list_proc,  Up: GUI

1.36.12 d_text_list_proc
------------------------

int d_text_list_proc(int msg, DIALOG *d, int c);
     Like d_list_proc, but allows the user to type in the first few
     characters of a listbox entry in order to select it.  Uses dp3
     internally, so you mustn't store anything important there yourself.

See also:
*Note exgui::.
*Note DIALOG::.


File: allegro.info,  Node: d_textbox_proc,  Next: d_slider_proc,  Prev: d_text_list_proc,  Up: GUI

1.36.13 d_textbox_proc
----------------------

int d_textbox_proc(int msg, DIALOG *d, int c);
     A text box object.  The dp field points to the text which is to be
     displayed in the box.  If the text is long, there will be a
     vertical scrollbar on the right hand side of the object which can
     be used to scroll through the text.  The default is to print the
     text with word wrapping, but if the D_SELECTED flag is set, the
     text will be printed with character wrapping.  The d1 field is used
     internally to store the number of lines of text, and d2 is used to
     store how far it has scrolled through the text.

See also:
*Note exgui::.
*Note DIALOG::.


File: allegro.info,  Node: d_slider_proc,  Next: d_menu_proc,  Prev: d_textbox_proc,  Up: GUI

1.36.14 d_slider_proc
---------------------

int d_slider_proc(int msg, DIALOG *d, int c);
     A slider control object.  This object holds a value in d2, in the
     range from 0 to d1.  It will display as a vertical slider if h is
     greater than or equal to w, otherwise it will display as a
     horizontal slider.  The dp field can contain an optional bitmap to
     use for the slider handle, and dp2 can contain an optional callback
     function, which is called each time d2 changes.  The callback
     function should have the following prototype:

          int function(void *dp3, int d2);

     The d_slider_proc object will return the value of the callback
     function.

See also:
*Note exgui::.
*Note exrgbhsv::.
*Note DIALOG::.


File: allegro.info,  Node: d_menu_proc,  Next: d_yield_proc,  Prev: d_slider_proc,  Up: GUI

1.36.15 d_menu_proc
-------------------

int d_menu_proc(int msg, DIALOG *d, int c);
     This object is a menu bar which will drop down child menus when it
     is clicked or if an alt+key corresponding to one of the shortcuts
     in the menu is pressed.  It ignores a lot of the fields in the
     dialog structure, in particular the color is taken from the
     gui_*_color variables, and the width and height are calculated
     automatically (the w and h fields from the DIALOG are only used as
     a minimum size.)  The dp field points to an array of menu
     structures: see do_menu() for more information.  The top level menu
     will be displayed as a horizontal bar, but when child menus drop
     down from it they will be in the normal vertical format used by
     do_menu().  When a menu item is selected, the return value from the
     menu callback function is passed back to the dialog manager, so
     your callbacks should return D_O_K, D_REDRAW, or D_CLOSE.

See also:
*Note GUI menus::.
*Note active_menu::.
*Note gui_menu_draw_menu::.
*Note exgui::.
*Note DIALOG::.


File: allegro.info,  Node: d_yield_proc,  Next: GUI variables,  Prev: d_menu_proc,  Up: GUI

1.36.16 d_yield_proc
--------------------

int d_yield_proc(int msg, DIALOG *d, int c);
     An invisible helper object that yields time slices for the
     scheduler (if the system supports it) when the GUI has nothing to
     do but waiting for user actions.  You should put one instance of
     this object in each dialog array because it may be needed on
     systems with an unusual scheduling algorithm (for instance QNX) in
     order to make the GUI fully responsive.

See also:
*Note rest::.
*Note exgui::.
*Note DIALOG::.


File: allegro.info,  Node: GUI variables,  Next: gui_mouse_focus,  Prev: d_yield_proc,  Up: GUI

1.36.17 GUI variables
---------------------

The behaviour of the dialog manager can be controlled by the following
global variables.


File: allegro.info,  Node: gui_mouse_focus,  Next: gui_fg_color,  Prev: GUI variables,  Up: GUI

1.36.18 gui_mouse_focus
-----------------------

extern int gui_mouse_focus;
     If set, the input focus follows the mouse pointer around the
     dialog, otherwise a click is required to move it.


File: allegro.info,  Node: gui_fg_color,  Next: gui_mg_color,  Prev: gui_mouse_focus,  Up: GUI

1.36.19 gui_fg_color
--------------------

extern int gui_fg_color;
extern int gui_bg_color;
     The foreground and background colors for the standard dialogs
     (alerts, menus, and the file selector).  They default to 255 and 0.

See also:
*Note gui_mg_color::.
*Note set_dialog_color::.
*Note exgui::.


File: allegro.info,  Node: gui_mg_color,  Next: gui_font_baseline,  Prev: gui_fg_color,  Up: GUI

1.36.20 gui_mg_color
--------------------

extern int gui_mg_color;
     The color used for displaying greyed-out dialog objects (with the
     D_DISABLED flag set).  Defaults to 8.

See also:
*Note gui_fg_color::.
*Note set_dialog_color::.
*Note exgui::.


File: allegro.info,  Node: gui_font_baseline,  Next: gui_mouse_x,  Prev: gui_mg_color,  Up: GUI

1.36.21 gui_font_baseline
-------------------------

extern int gui_font_baseline;
     If set to a non-zero value, adjusts the keyboard shortcut
     underscores to account for the height of the descenders in your
     font.


File: allegro.info,  Node: gui_mouse_x,  Next: GUI font,  Prev: gui_font_baseline,  Up: GUI

1.36.22 gui_mouse_x
-------------------

extern int (*gui_mouse_x)();
extern int (*gui_mouse_y)();
extern int (*gui_mouse_z)();
extern int (*gui_mouse_b)();
     Hook functions, used by the GUI routines whenever they need to
     access the mouse state.  By default these just return copies of the
     mouse_x, mouse_y, mouse_z, and mouse_b variables, but they could be
     used to offset or scale the mouse position, or read input from a
     different source entirely.


File: allegro.info,  Node: GUI font,  Next: gui_textout_ex,  Prev: gui_mouse_x,  Up: GUI

1.36.23 GUI font
----------------

You can change the global 'font' pointer to make the GUI objects use
something other than the standard 8x8 font.  The standard dialog
procedures, menus, and alert boxes, will work with fonts of any size,
but the gfx_mode_select() dialog will look wrong with anything other
than 8x8 fonts.


File: allegro.info,  Node: gui_textout_ex,  Next: gui_strlen,  Prev: GUI font,  Up: GUI

1.36.24 gui_textout_ex
----------------------

int gui_textout_ex(BITMAP *bmp, const char *s, int x, y, color, bg, centre);
     Helper function for use by the GUI routines.  Draws a text string
     onto the screen, interpreting the '&' character as an underbar for
     displaying keyboard shortcuts.  Returns the width of the output
     string in pixels.

See also:
*Note gui_strlen::.
*Note BITMAP::.


File: allegro.info,  Node: gui_strlen,  Next: gui_set_screen,  Prev: gui_textout_ex,  Up: GUI

1.36.25 gui_strlen
------------------

int gui_strlen(const char *s);
     Helper function for use by the GUI routines.  Returns the length of
     a string in pixels, ignoring '&' characters.

See also:
*Note gui_textout_ex::.


File: allegro.info,  Node: gui_set_screen,  Next: gui_get_screen,  Prev: gui_strlen,  Up: GUI

1.36.26 gui_set_screen
----------------------

void gui_set_screen(BITMAP *bmp);
     This function can be used to change the bitmap surface the GUI
     routines draw to.  This can be useful if you are using a double
     buffering or page flipping system.  Passing NULL will cause the
     default surface (screen) to be used again.  Example:

          BITMAP *page[2];

          /* Allocate two pages of video memory */
          page[0] = create_video_bitmap(SCREEN_W, SCREEN_H);
          page[1] = create_video_bitmap(SCREEN_W, SCREEN_H);

          /* Page flip */
          show_video_bitmap(page[0]);
          gui_set_screen(page[0]);

See also:
*Note gui_get_screen::.
*Note BITMAP::.


File: allegro.info,  Node: gui_get_screen,  Next: position_dialog,  Prev: gui_set_screen,  Up: GUI

1.36.27 gui_get_screen
----------------------

BITMAP *gui_get_screen(void);
     This function returns the current bitmap surface the GUI routines
     will use for drawing.  Note that this function will return screen
     if you have called gui_set_screen(NULL) previously, and will never
     return NULL.

See also:
*Note gui_set_screen::.
*Note BITMAP::.


File: allegro.info,  Node: position_dialog,  Next: centre_dialog,  Prev: gui_get_screen,  Up: GUI

1.36.28 position_dialog
-----------------------

void position_dialog(DIALOG *dialog, int x, int y);
     Moves an array of dialog objects to the specified screen position
     (specified as the top left corner of the dialog).

See also:
*Note centre_dialog::.
*Note exgui::.
*Note DIALOG::.


File: allegro.info,  Node: centre_dialog,  Next: set_dialog_color,  Prev: position_dialog,  Up: GUI

1.36.29 centre_dialog
---------------------

void centre_dialog(DIALOG *dialog);
     Moves an array of dialog objects so that it is centered in the
     screen.

See also:
*Note position_dialog::.
*Note set_dialog_color::.
*Note DIALOG::.


File: allegro.info,  Node: set_dialog_color,  Next: find_dialog_focus,  Prev: centre_dialog,  Up: GUI

1.36.30 set_dialog_color
------------------------

void set_dialog_color(DIALOG *dialog, int fg, int bg);
     Sets the foreground and background colors of an array of dialog
     objects.

See also:
*Note gui_fg_color::.
*Note gui_mg_color::.
*Note centre_dialog::.
*Note exgui::.
*Note DIALOG::.


File: allegro.info,  Node: find_dialog_focus,  Next: offer_focus,  Prev: set_dialog_color,  Up: GUI

1.36.31 find_dialog_focus
-------------------------

int find_dialog_focus(DIALOG *dialog);
     Searches the dialog for the object which has the input focus,
     returning an index or -1 if the focus is not set.  This is useful
     if you are calling do_dialog() several times in a row and want to
     leave the focus in the same place it was when the dialog was last
     displayed, as you can call do_dialog(dlg, find_dialog_focus(dlg));

See also:
*Note do_dialog::.
*Note init_dialog::.
*Note offer_focus::.
*Note DIALOG::.


File: allegro.info,  Node: offer_focus,  Next: object_message,  Prev: find_dialog_focus,  Up: GUI

1.36.32 offer_focus
-------------------

int offer_focus(DIALOG *dialog, int obj, int *focus_obj, int force);
     Offers the input focus to a particular object.  Normally the
     function sends the MSG_WANTFOCUS message to query whether the
     object is willing to accept the focus.  However, passing any
     non-zero value as force argument instructs the function to
     authoritatively set the focus to the object.

See also:
*Note find_dialog_focus::.
*Note DIALOG::.


File: allegro.info,  Node: object_message,  Next: dialog_message,  Prev: offer_focus,  Up: GUI

1.36.33 object_message
----------------------

int object_message(DIALOG *dialog, int msg, int c);
     Sends a message to an object and returns the answer it has
     generated.  Remember that the first parameter is the dialog object
     (not a whole array) that you wish to send the message to.  For
     example, to make the second object in a dialog draw itself, you
     might write:

          object_message(&dialog[1], MSG_DRAW, 0);

     The function will take care of scaring and unscaring the mouse if
     the message is MSG_DRAW.

See also:
*Note dialog_message::.
*Note scare_mouse::.
*Note scare_mouse_area::.
*Note unscare_mouse::.
*Note excustom::.
*Note exrgbhsv::.
*Note DIALOG::.


File: allegro.info,  Node: dialog_message,  Next: broadcast_dialog_message,  Prev: object_message,  Up: GUI

1.36.34 dialog_message
----------------------

int dialog_message(DIALOG *dialog, int msg, int c, int *obj);
     Sends a message to all the objects in an array.  If any of the
     dialog procedures return values other than D_O_K, it returns the
     value and sets obj to the index of the object which produced it.

See also:
*Note object_message::.
*Note broadcast_dialog_message::.
*Note DIALOG::.


File: allegro.info,  Node: broadcast_dialog_message,  Next: do_dialog,  Prev: dialog_message,  Up: GUI

1.36.35 broadcast_dialog_message
--------------------------------

int broadcast_dialog_message(int msg, int c);
     Broadcasts a message to all the objects in the active dialog.  If
     any of the dialog procedures return values other than D_O_K, it
     returns that value.

See also:
*Note dialog_message::.
*Note active_dialog::.


File: allegro.info,  Node: do_dialog,  Next: popup_dialog,  Prev: broadcast_dialog_message,  Up: GUI

1.36.36 do_dialog
-----------------

int do_dialog(DIALOG *dialog, int focus_obj);
     The basic dialog manager function.  This displays a dialog (an
     array of dialog objects, terminated by one with a NULL dialog
     procedure), and sets the input focus to the focus_obj (-1 if you
     don't want anything to have the focus).  It interprets user input
     and dispatches messages as they are required, until one of the
     dialog procedures tells it to close the dialog, at which point it
     returns the index of the object that caused it to exit, or until
     ESC is pressed, at which point it returns -1.

See also:
*Note popup_dialog::.
*Note init_dialog::.
*Note centre_dialog::.
*Note set_dialog_color::.
*Note find_dialog_focus::.
*Note excustom::.
*Note exgui::.
*Note exrgbhsv::.
*Note DIALOG::.


File: allegro.info,  Node: popup_dialog,  Next: init_dialog,  Prev: do_dialog,  Up: GUI

1.36.37 popup_dialog
--------------------

int popup_dialog(DIALOG *dialog, int focus_obj);
     Like do_dialog(), but it stores the data on the screen before
     drawing the dialog and restores it when the dialog is closed.  The
     screen area to be stored is calculated from the dimensions of the
     first object in the dialog, so all the other objects should lie
     within this one.

See also:
*Note do_dialog::.
*Note DIALOG::.


File: allegro.info,  Node: init_dialog,  Next: update_dialog,  Prev: popup_dialog,  Up: GUI

1.36.38 init_dialog
-------------------

DIALOG_PLAYER *init_dialog(DIALOG *dialog, int focus_obj);
     This function provides lower level access to the same functionality
     as do_dialog(), but allows you to combine a dialog box with your
     own program control structures.  It initialises a dialog, returning
     a pointer to a player object that can be used with update_dialog()
     and shutdown_dialog().  With these functions, you could implement
     your own version of do_dialog() with the lines:

          DIALOG_PLAYER *player = init_dialog(dialog, focus_obj);

          while (update_dialog(player))
             ;

          return shutdown_dialog(player);

     Note that you are responsible for showing and hiding the mouse
     cursor, which do_dialog would otherwise do for you, or saving and
     restoring the screen contents, as popup_dialog would do for you.

See also:
*Note update_dialog::.
*Note shutdown_dialog::.
*Note do_dialog::.
*Note DIALOG::.
*Note DIALOG_PLAYER::.


File: allegro.info,  Node: update_dialog,  Next: shutdown_dialog,  Prev: init_dialog,  Up: GUI

1.36.39 update_dialog
---------------------

int update_dialog(DIALOG_PLAYER *player);
     Updates the status of a dialog object returned by init_dialog().
     Returns TRUE if the dialog is still active, or FALSE if it has
     terminated.  Upon a return value of FALSE, it is up to you whether
     to call shutdown_dialog() or to continue execution.  The object
     that requested the exit can be determined from the player->obj
     field.

See also:
*Note init_dialog::.
*Note DIALOG_PLAYER::.


File: allegro.info,  Node: shutdown_dialog,  Next: active_dialog,  Prev: update_dialog,  Up: GUI

1.36.40 shutdown_dialog
-----------------------

int shutdown_dialog(DIALOG_PLAYER *player);
     Destroys a dialog player object returned by init_dialog(),
     returning the object that caused it to exit (this is the same as
     the return value from do_dialog()).

See also:
*Note init_dialog::.
*Note DIALOG_PLAYER::.


File: allegro.info,  Node: active_dialog,  Next: GUI menus,  Prev: shutdown_dialog,  Up: GUI

1.36.41 active_dialog
---------------------

extern DIALOG *active_dialog;
     Global pointer to the most recent activated dialog.  This may be
     useful if an object needs to iterate through a list of all its
     siblings.

See also:
*Note do_dialog::.
*Note init_dialog::.
*Note broadcast_dialog_message::.
*Note DIALOG::.


File: allegro.info,  Node: GUI menus,  Next: do_menu,  Prev: active_dialog,  Up: GUI

1.36.42 GUI menus
-----------------

Popup or pulldown menus are created as an array of MENU structures.
Read chapter "Structures and types defined by Allegro" for an internal
description of the MENU structure.

Each menu item contains a text string.  This can use the '&' character
to indicate keyboard shortcuts, or can be an zero-length string to
display the item as a non-selectable splitter bar.  If the string
contains a "\t" tab character, any text after this will be
right-justified, eg.  for displaying keyboard shortcut information.  The
proc pointer is a function which will be called when the menu item is
selected, and child points to another menu, allowing you to create
nested menus.  Both proc and child may be NULL. The proc function
returns an integer which is ignored if the menu was brought up by
calling do_menu(), but which is passed back to the dialog manager if it
was created by a d_menu_proc() object.  The array of menu items is
terminated by an entry with a NULL text pointer.

Menu items can be disabled (greyed-out) by setting the D_DISABLED bit in
the flags field, and a check mark can be displayed next to them by
setting the D_SELECTED bit.  With the default alignment and font this
will usually overlap the menu text, so if you are going to use checked
menu items it would be a good idea to prefix all your options with a
space or two, to ensure there is room for the check.

See also:
*Note do_menu::.
*Note d_menu_proc::.
*Note gui_menu_draw_menu::.


File: allegro.info,  Node: do_menu,  Next: init_menu,  Prev: GUI menus,  Up: GUI

1.36.43 do_menu
---------------

int do_menu(MENU *menu, int x, int y);
     Displays and animates a popup menu at the specified screen
     coordinates (these will be adjusted if the menu does not entirely
     fit on the screen).  Returns the index of the menu item that was
     selected, or -1 if the menu was cancelled.  Note that the return
     value cannot indicate selection from child menus, so you will have
     to use the callback functions if you want multi-level menus.

See also:
*Note GUI menus::.
*Note d_menu_proc::.
*Note active_menu::.
*Note gui_menu_draw_menu::.
*Note update_menu::.
*Note MENU::.


File: allegro.info,  Node: init_menu,  Next: update_menu,  Prev: do_menu,  Up: GUI

1.36.44 init_menu
-----------------

MENU_PLAYER *init_menu(MENU *menu, int x, int y);
     This function provides lower level access to the same functionality
     as do_menu(), but allows you to combine a popup menu with your own
     program control structures.  It initialises a menu, returning a
     pointer to a menu player object that can be used with update_menu()
     and shutdown_menu().  With these functions, you could implement
     your own version of do_menu() with the lines:

          MENU_PLAYER *player = init_menu(menu, x, y);

          while (update_menu(player))
             ;

          return shutdown_menu(player);

See also:
*Note update_menu::.
*Note shutdown_menu::.
*Note do_menu::.
*Note MENU::.
*Note MENU_PLAYER::.


File: allegro.info,  Node: update_menu,  Next: shutdown_menu,  Prev: init_menu,  Up: GUI

1.36.45 update_menu
-------------------

int update_menu(MENU_PLAYER *player);
     Updates the status of a menu object returned by init_menu().
     Returns TRUE if the menu is still active, or FALSE if it has
     terminated.  Upon a return value of FALSE, it is up to you to call
     shutdown_menu() or to continue execution.

See also:
*Note init_menu::.
*Note shutdown_menu::.
*Note do_menu::.
*Note MENU_PLAYER::.


File: allegro.info,  Node: shutdown_menu,  Next: active_menu,  Prev: update_menu,  Up: GUI

1.36.46 shutdown_menu
---------------------

int shutdown_menu(MENU_PLAYER *player);
     Destroys a menu player object returned by init_menu(), returning
     the index of the menu item that was selected, or -1 if the menu was
     cancelled (this is the same as the return value from do_menu()).

See also:
*Note init_menu::.
*Note update_menu::.
*Note MENU_PLAYER::.


File: allegro.info,  Node: active_menu,  Next: gui_menu_draw_menu,  Prev: shutdown_menu,  Up: GUI

1.36.47 active_menu
-------------------

extern MENU *active_menu;
     When a menu callback procedure is triggered, this will be set to
     the menu item that was selected, so your routine can determine
     where it was called from.

See also:
*Note GUI menus::.
*Note exgui::.
*Note MENU::.


File: allegro.info,  Node: gui_menu_draw_menu,  Next: alert,  Prev: active_menu,  Up: GUI

1.36.48 gui_menu_draw_menu
--------------------------

extern void (*gui_menu_draw_menu)(int x, int y, int w, int h);
extern void (*gui_menu_draw_menu_item)(MENU *m, int x, int y, int w, int h, int bar, int sel);
     If set, these functions will be called whenever a menu needs to be
     drawn, so you can change how menus look.

     gui_menu_draw_menu() is passed the position and size of the menu.
     It should draw the background of the menu onto screen.

     gui_menu_draw_menu_item() is called once for each menu item that is
     to be drawn.  bar will be set if the item is part of a top-level
     horizontal menu bar, and sel will be set if the menu item is
     selected.  It should also draw onto screen.

See also:
*Note GUI menus::.
*Note MENU::.


File: allegro.info,  Node: alert,  Next: alert3,  Prev: gui_menu_draw_menu,  Up: GUI

1.36.49 alert
-------------

int alert(const char *s1, *s2, *s3, const char *b1, *b2, int c1, c2);
     Displays a popup alert box, containing three lines of text (s1-s3),
     and with either one or two buttons.  The text for these buttons is
     passed in 'b1' and 'b2' ('b2' may be NULL), and the keyboard
     shortcuts in 'c1' and 'c2' as ASCII value.  Example:

          if (!exists(CONFIG_FILE))
             alert(CONFIG_FILE, "not found.", "Using defaults.",
                   "&Continue", NULL, 'c', 0);

     Returns 1 or 2 depending on which button was clicked.  If the alert
     is dismissed by pressing ESC when ESC is not one of the keyboard
     shortcuts, it treats it as a click on the second button (this is
     consistent with the common "Ok", "Cancel" alert).

See also:
*Note alert3::.
*Note gui_fg_color::.
*Note exgui::.
*Note expackf::.
*Note exspline::.


File: allegro.info,  Node: alert3,  Next: file_select_ex,  Prev: alert,  Up: GUI

1.36.50 alert3
--------------

int alert3(const char *s1, *s2, *s3, const char *b1, *b2, *b3, int c1, c2, c3);
     Like alert(), but with three buttons.  Returns 1, 2, or 3.

See also:
*Note alert::.
*Note gui_fg_color::.


File: allegro.info,  Node: file_select_ex,  Next: gfx_mode_select,  Prev: alert3,  Up: GUI

1.36.51 file_select_ex
----------------------

int file_select_ex(const char *message, char *path, const char *ext, int size, int w, int h);
     Displays the Allegro file selector, with the message as caption.
     The path parameter contains the initial filename to display (this
     can be used to set the starting directory, or to provide a default
     filename for a save-as operation).  The user selection is returned
     by altering the path buffer, whose maximum capacity in bytes is
     specified by the size parameter.  Note that it should have room for
     at least 80 characters (not bytes), so you should reserve 6x that
     amount, just to be sure.  The list of files is filtered according
     to the file extensions in the ext parameter.  Passing NULL includes
     all files; "PCX;BMP" includes only files with .PCX or .BMP
     extensions.  If you wish to control files by their attributes, one
     of the fields in the extension list can begin with a slash,
     followed by a set of attribute characters.  Any attribute written
     on its own, or with a '+' before it, indicates to include only
     files which have that attribute set.  Any attribute with a '-'
     before it indicates to leave out any files with that attribute.
     The flag characters are 'r' (read-only), 'h' (hidden), 's'
     (system), 'd' (directory) and 'a' (archive).  For example, an
     extension string of "PCX;BMP;/+r-h" will display only PCX or BMP
     files that are read-only and not hidden.  The directories are not
     affected in the same way as the other files by the extension
     string: the extensions are never taken into account for them and
     the other attributes are taken into account only when 'd' is
     mentioned in the string; in other words, all directories are
     included when 'd' is not mentioned in the string.  The file
     selector is stretched to the width and height specified in the w
     and h parameters, and to the size of the standard Allegro font.  If
     either the width or height argument is set to zero, it is stretched
     to the corresponding screen dimension.  This function returns zero
     if it was closed with the Cancel button or non-zero if it was OK'd.

See also:
*Note gui_fg_color::.


File: allegro.info,  Node: gfx_mode_select,  Next: gfx_mode_select_ex,  Prev: file_select_ex,  Up: GUI

1.36.52 gfx_mode_select
-----------------------

int gfx_mode_select(int *card, int *w, int *h);
     Displays the Allegro graphics mode selection dialog, which allows
     the user to select a screen mode and graphics card.

     The initial values at the addresses provided by card, w, and h are
     used as the default selections in the dialog if they are found in
     the driver and mode lists.  If they are not found then the initial
     selections will be the first in each list.  If you wish to ensure
     that the initial selection is always the first entry, then
     initialize the data at the addresses passed to the function to the
     value of 0 or -1.

     If the dialog is OK'd, it stores the selections at the addresses
     passed to the function.

     See the gfx_mode_select_filter function for the return values.

See also:
*Note gfx_mode_select_ex::.
*Note gfx_mode_select_filter::.
*Note set_gfx_mode::.
*Note gui_fg_color::.


File: allegro.info,  Node: gfx_mode_select_ex,  Next: gfx_mode_select_filter,  Prev: gfx_mode_select,  Up: GUI

1.36.53 gfx_mode_select_ex
--------------------------

int gfx_mode_select_ex(int *card, int *w, int *h, int *color_depth);
     Extended version of the graphics mode selection dialog, which also
     allows the user to select the color depth.

     As with gfx_mode_select, the values stored at the addresses passed
     to the function will be used as suggestions for the initial
     selections in the dialog, defaulting to the first entry in each
     list if the values are not found.  Initialize the data stored at
     the addresses passed to the function to the value of 0 or -1 if you
     want to ensure that the initial selection for each list will be the
     first entry.

     If the dialog is OK'd, it stores the selections at the addresses
     passed to the function.

     See the gfx_mode_select_filter function for the return values.

See also:
*Note gfx_mode_select::.
*Note gfx_mode_select_filter::.
*Note set_color_depth::.
*Note set_gfx_mode::.
*Note gui_fg_color::.
*Note ex3d::.
*Note exscn3d::.
*Note exswitch::.
*Note exupdate::.
*Note exzbuf::.


File: allegro.info,  Node: gfx_mode_select_filter,  Next: gui_shadow_box_proc,  Prev: gfx_mode_select_ex,  Up: GUI

1.36.54 gfx_mode_select_filter
------------------------------

int gfx_mode_select_filter(int *card, int *w, int *h, int *color_depth, int (*filter)(int, int, int, int));
     Even more extended version of the graphics mode selection dialog,
     which allows the programmer to customize the contents of the dialog
     and the user to select the color depth as well as the resolution
     and hardware driver.  'filter' will be passed (card, w, h,
     color_depth) quadruplets and must return 0 to let the specified
     quadruplet be added to the list of displayed modes.

     As with gfx_mode_select, the values stored at the addresses passed
     to the function will be used as suggestions for the initial
     selections in the dialog, defaulting to the first entry in each
     list if the values are not found.  Initialize the data stored at
     the addresses passed to the function to the value of 0 or -1 if you
     want to ensure that the initial selection for each list will be the
     first entry.

     If the dialog is OK'd, it stores the selections at the addresses
     passed to the function.

     Example usage :

          ret = gfx_mode_select_filter(&card, &w, &h, &color_depth, user_filter);
          if (ret) {/* User okayed dialog or user_filter removed all modes */
             if (card == GFX_NONE) {
                // No modes available
                *card = 0;/* Make sure not to leave *card == GFX_NONE */
                return -1;
             }
             /* Handle changing to new mode here... */

          } else {/* User cancelled dialog or there was an error (unlikely) */
             if (card == GFX_NONE) {
                /* Error, probably out of memory */
                *card = 0;/* Make sure not to leave *card == GFX_NONE */
                return -2;
             }
             /* Carry on in current graphics mode if that is acceptable */
          }

     Returns zero if the user cancelled the dialog or an error occurred.
     In the case of an error then *card is assigned the value GFX_NONE.
     The functions return non-zero if the user made a selection OR if
     all the modes were filtered out.  In the case that all of the modes
     were filtered out, then *card is assigned the value GFX_NONE. This
     means you should NOT initialize the *card to the value of GFX_NONE,
     as it could interfere with determining the proper return value.

See also:
*Note gfx_mode_select::.
*Note gfx_mode_select_ex::.
*Note set_color_depth::.
*Note set_gfx_mode::.
*Note gui_fg_color::.


File: allegro.info,  Node: gui_shadow_box_proc,  Next: JOY_TYPE_*/DOS,  Prev: gfx_mode_select_filter,  Up: GUI

1.36.55 gui_shadow_box_proc
---------------------------

extern int (*gui_shadow_box_proc)(int msg, struct DIALOG *d, int c);
extern int (*gui_ctext_proc)(int msg, struct DIALOG *d, int c);
extern int (*gui_button_proc)(int msg, struct DIALOG *d, int c);
extern int (*gui_edit_proc)(int msg, struct DIALOG *d, int c);
extern int (*gui_list_proc)(int msg, struct DIALOG *d, int c);
extern int (*gui_text_list_proc)(int msg, struct DIALOG *d, int c);
     If set, these functions will be used by the standard Allegro
     dialogs.  This allows you to customise the look and feel, much like
     gui_fg_color and gui_bg_color, but much more flexibly.

See also:
*Note alert::.
*Note alert3::.
*Note file_select_ex::.
*Note gfx_mode_select::.
*Note gui_fg_color::.
*Note DIALOG::.


File: allegro.info,  Node: Platform,  Next: DOS,  Prev: GUI,  Up: Top

2 Platform specifics
********************

* Menu:

* DOS::                     DOS specifics
* Windows::                 Windows specifics
* Unix::                    Unix specifics
* BeOS::                    BeOS specifics
* QNX::                     QNX specifics
* MacOS::                   MacOS X specifics
* Differences::             Differences between platforms


File: allegro.info,  Node: DOS,  Next: Windows,  Prev: Platform,  Up: Platform

2.1 DOS specifics
=================

There are four Allegro files which you should redistribute along your
program.  These are the files 'keyboard.dat', 'language.dat',
'allegro.cfg' and 'setup.exe'.

The first two contain internationalisation information for keyboard
mappings and system messages to show up localised on the user's
computer.  The 'setup.exe' program, which comes in Allegro's 'setup'
directory, is a standalone tool which you can graphically customise and
even embed into your main binary.  The user can generate a configuration
file with this tool, to store special settings or avoid Allegro's
autodetection failing on specific hardware.  Even if you distribute
'setup.exe', you are recommended to copy too the empty 'allegro.cfg'
file, in case the setup program itself is unable to run and the user has
to edit manually the configuration with a text editor.

If you are using get_config_text() in your program to localise text
strings, merge your xxtext.cfg files with the ones provided by Allegro
in the 'resource' directory before creating 'language.dat', and
redistribute this with your program.  This file will contain then both
Allegro's system messages and the strings of your program.

* Menu:

* JOY_TYPE_*/DOS::
* GFX_*/DOS::
* DIGI_*/DOS::
* MIDI_*/DOS::
* DOS integration routines::
* i_love_bill::


File: allegro.info,  Node: JOY_TYPE_*/DOS,  Next: GFX_*/DOS,  Prev: gui_shadow_box_proc,  Up: DOS

2.1.1 JOY_TYPE_*/DOS
--------------------

Drivers JOY_TYPE_*/DOS
     The DOS library supports the following type parameters for the
     install_joystick() function:

        * JOY_TYPE_AUTODETECT
          Attempts to autodetect your joystick hardware.  It isn't
          possible to reliably distinguish between all the possible
          input setups, so this routine can only ever choose the
          standard joystick, Sidewider, GamePad Pro, or GrIP drivers,
          but it will use information from the configuration file if one
          is available (this can be created using the setup utility or
          by calling the save_joystick_data() function), so you can
          always use JOY_TYPE_AUTODETECT in your code and then select
          the exact hardware type from the setup program.
        * JOY_TYPE_NONE
          Dummy driver for machines without any joystick.
        * JOY_TYPE_STANDARD
          A normal two button stick.
        * JOY_TYPE_2PADS
          Dual joystick mode (two sticks, each with two buttons).
        * JOY_TYPE_4BUTTON
          Enable the extra buttons on a 4-button joystick.
        * JOY_TYPE_6BUTTON
          Enable the extra buttons on a 6-button joystick.
        * JOY_TYPE_8BUTTON
          Enable the extra buttons on an 8-button joystick.
        * JOY_TYPE_FSPRO
          CH Flightstick Pro or compatible stick, which provides four
          buttons, an analogue throttle control, and a 4-direction
          coolie hat.
        * JOY_TYPE_WINGEX
          A Logitech Wingman Extreme, which should also work with any
          Thrustmaster Mk.I compatible joystick.  It provides support
          for four buttons and a coolie hat.  This also works with the
          Wingman Warrior, if you plug in the 15 pin plug (remember to
          unplug the 9-pin plug!)  and set the tiny switch in front to
          the "H" position (you will not be able to use the throttle or
          the spinner though).
        * JOY_TYPE_SIDEWINDER
          The Microsoft Sidewinder digital pad (supports up to four
          controllers, each with ten buttons and a digital direction
          control).
        * JOY_TYPE_SIDEWINDER_AG
          An alternative driver to JOY_TYPE_SIDEWINDER. Try this if your
          Sidewinder isn't recognized with JOY_TYPE_SIDEWINDER.
        * JOY_TYPE_SIDEWINDER_PP
          The Microsoft Sidewinder 3D/Precision/Force Feedback Pro
          joysticks.
        * JOY_TYPE_GAMEPAD_PRO
          The Gravis GamePad Pro (supports up to two controllers, each
          with ten buttons and a digital direction control).
        * JOY_TYPE_GRIP
          Gravis GrIP driver, using the grip.gll driver file.
        * JOY_TYPE_GRIP4
          Version of the Gravis GrIP driver that is constrained to only
          move along the four main axes.
        * JOY_TYPE_SNESPAD_LPT1
          JOY_TYPE_SNESPAD_LPT2
          JOY_TYPE_SNESPAD_LPT3
          SNES joypads connected to LPT1, LPT2, and LPT3 respectively.
        * JOY_TYPE_PSXPAD_LPT1
          JOY_TYPE_PSXPAD_LPT2
          JOY_TYPE_PSXPAD_LPT3
          PSX joypads connected to LPT1, LPT2, and LPT3 respectively.
          See http://www.ziplabel.com/dpadpro/index.html for information
          about the parallel cable required.  The driver automagically
          detects which types of PSX pads are connected out of digital,
          analog (red or green mode), NegCon, multi taps, Namco light
          guns, Jogcons (force feedback steering wheel) and the mouse.
          If the controller isn't recognised it is treated as an analog
          controller, meaning the driver should work with just about
          anything.  You can connect controllers in any way you see fit,
          but only the first 8 will be used.

          The Sony Dual Shock or Namco Jogcon will reset themselves (to
          digital mode) after not being polled for 5 seconds.  This is
          normal, the same thing happens on a Playstation, it's designed
          to stop any vibration in case the host machine crashes.  Other
          mode switching controllers may have similar quirks.  However,
          if this happens to a Jogcon controller the mode button is
          disabled.  To reenable the mode button on the Jogcon you need
          to hold down the Start and Select buttons at the same time.

          The G-con45 needs to be connected to (and pointed at) a TV
          type monitor connected to your computer.  The composite video
          out on my video card works fine for this (a Hercules Stingray
          128/3D 8Mb).  The TV video modes in Mame should work too.
        * JOY_TYPE_N64PAD_LPT1
          JOY_TYPE_N64PAD_LPT2
          JOY_TYPE_N64PAD_LPT3
          N64 joypads connected to LPT1, LPT2, and LPT3 respectively.
          See http://www.st-hans.de/N64.htm for information about the
          necessary hardware adapter.  It supports up to four
          controllers on a single parallel port.  There is no need to
          calibrate the analog stick, as this is done by the controller
          itself when powered up.  This means that the stick has to be
          centred when the controller is initialised.  One possible
          issue people may have with this driver is that it is
          physically impossible to move the analog stick fully diagonal,
          but I can't see this causing any major problems.  This is
          because of the shape of the rim that the analog stick rests
          against.  Like the Gravis Game Pad Pro, this driver briefly
          needs to disable hardware interrupts while polling.  This
          causes a noticeable performance hit on my machine in both
          drivers, but there is no way around it.  At a (very) rough
          guess I'd say it slows down Mame 5% - 10%.
        * JOY_TYPE_DB9_LPT1
          JOY_TYPE_DB9_LPT2
          JOY_TYPE_DB9_LPT3
          A pair of two-button joysticks connected to LPT1, LPT2, and
          LPT3 respectively.  Port 1 is compatible with Linux joy-db9
          driver (multisystem 2-button), and port 2 is compatible with
          Atari interface for DirectPad Pro.  See the source file
          (src/dos/multijoy.c) for pinout information.
        * JOY_TYPE_TURBOGRAFIX_LPT1
          JOY_TYPE_TURBOGRAFIX_LPT2
          JOY_TYPE_TURBOGRAFIX_LPT3
          These drivers support up to 7 joysticks, each one with up to 5
          buttons, connected to LPT1, LPT2, and LPT3 respectively.  They
          use the TurboGraFX interface by Steffen Schwenke: see
          http://www.burg-halle.de/~schwenke/parport.html for details on
          how to build this.
        * JOY_TYPE_WINGWARRIOR
          A Wingman Warrior joystick.
        * JOY_TYPE_IFSEGA_ISA
          JOY_TYPE_IFSEGA_PCI
          JOY_TYPE_IFSEGA_PCI_FAST
          Drivers for the IF-SEGA joystick interface cards by the
          IO-DATA company (these come in PCI, PCI2, and ISA variants).

See also:
*Note install_joystick::.


File: allegro.info,  Node: GFX_*/DOS,  Next: DIGI_*/DOS,  Prev: JOY_TYPE_*/DOS,  Up: DOS

2.1.2 GFX_*/DOS
---------------

Drivers GFX_*/DOS
     The DOS library supports the following card parameters for the
     set_gfx_mode() function:

        * GFX_TEXT
          Return to text mode.
        * GFX_AUTODETECT
          Let Allegro pick an appropriate graphics driver.
        * GFX_AUTODETECT_FULLSCREEN
          Autodetects a graphics driver, but will only use fullscreen
          drivers, failing if these are not available on current
          platform.
        * GFX_AUTODETECT_WINDOWED
          Same as above, but uses only windowed drivers.  This will
          always fail under DOS.
        * GFX_SAFE
          Special driver for when you want to reliably set a graphics
          mode and don't really care what resolution or color depth you
          get.  See the set_gfx_mode() documentation for details.
        * GFX_VGA
          The standard 256-color VGA mode 13h, using the GFX_VGA driver.
          This is normally sized 320x200, which will work on any VGA but
          doesn't support large virtual screens and hardware scrolling.
          Allegro also provides some tweaked variants of the mode which
          are able to scroll, sized 320x100 (with a 200 pixel high
          virtual screen), 160x120 (with a 409 pixel high virtual
          screen), 256x256 (no scrolling), and 80x80 (with a 819 pixel
          high virtual screen).
        * GFX_MODEX
          Mode-X will work on any VGA card, and provides a range of
          different 256-color tweaked resolutions.

             * Stable mode-X resolutions:

                  * Square aspect ratio: 320x240
                  * Skewed aspect ratio: 256x224, 256x240, 320x200,
                    320x400, 320x480, 320x600, 360x200, 360x240,
                    360x360, 360x400, 360x480

               These have worked on every card/monitor that I've tested.
             * Unstable mode-X resolutions:

                  * Square aspect ratio: 360x270, 376x282, 400x300
                  * Skewed aspect ratio: 256x200, 256x256, 320x350,
                    360x600, 376x308, 376x564, 400x150, 400x600

               These only work on some monitors.  They were fine on my
               old machine, but don't get on very well with my new
               monitor.  If you are worried about the possibility of
               damaging your monitor by using these modes, don't be.  Of
               course I'm not providing any warranty with any of this,
               and if your hardware does blow up that is tough, but I
               don't think this sort of tweaking can do any damage.
               From the documentation of Robert Schmidt's TWEAK program:

               "Some time ago, putting illegal or unsupported values or
               combinations of such into the video card registers might
               prove hazardous to both your monitor and your health.  I
               have *never* claimed that bad things can't happen if you
               use TWEAK, although I'm pretty sure it never will.  I've
               never heard of any damage arising from trying out TWEAK,
               or from general VGA tweaking in any case."

          Most of the mode-X drawing functions are slower than in mode
          13h, due to the complexity of the planar bitmap organisation,
          but solid area fills and plane-aligned blits from one part of
          video memory to another can be significantly faster,
          particularly on older hardware.  Mode-X can address the full
          256k of VGA RAM, so hardware scrolling and page flipping are
          possible, and it is possible to split the screen in order to
          scroll the top part of the display but have a static status
          indicator at the bottom.
        * GFX_VESA1
          Use the VESA 1.x driver.
        * GFX_VESA2B
          Use the VBE 2.0 banked mode driver.
        * GFX_VESA2L
          Use the VBE 2.0 linear framebuffer driver.
        * GFX_VESA3
          Use the VBE 3.0 driver.  This is the only VESA driver that
          supports the request_refresh_rate() function.

          The standard VESA modes are 640x480, 800x600, and 1024x768.
          These ought to work with any SVGA card: if they don't, get a
          copy of the SciTech Display Doctor and see if that fixes it.
          What color depths are available will depend on your hardware.
          Most cards support both 15 and 16-bit resolutions, but if at
          all possible I would advise you to support both (it's not
          hard...)  in case one is not available.  Some cards provide
          both 24 and 32-bit truecolor, in which case it is a choice
          between 24 (saves memory) or 32 (faster), but many older cards
          have no 32-bit mode and some newer ones don't support 24-bit
          resolutions.  Use the vesainfo test program to see what modes
          your VESA driver provides.

          Many cards also support 640x400, 1280x1024, and 1600x1200, but
          these aren't available on everything, for example the S3
          chipset has no 640x400 mode.  Other weird resolution may be
          possible, eg.  some Tseng boards can do 640x350, and the
          Avance Logic has a 512x512 mode.

          The SciTech Display Doctor provides several scrollable low
          resolution modes in a range of different color depths
          (320x200, 320x240, 320x400, 320x480, 360x200, 360x240,
          360x400, and 360x480 all work on my ET4000 with 8, 15, or 16
          bits per pixel).  These are lovely, allowing scrolling and
          page flipping without the complexity of the mode-X planar
          setup, but unfortunately they aren't standard so you will need
          Display Doctor in order to use them.
        * GFX_VBEAF
          VBE/AF is a superset of the VBE 2.0 standard, which provides
          an API for accessing hardware accelerator features.  VBE/AF
          drivers are currently only available from the FreeBE/AF
          project or as part of the SciTech Display Doctor package, but
          they can give dramatic speed improvements when used with
          suitable hardware.  For a detailed discussion of hardware
          acceleration issues, refer to the documentation for the
          gfx_capabilities flag.

          You can use the afinfo test program to check whether you have
          a VBE/AF driver, and to see what resolutions it supports.

          The SciTech VBE/AF drivers require nearptr access to be
          enabled, so any stray pointers are likely to crash your
          machine while their drivers are in use.  This means it may be
          a good idea to use VESA while debugging your program, and only
          switch to VBE/AF once the code is working correctly.  The
          FreeBE/AF drivers do not have this problem.
        * GFX_XTENDED
          An unchained 640x400 mode, as described by Mark Feldman in the
          PCGPE. This uses VESA to select an SVGA mode (so it will only
          work on cards supporting the VESA 640x400 resolution), and
          then unchains the VGA hardware as for mode-X. This allows the
          entire screen to be addressed without the need for bank
          switching, but hardware scrolling and page flipping are not
          possible.  This driver will never be autodetected (the normal
          VESA 640x400 mode will be chosen instead), so if you want to
          use it you will have to explicitly pass GFX_XTENDED to
          set_gfx_mode().

     There are a few things you need to be aware of for scrolling: most
     VESA implementations can only handle horizontal scrolling in four
     pixel increments, so smooth horizontal panning is impossible in
     SVGA modes.  A significant number of VESA implementations seem to
     be very buggy when it comes to scrolling in truecolor video modes,
     so you shouldn't depend on this routine working correctly in the
     truecolor resolutions unless you can be sure that SciTech Display
     Doctor is installed.  Hardware scrolling may also not work at all
     under Windows.

     Triple buffering is only possible with certain drivers: it will
     work in any DOS mode-X resolution if the timer retrace simulator is
     active (but this doesn't work correctly under Windows 95), plus it
     is supported by the VBE 3.0 and VBE/AF drivers for a limited number
     graphics cards.
See also:
*Note set_gfx_mode::.


File: allegro.info,  Node: DIGI_*/DOS,  Next: MIDI_*/DOS,  Prev: GFX_*/DOS,  Up: DOS

2.1.3 DIGI_*/DOS
----------------

Drivers DIGI_*/DOS
     The DOS sound functions support the following digital sound cards:

          DIGI_AUTODETECT      - let Allegro pick a digital sound driver
          DIGI_NONE            - no digital sound
          DIGI_SB              - Sound Blaster (autodetect type)
          DIGI_SB10            - SB 1.0 (8-bit mono single shot DMA)
          DIGI_SB15            - SB 1.5 (8-bit mono single shot DMA)
          DIGI_SB20            - SB 2.0 (8-bit mono auto-initialised
                                 DMA)
          DIGI_SBPRO           - SB Pro (8-bit stereo)
          DIGI_SB16            - SB16 (16-bit stereo)
          DIGI_AUDIODRIVE      - ESS AudioDrive
          DIGI_SOUNDSCAPE      - Ensoniq Soundscape
          DIGI_WINSOUNDSYS     - Windows Sound System

See also:
*Note detect_digi_driver::.
*Note install_sound::.
*Note install_sound_input::.


File: allegro.info,  Node: MIDI_*/DOS,  Next: DOS integration routines,  Prev: DIGI_*/DOS,  Up: DOS

2.1.4 MIDI_*/DOS
----------------

Drivers MIDI_*/DOS
     The DOS sound functions support the following MIDI sound cards:

          MIDI_AUTODETECT      - let Allegro pick a MIDI sound driver
          MIDI_NONE            - no MIDI sound
          MIDI_ADLIB           - Adlib or SB FM synth (autodetect type)
          MIDI_OPL2            - OPL2 synth (mono, used in Adlib and SB)
          MIDI_2XOPL2          - dual OPL2 synths (stereo, used in
                                 SB Pro-I)
          MIDI_OPL3            - OPL3 synth (stereo, SB Pro-II
                                 and above)
          MIDI_SB_OUT          - SB MIDI interface
          MIDI_MPU             - MPU-401 MIDI interface
          MIDI_DIGMID          - sample-based software wavetable player
          MIDI_AWE32           - AWE32 (EMU8000 chip)

See also:
*Note detect_midi_driver::.
*Note install_sound::.
*Note install_sound_input::.


File: allegro.info,  Node: DOS integration routines,  Next: i_love_bill,  Prev: MIDI_*/DOS,  Up: DOS

2.1.5 DOS integration routines
------------------------------


File: allegro.info,  Node: i_love_bill,  Next: JOY_TYPE_*/Windows,  Prev: DOS integration routines,  Up: DOS

2.1.6 i_love_bill
-----------------

extern int i_love_bill;
     When running in clean DOS mode, the timer handler dynamically
     reprograms the clock chip to generate interrupts at exactly the
     right times, which gives an extremely high accuracy.
     Unfortunately, this constant speed adjustment doesn't work under
     most multitasking systems (notably Windows), so there is an
     alternative mode that just locks the hardware timer interrupt to a
     speed of 200 ticks per second.  This reduces the accuracy of the
     timer (for instance, rest() will round the delay time to the
     nearest 5 milliseconds), and prevents the vertical retrace
     simulator from working, but on the plus side, it makes Allegro
     programs work under Windows.  This flag is set by allegro_init() if
     it detects the presence of a multitasking OS, and enables the fixed
     rate timer mode.

See also:
*Note install_timer::.
*Note allegro_init::.
*Note os_type::.


File: allegro.info,  Node: Windows,  Next: Unix,  Prev: DOS,  Up: Platform

2.2 Windows specifics
=====================

In terms of file redistribution, the Windows platform behaves
practically the same as the DOS platform.  Read section chapter "Dos
specifics" in the manual to learn more about this.

A Windows program that uses the Allegro library is only required to
include one or more header files from the include/allegro tree, or
allegro.h; however, if it also needs to directly call non portable Win32
API functions, it must include the Windows-specific header file
winalleg.h after the Allegro headers, and before any Win32 API header
file.  By default winalleg.h includes the main Win32 C API header file
windows.h.  If instead you want to use the C++ interface to the Win32
API (a.k.a.  the Microsoft Foundation Classes), define the preprocessor
symbol ALLEGRO_AND_MFC before including any Allegro header so that
afxwin.h will be included.  Note that, in this latter case, the Allegro
debugging macros ASSERT() and TRACE() are renamed AL_ASSERT() and
AL_TRACE() respectively.

Windows GUI applications start with a WinMain() entry point, rather than
the standard main() entry point.  Allegro is configured to build GUI
applications by default and to do some magic in order to make a regular
main() work with them, but you have to help it out a bit by writing
END_OF_MAIN() right after your main() function.  If you don't want to do
that, you can just include winalleg.h and write a WinMain() function.
Note that this magic may bring about conflicts with a few programs using
direct calls to Win32 API functions; for these programs, the regular
WinMain() is required and the magic must be disabled by defining the
preprocessor symbol ALLEGRO_NO_MAGIC_MAIN before including Allegro
headers.

If you want to build a console application using Allegro, you have to
define the preprocessor symbol ALLEGRO_USE_CONSOLE before including
Allegro headers; it will instruct the library to use console features
and also to disable the special processing of the main() function
described above.

When creating the main window, Allegro searches the executable for an
ICON resource named "allegro_icon".  If it is present, Allegro
automatically loads it and uses it as its application icon; otherwise,
Allegro uses the default IDI_APPLICATION icon.  See the manual of your
compiler for a method to create an ICON resource, or use the wfixicon
utility from the tools/win directory.

DirectX requires that system and video bitmaps (including the screen) be
locked before you can draw onto them.  This will be done automatically,
but you can usually get much better performance by doing it yourself:
see the acquire_bitmap() function for details.

Due to a major oversight in the design of DirectX, there is no way to
preserve the contents of video memory when the user switches away from
your program.  You need to be prepared for the fact that your screen
contents, and the contents of any video memory bitmaps, may be destroyed
at any point.  You can use the set_display_switch_callback() function to
find out when this happens.

On the Windows platform, the only return values for the
desktop_color_depth() function are 8, 16, 24 and 32.  This means that
15-bit and 16-bit desktops cannot be differentiated and are both
reported as 16-bit desktops.  See below for the consequences for
windowed and overlay DirectX drivers.

* Menu:

* JOY_TYPE_*/Windows::
* GFX_*/Windows::
* DIGI_*/Windows::
* MIDI_*/Windows::
* Windows integration routines::
* win_get_window::
* win_set_window::
* win_set_wnd_create_proc::
* win_get_dc::
* win_release_dc::
* win_set_msg_pre_proc::
* GDI routines::
* set_gdi_color_format::
* set_palette_to_hdc::
* convert_palette_to_hpalette::
* convert_hpalette_to_palette::
* convert_bitmap_to_hbitmap::
* convert_hbitmap_to_bitmap::
* draw_to_hdc::
* blit_to_hdc::
* stretch_blit_to_hdc::
* blit_from_hdc::
* stretch_blit_from_hdc::


File: allegro.info,  Node: JOY_TYPE_*/Windows,  Next: GFX_*/Windows,  Prev: i_love_bill,  Up: Windows

2.2.1 JOY_TYPE_*/Windows
------------------------

Drivers JOY_TYPE_*/Windows
     The Windows library supports the following type parameters for the
     install_joystick() function:

        * JOY_TYPE_AUTODETECT
          Attempts to autodetect your joystick hardware.  It will use
          information from the configuration file if one is available
          (this can be created using the setup utility or by calling the
          save_joystick_data() function), so you can always use
          JOY_TYPE_AUTODETECT in your code and then select the exact
          hardware type from the setup program.
        * JOY_TYPE_NONE
          Dummy driver for machines without any joystick.
        * JOY_TYPE_DIRECTX
          Use DirectInput to access the joystick.
        * JOY_TYPE_WIN32
          Use the regular Win32 interface rather than DirectInput to
          access the joystick.

See also:
*Note install_joystick::.


File: allegro.info,  Node: GFX_*/Windows,  Next: DIGI_*/Windows,  Prev: JOY_TYPE_*/Windows,  Up: Windows

2.2.2 GFX_*/Windows
-------------------

Drivers GFX_*/Windows
     The Windows library supports the following card parameters for the
     set_gfx_mode() function:

        * GFX_TEXT
          This closes any graphics mode previously opened with
          set_gfx_mode.
        * GFX_AUTODETECT
          Let Allegro pick an appropriate graphics driver.
        * GFX_AUTODETECT_FULLSCREEN
          Autodetects a graphics driver, but will only use fullscreen
          drivers, failing if these are not available on current
          platform.
        * GFX_AUTODETECT_WINDOWED
          Same as above, but uses only windowed drivers.
        * GFX_SAFE
          Special driver for when you want to reliably set a graphics
          mode and don't really care what resolution or color depth you
          get.  See the set_gfx_mode() documentation for details.
        * GFX_DIRECTX
          Alias for GFX_DIRECTX_ACCEL.
        * GFX_DIRECTX_ACCEL
          The regular fullscreen DirectX driver, running with hardware
          acceleration enabled.
        * GFX_DIRECTX_SOFT
          DirectX fullscreen driver that only uses software drawing,
          rather than any hardware accelerated features.
        * GFX_DIRECTX_SAFE
          Simplified fullscreen DirectX driver that doesn't support any
          hardware acceleration, video or system bitmaps, etc.
        * GFX_DIRECTX_WIN
          The regular windowed DirectX driver, running in color
          conversion mode when the color depth doesn't match that of the
          Windows desktop.  Color conversion is much slower than direct
          drawing and is not supported between 15-bit and 16-bit color
          depths.  This limitation is needed to work around that of
          desktop_color_depth() (see above) and allows to select the
          direct drawing mode in a reliable way on desktops reported as
          16-bit:

               if (desktop_color_depth() == 16) {
                  set_color_depth(16);
                  if (set_gfx_mode(GFX_DIRECTX_WIN, 640, 480, 0, 0)
                      != 0) {
                     set_color_depth(15);
                     if (set_gfx_mode(GFX_DIRECTX_WIN, 640, 480, 0, 0)
                         != 0) {
                        /* 640x480 direct drawing mode not supported */
                        goto Error;
                     }
                  }
                  /* ok, we are in direct drawing mode */
               }

          Note that, mainly for performance reasons, this driver
          requires the width of the screen to be a multiple of 4.  This
          driver is capable of displaying a hardware cursor, but there
          are size restrictions.  Typically, the cursor image cannot be
          more than 32x32 pixels.
        * GFX_DIRECTX_OVL
          The DirectX overlay driver.  It uses special hardware features
          to run your program in a windowed mode: it doesn't work on all
          hardware, but performance is excellent on cards that are
          capable of it.  It requires the color depth to be the same as
          that of the Windows desktop.  In light of the limitation of
          desktop_color_depth() (see above), the reliable way of setting
          the overlay driver on desktops reported as 16-bit is:

               if (desktop_color_depth() == 16) {
                  set_color_depth(16);
                  if (set_gfx_mode(GFX_DIRECTX_OVL, 640, 480, 0, 0)
                      != 0) {
                     set_color_depth(15);
                     if (set_gfx_mode(GFX_DIRECTX_OVL, 640, 480, 0, 0)
                         != 0) {
                        /* 640x480 overlay driver not supported */
                        goto Error;
                     }
                  }
                  /* ok, the 640x480 overlay driver is running */
               }

        * GFX_GDI
          The windowed GDI driver.  It is extremely slow, but is
          guaranteed to work on all hardware, so it can be useful for
          situations where you want to run in a window and don't care
          about performance.  Note that this driver features a hardware
          mouse cursor emulation in order to speed up basic mouse
          operations (like GUI operations).

See also:
*Note set_gfx_mode::.


File: allegro.info,  Node: DIGI_*/Windows,  Next: MIDI_*/Windows,  Prev: GFX_*/Windows,  Up: Windows

2.2.3 DIGI_*/Windows
--------------------

Drivers DIGI_*/Windows
     The Windows sound functions support the following digital sound
     cards:

          DIGI_AUTODETECT      - let Allegro pick a digital sound driver
          DIGI_NONE            - no digital sound
          DIGI_DIRECTX(n)      - use DirectSound device #n (zero-based)
                                 with direct mixing
          DIGI_DIRECTAMX(n)    - use DirectSound device #n (zero-based)
                                 with Allegro mixing
          DIGI_WAVOUTID(n)     - high (n=0) or low (n=1) quality WaveOut
                                 device

See also:
*Note detect_digi_driver::.
*Note install_sound::.
*Note install_sound_input::.


File: allegro.info,  Node: MIDI_*/Windows,  Next: Windows integration routines,  Prev: DIGI_*/Windows,  Up: Windows

2.2.4 MIDI_*/Windows
--------------------

Drivers MIDI_*/Windows
     The Windows sound functions support the following MIDI sound cards:

          MIDI_AUTODETECT      - let Allegro pick a MIDI sound driver
          MIDI_NONE            - no MIDI sound
          MIDI_WIN32MAPPER     - use win32 MIDI mapper
          MIDI_WIN32(n)        - use win32 device #n (zero-based)
          MIDI_DIGMID          - sample-based software wavetable player

See also:
*Note detect_midi_driver::.
*Note install_sound::.
*Note install_sound_input::.


File: allegro.info,  Node: Windows integration routines,  Next: win_get_window,  Prev: MIDI_*/Windows,  Up: Windows

2.2.5 Windows integration routines
----------------------------------

The following functions provide a platform specific interface to
seamlessly integrate Allegro into general purpose Win32 programs.  To
use these routines, you must include winalleg.h after other Allegro
headers.


File: allegro.info,  Node: win_get_window,  Next: win_set_window,  Prev: Windows integration routines,  Up: Windows

2.2.6 win_get_window
--------------------

HWND win_get_window(void);
     Retrieves a handle to the window used by Allegro.  Note that
     Allegro uses an underlying window even though you don't set any
     graphics mode, unless you have installed the neutral system driver
     (SYSTEM_NONE).


File: allegro.info,  Node: win_set_window,  Next: win_set_wnd_create_proc,  Prev: win_get_window,  Up: Windows

2.2.7 win_set_window
--------------------

void win_set_window(HWND wnd);
     Registers an user-created window to be used by Allegro.  This
     function is meant to be called before initialising the library with
     allegro_init() or installing the autodetected system driver
     (SYSTEM_AUTODETECT). It lets you attach Allegro to any already
     existing window and prevents the library from creating its own,
     thus leaving you total control over the window; in particular, you
     are responsible for processing the events as usual (Allegro will
     automatically monitor a few of them, but will not filter out any of
     them).  You can then use every component of the library (graphics,
     mouse, keyboard, sound, timers and so on), bearing in mind that
     some Allegro functions are blocking (e.g.  readkey() if the key
     buffer is empty) and thus must be carefully manipulated by the
     window thread.

     However you can also call it after the library has been
     initialised, provided that no graphics mode is set.  In this case
     the keyboard, mouse, joystick, sound and sound recording modules
     will be restarted.

     Passing NULL instructs Allegro to switch back to its built-in
     window if an user-created window was registered, or to request a
     new handle from Windows for its built-in window if this was already
     in use.


File: allegro.info,  Node: win_set_wnd_create_proc,  Next: win_get_dc,  Prev: win_set_window,  Up: Windows

2.2.8 win_set_wnd_create_proc
-----------------------------

void win_set_wnd_create_proc(HWND (*proc)(WNDPROC));
     Registers an user-defined procedure to be used by Allegro for
     creating its window.  This function must be called *before*
     initializing the library with allegro_init() or installing the
     autodetected system driver (SYSTEM_AUTODETECT). It lets you
     customize Allegro's window but only by its creation: unlike with
     win_set_window(), you have no control over the window once it has
     been created (in particular, you are not responsible for processing
     the events).  The registered function will be passed a window
     procedure (WNDPROC object) that it must make the procedure of the
     new window of and it must return a handle to the new window.  You
     can then use the full-featured library in the regular way.


File: allegro.info,  Node: win_get_dc,  Next: win_release_dc,  Prev: win_set_wnd_create_proc,  Up: Windows

2.2.9 win_get_dc
----------------

HDC win_get_dc(BITMAP *bmp);
     Retrieves a handle to the device context of a DirectX video or
     system bitmap.

*Note BITMAP::.


File: allegro.info,  Node: win_release_dc,  Next: win_set_msg_pre_proc,  Prev: win_get_dc,  Up: Windows

2.2.10 win_release_dc
---------------------

void win_release_dc(BITMAP *bmp, HDC dc);
     Releases a handle to the device context of the bitmap that was
     previously retrieved with win_get_dc().

*Note BITMAP::.


File: allegro.info,  Node: win_set_msg_pre_proc,  Next: GDI routines,  Prev: win_release_dc,  Up: Windows

2.2.11 win_set_msg_pre_proc
---------------------------

void win_set_msg_pre_proc(int (*proc)(HWND, UINT, WPARAM, LPARAM, int *retval));
     Set a user callback to be called on window events.  This callback
     function takes the same parameters as a normal window callback
     procedure plus an additional pointer to an integer.  This pointer
     should be filled with a return value that must be set if the
     callback has completely processed the window event.  If the
     callback has completely processed the window event, it should
     return 0 and fill retval with a proper value (the default is zero),
     otherwise it should return a non-zero value, and event processing
     will continue in Allegro's default window callback procedure.


File: allegro.info,  Node: GDI routines,  Next: set_gdi_color_format,  Prev: win_set_msg_pre_proc,  Up: Windows

2.2.12 GDI routines
-------------------

The following GDI routines are a very platform specific thing, to allow
drawing Allegro memory bitmaps onto a Windows device context.  When you
want to use this, you'll have to install the neutral system driver
(SYSTEM_NONE) or attach Allegro to an external window with
win_set_window().

There are two ways to draw your Allegro bitmaps to the Windows GDI. When
you are using static bitmaps (for example just some pictures loaded from
a datafile), you can convert them to DDB (device-dependent bitmaps) with
convert_bitmap_to_hbitmap() and then just use Win32's BitBlt() to draw
it.

When you are using dynamic bitmaps (for example some things which react
to user input), it's better to use set_palette_to_hdc() and
blit_to_hdc() functions, which work with DIB (device-independent
bitmaps).

There are also functions to blit from a device context into an Allegro
BITMAP, so you can do things like screen capture.

All the drawing and conversion functions use the current palette as a
color conversion table.  You can alter the current palette with the
set_palette_to_hdc() or select_palette() functions.  Warning: when the
GDI system color palette is explicitly changed, (by another application,
for example) the current Allegro palette is not updated along with it!

To use these routines, you must include winalleg.h after Allegro
headers.


File: allegro.info,  Node: set_gdi_color_format,  Next: set_palette_to_hdc,  Prev: GDI routines,  Up: Windows

2.2.13 set_gdi_color_format
---------------------------

void set_gdi_color_format(void);
     Tells Allegro to use the GDI color layout for truecolor images.
     This is optional, but it will make the conversions work faster.  If
     you are going to call this, you should do it right after
     initialising Allegro and before creating any graphics.


File: allegro.info,  Node: set_palette_to_hdc,  Next: convert_palette_to_hpalette,  Prev: set_gdi_color_format,  Up: Windows

2.2.14 set_palette_to_hdc
-------------------------

void set_palette_to_hdc(HDC dc, PALETTE pal);
     Selects and realizes an Allegro palette on the specified device
     context.

*Note PALETTE::.


File: allegro.info,  Node: convert_palette_to_hpalette,  Next: convert_hpalette_to_palette,  Prev: set_palette_to_hdc,  Up: Windows

2.2.15 convert_palette_to_hpalette
----------------------------------

HPALETTE convert_palette_to_hpalette(PALETTE pal);
     Converts an Allegro palette to a Windows palette and returns a
     handle to it.  You should call DeleteObject() when you no longer
     need it.

See also:
*Note convert_hpalette_to_palette::.
*Note PALETTE::.


File: allegro.info,  Node: convert_hpalette_to_palette,  Next: convert_bitmap_to_hbitmap,  Prev: convert_palette_to_hpalette,  Up: Windows

2.2.16 convert_hpalette_to_palette
----------------------------------

void convert_hpalette_to_palette(HPALETTE hpal, PALETTE pal);
     Converts a Windows palette to an Allegro palette.

See also:
*Note convert_palette_to_hpalette::.
*Note PALETTE::.


File: allegro.info,  Node: convert_bitmap_to_hbitmap,  Next: convert_hbitmap_to_bitmap,  Prev: convert_hpalette_to_palette,  Up: Windows

2.2.17 convert_bitmap_to_hbitmap
--------------------------------

HBITMAP convert_bitmap_to_hbitmap(BITMAP *bitmap);
     Converts an Allegro memory bitmap to a Windows DDB and returns a
     handle to it.  This bitmap uses its own memory, so you can destroy
     the original bitmap without affecting the converted one.  You
     should call DeleteObject() when you no longer need this bitmap.

See also:
*Note convert_hbitmap_to_bitmap::.
*Note BITMAP::.


File: allegro.info,  Node: convert_hbitmap_to_bitmap,  Next: draw_to_hdc,  Prev: convert_bitmap_to_hbitmap,  Up: Windows

2.2.18 convert_hbitmap_to_bitmap
--------------------------------

BITMAP *convert_hbitmap_to_bitmap(HBITMAP bitmap);
     Creates an Allegro memory bitmap from a Windows DDB.

See also:
*Note convert_bitmap_to_hbitmap::.
*Note BITMAP::.


File: allegro.info,  Node: draw_to_hdc,  Next: blit_to_hdc,  Prev: convert_hbitmap_to_bitmap,  Up: Windows

2.2.19 draw_to_hdc
------------------

void draw_to_hdc(HDC dc, BITMAP *bitmap, int x, int y);
     Draws an entire Allegro bitmap to a Windows device context, using
     the same parameters as the draw_sprite() function.

See also:
*Note blit_to_hdc::.
*Note stretch_blit_to_hdc::.
*Note draw_sprite::.
*Note BITMAP::.


File: allegro.info,  Node: blit_to_hdc,  Next: stretch_blit_to_hdc,  Prev: draw_to_hdc,  Up: Windows

2.2.20 blit_to_hdc
------------------

void blit_to_hdc(BITMAP *bitmap, HDC dc, int sx, sy, dx, dy, w, h);
     Blits an Allegro memory bitmap to a Windows device context, using
     the same parameters as the blit() function.

See also:
*Note draw_to_hdc::.
*Note stretch_blit_to_hdc::.
*Note blit_from_hdc::.
*Note blit::.
*Note BITMAP::.


File: allegro.info,  Node: stretch_blit_to_hdc,  Next: blit_from_hdc,  Prev: blit_to_hdc,  Up: Windows

2.2.21 stretch_blit_to_hdc
--------------------------

void stretch_blit_to_hdc(BITMAP *bitmap, HDC dc, int sx, sy, sw, sh, int dx, dy, dw, dh);
     Blits an Allegro memory bitmap to a Windows device context, using
     the same parameters as the stretch_blit() function.

See also:
*Note draw_to_hdc::.
*Note blit_to_hdc::.
*Note stretch_blit_from_hdc::.
*Note stretch_blit::.
*Note BITMAP::.


File: allegro.info,  Node: blit_from_hdc,  Next: stretch_blit_from_hdc,  Prev: stretch_blit_to_hdc,  Up: Windows

2.2.22 blit_from_hdc
--------------------

void blit_from_hdc(HDC hdc, BITMAP *bitmap, int sx, sy, dx, dy, w, h);
     Blits from a Windows device context to an Allegro memory bitmap,
     using the same parameters as the blit() function.  See
     stretch_blit_from_hdc() for details.

See also:
*Note stretch_blit_from_hdc::.
*Note blit_to_hdc::.
*Note blit::.
*Note BITMAP::.


File: allegro.info,  Node: stretch_blit_from_hdc,  Next: JOY_TYPE_*/Linux,  Prev: blit_from_hdc,  Up: Windows

2.2.23 stretch_blit_from_hdc
----------------------------

void stretch_blit_from_hdc(HDC hcd, BITMAP *bitmap, int sx, sy, sw, sh, int dx, dy, dw, dh);
     Blits from a Windows device context to an Allegro memory bitmap,
     using the same parameters as the stretch_blit() function.  It uses
     the current Allegro palette and does conversion to this palette,
     regardless of the current DC palette.  So if you are blitting from
     8-bit mode, you should first set the DC palette with the
     set_palette_to_hdc() function.

See also:
*Note blit_from_hdc::.
*Note stretch_blit_to_hdc::.
*Note stretch_blit::.
*Note BITMAP::.


File: allegro.info,  Node: Unix,  Next: BeOS,  Prev: Windows,  Up: Platform

2.3 Unix specifics
==================

Under Unix you usually have two ways of redistributing your binaries.
You either pack everything in a single directory, even providing Allegro
in binary or source form for the user to compile.  Or your program is
being packaged separately from Allegro and stored in different paths.
For the first case of redistribution, read section "Files shared by
Allegro" from the "Dos specifics" chapter to learn more about this.

For the second type, you can ignore redistributing the setup, keyboard
mappings and language datafiles, because they will be already installed
in the system.  This, however, is problematic if you are using
get_config_text() to localise your program's text strings.

The problem is that on other platforms you usually mix your program's
text strings with those of Allegro (found in the 'resources' directory)
to create a special language.dat.  And it is likely that the Allegro
library installed on the user's system already contains a datafile.dat.
You can go ahead and still provide your own language.dat file, but this
will mean that if Allegro is updated, your language.dat file may not
contain all the text strings used by the new version.

Given the slow paced release cycle of Allegro, this might not be a
concern.  However, if you want to make it easy on system administrators,
instead of providing your own 'language.dat', you should provide the
separate 'xxtext.cfg' files it in a separate directory.  Then, before
showing the strings to the user you can detect the language setting and
use override_config_file() with the appropriate localisation file and
call reload_config_texts().

In order to locate things like the config and translation files, Allegro
needs to know the path to your executable.  Since there is no standard
way to find that, it needs to capture a copy of your argv[] parameter,
and it does this with some preprocessor macro trickery.  Unfortunately
it can't quite pull this off without a little bit of your help, so you
will have to write END_OF_MAIN() right after your main() function.
Pretty easy, really, and if you forget, you'll get a nice linker error
about a missing _mangled_main function to remind you :-)

Under Unix resources are searched for in many different paths (see
above).  When a configuration resource is looked for, it is usually
tried with the variations 'name.cfg' or '.namerc' in multiple paths: the
current directory, the directory pointed to by the ALLEGRO environment
variable, the user's home directory, one or more global system
directories which usually only the root user has access to and any
custom paths set up with set_allegro_resource_path().  Text files, like
the main allegro config file or a language text translation files are
looked for in the following places:

     ./allegro.cfg
     $ALLEGRO/allegro.cfg
     ~/allegro.cfg
     ~/.allegrorc
     /etc/allegro.cfg
     /etc/allegrorc

Binary resources like the language translation files packfile
(language.dat) are looked for in:

     ./language.dat
     $ALLEGRO/language.dat
     ~/language.dat
     /etc/language.dat
     /usr/share/allegro/language.dat
     /usr/local/share/allegro/language.dat

Note that if you have installed Allegro from the source distribution
with the typical 'make install', global files like 'language.dat' and
'allegro.cfg' will not have been installed.  As a system administrator
you are required to install them manually wherever you prefer to have
them.  If you suspect that an Allegro program is somehow not finding the
correct configuration file, you could try using the following command:

     strace program 2>&1|egrep "(open|stat)"

The strace program traces system calls and signals.  By default it
outputs the information to stderr, so that's why we redirect it to stdin
with '2>&1'.  Since we are interested only in files being
(un)successfully opened, we restrict the output of the log to stat or
open calls with the extended grep command.  You could add another grep
to filter only lines with text like 'language' or 'allegro'.

* Menu:

* JOY_TYPE_*/Linux::
* GFX_*/Linux::
* GFX_*/X::
* DIGI_*/Unix::
* MIDI_*/Unix::
* Unix integration routines::
* xwin_set_window_name::
* allegro_icon::


File: allegro.info,  Node: JOY_TYPE_*/Linux,  Next: GFX_*/Linux,  Prev: stretch_blit_from_hdc,  Up: Unix

2.3.1 JOY_TYPE_*/Linux
----------------------

Drivers JOY_TYPE_*/Linux
     The Linux library supports the following type parameters for the
     install_joystick() function:

        * JOY_TYPE_AUTODETECT
          Attempts to autodetect your joystick hardware.  It will use
          information from the configuration file if one is available
          (this can be created using the setup utility or by calling the
          save_joystick_data() function), so you can always use
          JOY_TYPE_AUTODETECT in your code and then select the exact
          hardware type from the setup program.
        * JOY_TYPE_NONE
          Dummy driver for machines without any joystick.
        * JOY_TYPE_LINUX_ANALOGUE
          Regular joystick interface.  Joystick support needs to be
          enabled in your kernel.

See also:
*Note install_joystick::.


File: allegro.info,  Node: GFX_*/Linux,  Next: GFX_*/X,  Prev: JOY_TYPE_*/Linux,  Up: Unix

2.3.2 GFX_*/Linux
-----------------

Drivers GFX_*/Linux
     When running in Linux console mode, Allegro supports the following
     card parameters for the set_gfx_mode() function:

        * GFX_TEXT
          Return to text mode.
        * GFX_AUTODETECT
          Let Allegro pick an appropriate graphics driver.
        * GFX_AUTODETECT_FULLSCREEN
          Autodetects a graphics driver, but will only use fullscreen
          drivers, failing if these are not available on current
          platform.
        * GFX_AUTODETECT_WINDOWED
          Same as above, but uses only windowed drivers.  This will
          always fail under Linux console mode.
        * GFX_SAFE
          Special driver for when you want to reliably set a graphics
          mode and don't really care what resolution or color depth you
          get.  See the set_gfx_mode() documentation for details.
        * GFX_FBCON
          Use the framebuffer device (eg.  /dev/fb0).  This requires you
          to have framebuffer support compiled into your kernel, and
          correctly configured for your hardware.  It is currently the
          only console mode driver that will work without root
          permissions, unless you are using a development version of
          SVGAlib.
        * GFX_VBEAF
          Use a VBE/AF driver (vbeaf.drv), assuming that you have
          installed one which works under Linux (currently only two of
          the FreeBE/AF project drivers are capable of this: I don't
          know about the SciTech ones).  VBE/AF requires root
          permissions, but is currently the only Linux driver which
          supports hardware accelerated graphics.
        * GFX_SVGALIB
          Use the SVGAlib library for graphics output.  This requires
          root permissions if your version of SVGAlib requires them.
        * GFX_VGA
          GFX_MODEX
          Use direct hardware access to set standard VGA or mode-X
          resolutions, supporting the same modes as in the DOS versions
          of these drivers.  Requires root permissions.

See also:
*Note set_gfx_mode::.
*Note GFX_*/X::.


File: allegro.info,  Node: GFX_*/X,  Next: DIGI_*/Unix,  Prev: GFX_*/Linux,  Up: Unix

2.3.3 GFX_*/X
-------------

Drivers GFX_*/X
     When running in X mode, Allegro supports the following card
     parameters for the set_gfx_mode() function:

        * GFX_TEXT
          This closes any graphics mode previously opened with
          set_gfx_mode.
        * GFX_AUTODETECT
          Let Allegro pick an appropriate graphics driver.
        * GFX_AUTODETECT_FULLSCREEN
          Autodetects a graphics driver, but will only use fullscreen
          drivers, failing if these are not available on current
          platform.
        * GFX_AUTODETECT_WINDOWED
          Same as above, but uses only windowed drivers.
        * GFX_SAFE
          Special driver for when you want to reliably set a graphics
          mode and don't really care what resolution or color depth you
          get.  See the set_gfx_mode() documentation for details.
        * GFX_XWINDOWS
          The standard X graphics driver.  This should work on any Unix
          system, and can operate remotely.  It does not require root
          permissions.  If the ARGB cursor extension is available, this
          driver is capable of displaying a hardware cursor.  This needs
          to be enabled by calling enable_hardware_cursor() because it
          cannot be used reliably alongside get_mouse_mickeys().
        * GFX_XWINDOWS_FULLSCREEN
          The same as above, but while GFX_XWINDOWS runs windowed, this
          one uses the XF86VidMode extension to make it run in
          fullscreen mode even without root permissions.  You're still
          using the standard X protocol though, so expect the same low
          performances as with the windowed driver version.  If the ARGB
          cursor extension is available, this driver is capable of
          displaying a hardware cursor.  This needs to be enabled by
          calling enable_hardware_cursor() because it cannot be used
          reliably alongside get_mouse_mickeys().
        * GFX_XDGA2
          Use new DGA 2.0 extension provided by XFree86 4.0.x.  This
          will work in fullscreen mode, and it will support hardware
          acceleration if available.  This driver requires root
          permissions.
        * GFX_XDGA2_SOFT
          The same as GFX_XDGA2, but turns off hardware acceleration
          support.  This driver requires root permissions.

See also:
*Note set_gfx_mode::.
*Note GFX_*/Linux::.


File: allegro.info,  Node: DIGI_*/Unix,  Next: MIDI_*/Unix,  Prev: GFX_*/X,  Up: Unix

2.3.4 DIGI_*/Unix
-----------------

Drivers DIGI_*/Unix
     The Unix sound functions support the following digital sound cards:

          DIGI_AUTODETECT      - let Allegro pick a digital sound driver
          DIGI_NONE            - no digital sound
          DIGI_OSS             - Open Sound System
          DIGI_ESD             - Enlightened Sound Daemon
          DIGI_ARTS            - aRts (Analog Real-Time Synthesizer)
          DIGI_ALSA            - ALSA sound driver
          DIGI_JACK            - JACK sound driver

See also:
*Note detect_digi_driver::.
*Note install_sound::.
*Note install_sound_input::.


File: allegro.info,  Node: MIDI_*/Unix,  Next: Unix integration routines,  Prev: DIGI_*/Unix,  Up: Unix

2.3.5 MIDI_*/Unix
-----------------

Drivers MIDI_*/Unix
     The Unix sound functions support the following MIDI sound cards:

          MIDI_AUTODETECT      - let Allegro pick a MIDI sound driver
          MIDI_NONE            - no MIDI sound
          MIDI_OSS             - Open Sound System
          MIDI_DIGMID          - sample-based software wavetable player
          MIDI_ALSA            - ALSA RawMIDI driver

See also:
*Note detect_midi_driver::.
*Note install_sound::.
*Note install_sound_input::.


File: allegro.info,  Node: Unix integration routines,  Next: xwin_set_window_name,  Prev: MIDI_*/Unix,  Up: Unix

2.3.6 Unix integration routines
-------------------------------


File: allegro.info,  Node: xwin_set_window_name,  Next: allegro_icon,  Prev: Unix integration routines,  Up: Unix

2.3.7 xwin_set_window_name
--------------------------

void xwin_set_window_name(const char *name, const char *group);
     This function is only available under X. It lets you to specify the
     window name and group (or class).  They are important because they
     allow the window manager to remember the window attributes
     (position, layer, etc).  Note that the name and the title of the
     window are two different things: the title is what appears in the
     title bar of the window, but usually has no other effects on the
     behaviour of the application.

See also:
*Note set_window_title::.


File: allegro.info,  Node: allegro_icon,  Next: GFX_*/BeOS,  Prev: xwin_set_window_name,  Up: Unix

2.3.8 allegro_icon
------------------

extern void *allegro_icon;
     This is a pointer to the Allegro X11 icon, which is in the format
     of standard .xpm bitmap data.  You do not normally have to bother
     with this at all: you can use the xfixicon.sh utility from the
     tools/x11 directory to convert a true colour bitmap to a C file
     that you only need to link with your own code to set the icon.


File: allegro.info,  Node: BeOS,  Next: QNX,  Prev: Unix,  Up: Platform

2.4 BeOS specifics
==================

In terms of file redistribution, the BeOS platform behaves practically
the same as the DOS platform.  Read section chapter "Dos specifics" in
the manual to learn more about this.

* Menu:

* GFX_*/BeOS::
* DIGI_*/BeOS::
* MIDI_*/BeOS::


File: allegro.info,  Node: GFX_*/BeOS,  Next: DIGI_*/BeOS,  Prev: allegro_icon,  Up: BeOS

2.4.1 GFX_*/BeOS
----------------

Drivers GFX_*/BeOS
     BeOS Allegro supports the following card parameters for the
     set_gfx_mode() function:

        * GFX_TEXT
          This closes any graphics mode previously opened with
          set_gfx_mode.
        * GFX_AUTODETECT
          Let Allegro pick an appropriate graphics driver.
        * GFX_AUTODETECT_FULLSCREEN
          Autodetects a graphics driver, but will only use fullscreen
          drivers, failing if these are not available on current
          platform.
        * GFX_AUTODETECT_WINDOWED
          Same as above, but uses only windowed drivers.
        * GFX_SAFE
          Special driver for when you want to reliably set a graphics
          mode and don't really care what resolution.  See the
          set_gfx_mode() documentation for details.
        * GFX_BWINDOWSCREEN_ACCEL
          Fullscreen exclusive mode.  Supports only resolutions higher
          or equal to 640x480, and uses hardware acceleration if
          available.
        * GFX_BWINDOWSCREEN
          Works the same as GFX_BWINDOWSCREEN_ACCEL, but disables
          acceleration.
        * GFX_BDIRECTWINDOW
          Fast windowed mode using the BDirectWindow class.  Not all
          graphics cards support this.
        * GFX_BWINDOW
          Normal windowed mode using the BWindow class.  Slow but always
          works.
        * GFX_BWINDOW_OVERLAY
          Fullscreen mode using BWindow with a BBitmap overlay.  This
          mode isn't supported by all graphics cards, only supports 15,
          16 and 32-bit color depths, but allows any fullscreen
          resolution, even low ones that are normally unavailable under
          BeOS.

See also:
*Note set_gfx_mode::.


File: allegro.info,  Node: DIGI_*/BeOS,  Next: MIDI_*/BeOS,  Prev: GFX_*/BeOS,  Up: BeOS

2.4.2 DIGI_*/BeOS
-----------------

Drivers DIGI_*/BeOS
     The BeOS sound functions support the following digital sound cards:

          DIGI_AUTODETECT      - let Allegro pick a digital sound driver
          DIGI_NONE            - no digital sound
          DIGI_BEOS            - BeOS digital output

See also:
*Note detect_digi_driver::.
*Note install_sound::.
*Note install_sound_input::.


File: allegro.info,  Node: MIDI_*/BeOS,  Next: GFX_*/QNX,  Prev: DIGI_*/BeOS,  Up: BeOS

2.4.3 MIDI_*/BeOS
-----------------

Drivers MIDI_*/BeOS
     The BeOS sound functions support the following MIDI sound cards:

          MIDI_AUTODETECT      - let Allegro pick a MIDI sound driver
          MIDI_NONE            - no MIDI sound
          MIDI_BEOS            - BeOS MIDI output
          MIDI_DIGMID          - sample-based software wavetable player

See also:
*Note detect_midi_driver::.
*Note install_sound::.
*Note install_sound_input::.


File: allegro.info,  Node: QNX,  Next: MacOS,  Prev: BeOS,  Up: Platform

2.5 QNX specifics
=================

In terms of file redistribution, the QNX platform behaves practically
the same as the DOS platform.  Read section chapter "Dos specifics" in
the manual to learn more about this.

* Menu:

* GFX_*/QNX::
* DIGI_*/QNX::
* MIDI_*/QNX::
* QNX integration routines::
* qnx_get_window::


File: allegro.info,  Node: GFX_*/QNX,  Next: DIGI_*/QNX,  Prev: MIDI_*/BeOS,  Up: QNX

2.5.1 GFX_*/QNX
---------------

Drivers GFX_*/QNX
     QNX Allegro supports the following card parameters for the
     set_gfx_mode() function:

        * GFX_TEXT
          This closes any graphics mode previously opened with
          set_gfx_mode.
        * GFX_AUTODETECT
          Let Allegro pick an appropriate graphics driver.
        * GFX_AUTODETECT_FULLSCREEN
          Autodetects a graphics driver, but will only use fullscreen
          drivers, failing if these are not available on current
          platform.
        * GFX_AUTODETECT_WINDOWED
          Same as above, but uses only windowed drivers.
        * GFX_SAFE
          Special driver for when you want to reliably set a graphics
          mode and don't really care what resolution.  See the
          set_gfx_mode() documentation for details.
        * GFX_PHOTON
          Alias for GFX_PHOTON_ACCEL.
        * GFX_PHOTON_ACCEL
          Fullscreen exclusive mode through Photon, running with
          hardware acceleration enabled.
        * GFX_PHOTON_SOFT
          Fullscreen exclusive mode that only uses software drawing,
          rather than any hardware accelerated features.
        * GFX_PHOTON_SAFE
          Simplified fullscreen exclusive driver that doesn't support
          any hardware acceleration, video or system bitmaps, etc.
        * GFX_PHOTON_WIN
          The regular windowed Photon driver, running in color
          conversion mode when the color depth doesn't match that of the
          Photon desktop.  Color conversion is much slower than direct
          drawing.  Note that, mainly for performance reasons, this
          driver requires the width of the screen to be a multiple of 4.

See also:
*Note set_gfx_mode::.


File: allegro.info,  Node: DIGI_*/QNX,  Next: MIDI_*/QNX,  Prev: GFX_*/QNX,  Up: QNX

2.5.2 DIGI_*/QNX
----------------

Drivers DIGI_*/QNX
     The QNX sound functions support the following digital sound cards:

          DIGI_AUTODETECT      - let Allegro pick a digital sound driver
          DIGI_NONE            - no digital sound
          DIGI_ALSA            - ALSA sound driver

See also:
*Note detect_digi_driver::.
*Note install_sound::.
*Note install_sound_input::.


File: allegro.info,  Node: MIDI_*/QNX,  Next: QNX integration routines,  Prev: DIGI_*/QNX,  Up: QNX

2.5.3 MIDI_*/QNX
----------------

Drivers MIDI_*/QNX
     The QNX sound functions support the following MIDI sound cards:

          MIDI_AUTODETECT      - let Allegro pick a MIDI sound driver
          MIDI_NONE            - no MIDI sound
          MIDI_ALSA            - ALSA RawMIDI driver
          MIDI_DIGMID          - sample-based software wavetable player

See also:
*Note detect_midi_driver::.
*Note install_sound::.
*Note install_sound_input::.


File: allegro.info,  Node: QNX integration routines,  Next: qnx_get_window,  Prev: MIDI_*/QNX,  Up: QNX

2.5.4 QNX integration routines
------------------------------

The following functions provide a platform specific interface to
seamlessly integrate Allegro into general purpose QNX programs.  To use
these routines, you must include qnxalleg.h after other Allegro headers.


File: allegro.info,  Node: qnx_get_window,  Next: GFX_*/MacOSX,  Prev: QNX integration routines,  Up: QNX

2.5.5 qnx_get_window
--------------------

PtWidget_t qnx_get_window(void);
     Retrieves a handle to the window used by Allegro.  Note that
     Allegro uses an underlying window even though you don't set any
     graphics mode, unless you have installed the neutral system driver
     (SYSTEM_NONE).


File: allegro.info,  Node: MacOS,  Next: Differences,  Prev: QNX,  Up: Platform

2.6 MacOS X specifics
=====================

In terms of file redistribution, the MacOS X platform behaves
practically the same as the DOS platform.  Read section chapter "Dos
specifics" in the manual to learn more about this.

Allegro programs under MacOS X are Cocoa applications; in order to hide
all the Cocoa interfacing to the end-user, you need to add the
END_OF_MAIN() macro right after your main() function.  This is a
necessary step: if you omit it, your program will not compile.

The END_OF_MAIN() macro simply does some magic to make sure your program
executes another function before your main(); this function is defined
into the liballeg-main.a static library, which is automatically linked
if you use the allegro-config script when linking.  Otherwise be sure
you link against it unless you want to get undefined symbol errors.

To behave nicely with the MacOS X user interface, Allegro apps will
provide a standard application menu with the "Quit" menu item in it.
The default behaviour when the user hits Command-Q or selects "Quit" is
to do nothing.  To override this behaviour you must call the
set_close_button_callback() function; under MacOS X the supplied
callback will be used either if the user clicks the window close button
either on Command-Q or "Quit" selection.  In this last case the
application will not shutdown, but you are supposed to set some quit
flag in your callback and check for it on a regular basis in your main
program loop.

If you would like to use InterfaceBuilder to design a more
fully-featured menu, Allegro will automatically load it if you create a
bundle for your application.  The use of InterfaceBuilder is beyond the
scope of this document.  Briefly, you need to create a Nib, called
MainMenu.nib, containing a main menu and a controller.  Then, when you
create the bundle, install MainMenu.nib into the Contents/Resources
subdirectory.  Note that the actions attached to the menu items will be
called from a different thread than the one in which your Allegro code
is running.  Therefore you should not do any work there (especially,
don't call Allegro functions.)  Instead, set a variable, and test it in
your main loop.

* Menu:

* GFX_*/MacOSX::
* DIGI_*/MacOSX::
* MIDI_*/MacOSX::


File: allegro.info,  Node: GFX_*/MacOSX,  Next: DIGI_*/MacOSX,  Prev: qnx_get_window,  Up: MacOS

2.6.1 GFX_*/MacOSX
------------------

Drivers GFX_*/MacOSX
     MacOS X Allegro supports the following card parameters for the
     set_gfx_mode() function:

        * GFX_TEXT
          This closes any graphics mode previously opened with
          set_gfx_mode.
        * GFX_AUTODETECT
          Let Allegro pick an appropriate graphics driver.
        * GFX_AUTODETECT_FULLSCREEN
          Autodetects a graphics driver, but will only use fullscreen
          drivers, failing if these are not available on current
          platform.
        * GFX_AUTODETECT_WINDOWED
          Same as above, but uses only windowed drivers.
        * GFX_SAFE
          Special driver for when you want to reliably set a graphics
          mode and don't really care what resolution.  See the
          set_gfx_mode() documentation for details.
        * GFX_QUARTZ_FULLSCREEN
          Fullscreen exclusive mode, using the CGDirectDisplay
          interface.  Supports only resolutions higher or equal to
          640x480, and uses hardware acceleration if available.
        * GFX_QUARTZ_WINDOW
          Windowed mode using QuickDraw in a Cocoa window.

See also:
*Note set_gfx_mode::.


File: allegro.info,  Node: DIGI_*/MacOSX,  Next: MIDI_*/MacOSX,  Prev: GFX_*/MacOSX,  Up: MacOS

2.6.2 DIGI_*/MacOSX
-------------------

Drivers DIGI_*/MacOSX
     The MacOS X sound functions support the following digital sound
     cards:

          DIGI_AUTODETECT      - let Allegro pick a digital sound driver
          DIGI_NONE            - no digital sound
          DIGI_CORE_AUDIO      - CoreAudio digital output (OS >= X.2 required)
          DIGI_SOUND_MANAGER   - Carbon Sound Manager digital output

See also:
*Note detect_digi_driver::.
*Note install_sound::.
*Note install_sound_input::.


File: allegro.info,  Node: MIDI_*/MacOSX,  Next: ASSERT,  Prev: DIGI_*/MacOSX,  Up: MacOS

2.6.3 MIDI_*/MacOSX
-------------------

Drivers MIDI_*/MacOSX
     The MacOS X sound functions support the following MIDI sound cards:

          MIDI_AUTODETECT      - let Allegro pick a MIDI sound driver
          MIDI_NONE            - no MIDI sound
          MIDI_CORE_AUDIO      - CoreAudio MIDI synthesizer (OS >= X.2 required)
          MIDI_QUICKTIME       - QuickTime Music Note Allocator MIDI output
          MIDI_DIGMID          - sample-based software wavetable player

See also:
*Note detect_midi_driver::.
*Note install_sound::.
*Note install_sound_input::.


File: allegro.info,  Node: Differences,  Next: Miscellaneous,  Prev: MacOS,  Up: Platform

2.7 Differences between platforms
=================================

Here's a quick summary of things that may cause problems when moving
your code from one platform to another (you can find a more detailed
version of this in the docs section of the Allegro website).

The Windows, Unix and MacOS X versions require you to write
END_OF_MAIN() after your main() function.  This is used to magically
turn an ISO C style main() into a Windows style WinMain(), or by the
Unix code to grab a copy of your argv[] parameter, or by the MacOS X
code to shell the user main() inside a Cocoa application.

On many platforms Allegro runs very slowly if you rely on it in order to
automatically lock bitmaps when drawing onto them.  For good
performance, you need to call acquire_bitmap() and release_bitmap()
yourself, and try to keep the amount of locking to a minimum.

The Windows version may lose the contents of video memory if the user
switches away from your program, so you need to deal with that.

None of the currently supported platforms require input polling, but it
is possible that some future ones might, so if you want to ensure 100%
portability of your program, you should call poll_mouse() and
poll_keyboard() in all the relevant places.

On Unix the shared files by Allegro (like 'language.dat') may require a
special use due to the nature of distributing the resources in separate
paths instead of putting everything in the same directory.  Check the
beginning of your platform's specific chapter to learn more about this.

Allegro defines a number of standard macros that can be used to check
various attributes of the current platform:

ALLEGRO_PLATFORM_STR
Text string containing the name of the current platform.

ALLEGRO_DOS
ALLEGRO_DJGPP
ALLEGRO_WATCOM
ALLEGRO_WINDOWS
ALLEGRO_MSVC
ALLEGRO_MINGW32
ALLEGRO_BCC32
ALLEGRO_UNIX
ALLEGRO_LINUX
ALLEGRO_BEOS
ALLEGRO_QNX
ALLEGRO_DARWIN
ALLEGRO_MACOSX
ALLEGRO_GCC
Defined if you are building for a relevant system.  Often several of
these will apply, eg.  DOS+Watcom, or Windows+GCC+MinGW.

Note that ALLEGRO_LINUX is a misnomer.  It will only be defined if Linux
console support is enabled.  It is not a reliable way to check if the
program is being built on a Linux system.

ALLEGRO_AMD64
ALLEGRO_I386
ALLEGRO_BIG_ENDIAN
ALLEGRO_LITTLE_ENDIAN
Defined if you are building for a processor of the relevant type.

ALLEGRO_MULTITHREADED
Defined if the library is internally multi-threaded on this system.

ALLEGRO_USE_CONSTRUCTOR
Defined if the compiler supports constructor/destructor functions.

ALLEGRO_VRAM_SINGLE_SURFACE
Defined if the screen is a single large surface that is then partitioned
into multiple video sub-bitmaps (eg.  DOS), rather than each video
bitmap being a totally unique entity (eg.  Windows).

ALLEGRO_CONSOLE_OK
Defined if when you are not in a graphics mode, there is a text mode
console that you can printf() to, and from which the user could
potentially redirect stdout to capture it even while you are in a
graphics mode.  If this define is absent, you are running in an
environment like Windows that has no stdout at all.

ALLEGRO_MAGIC_MAIN
Defined if Allegro uses a magic main, i.e takes over the main() entry
point and turns it into a secondary entry point suited to its needs.

ALLEGRO_LFN
Non-zero if long filenames are supported, or zero if you are limited to
8.3 format (in the DJGPP version, this is a variable depending on the
runtime environment).

LONG_LONG
Defined to whatever represents a 64-bit "long long" integer for the
current compiler, or not defined if that isn't supported.

OTHER_PATH_SEPARATOR
Defined to a path separator character other than a forward slash for
platforms that use one (eg.  a backslash under DOS and Windows), or
defined to a forward slash if there is no other separator character.

DEVICE_SEPARATOR
Defined to the filename device separator character (a colon for DOS and
Windows), or to zero if there are no explicit devices in paths (Unix).

Allegro can be customized at compile time to a certain extent with the
following macros:

ALLEGRO_NO_MAGIC_MAIN
If you define this prior to including Allegro headers, Allegro won't
touch the main() entry point.  This effectively removes the requirement
on a program to be linked against the Allegro library when it includes
the allegro.h header file.  Note that the configuration and file
routines are not guaranteed to work on Unix systems when this symbol is
defined.  Moreover, on Darwin/MacOS X systems, this symbol simply
prevents the program from being linked against the Allegro library!
This highly non portable feature is primarily intended to be used under
Windows.

ALLEGRO_USE_CONSOLE
If you define this prior to including Allegro headers, Allegro will be
set up for building a console application rather than the default GUI
program on some platforms (especially Windows).

ALLEGRO_NO_STD_HEADER
If you define this prior to including Allegro headers, Allegro will not
automatically include some standard headers (eg <stddef.h>) its own
headers depend upon.

ALLEGRO_NO_KEY_DEFINES
If you define this prior to including Allegro headers, Allegro will omit
the definition of the KEY_* constants, which may clash with other
headers.

ALLEGRO_NO_FIX_ALIASES
The fixed point functions used to be named with an "f" prefix instead of
"fix", eg.  fixsqrt() used to be fsqrt(), but were renamed due to
conflicts with some libc implementations.  So backwards compatibility
aliases are provided as static inline functions which map the old names
to the new names, eg.  fsqrt() calls fixsqrt().  If you define this
symbol prior to including Allegro headers, the aliases will be turned
off.

ALLEGRO_NO_FIX_CLASS
If you define this symbol prior to including Allegro headers in a C++
source file, the 'fix' class will not be made available.  This mitigates
problems with the 'fix' class's overloading getting in the way.

ALLEGRO_NO_VHLINE_ALIAS
The 'curses' API also defines functions called vline() and hline().  To
avoid a linker conflict when both libraries are used, we have internally
renamed our functions and added inline function aliases which remap
vline() and hline().  This should not be noticeable to most users.

If you define ALLEGRO_NO_VHLINE_ALIAS prior to including Allegro
headers, Allegro will not define the vline() and hline() aliases, e.g.
so you can include curses.h and allegro.h in the same module.

ALLEGRO_NO_CLEAR_BITMAP_ALIAS
If you define this prior to including Allegro headers, Allegro will not
define the clear() backwards compatibility alias to clear_bitmap().

ALLEGRO_NO_COMPATIBILITY
If you define this prior to including Allegro headers, Allegro will not
include the backward compatibility layer.  It is undefined by default so
old programs can still be compiled with the minimum amount of issues,
but you should define this symbol if you intend to maintain your code up
to date with the latest versions of Allegro.  It automatically turns off
all backwards compatibility aliases.

Allegro also defines a number of standard macros that can be used to
insulate you from some of the differences between systems:

INLINE
Use this in place of the regular "inline" function modifier keyword, and
your code will work correctly on any of the supported compilers.

RET_VOLATILE
Use this to declare a function with a volatile return value.

ZERO_SIZE_ARRAY(type, name)
Use this to declare zero-sized arrays in terminal position inside
structures, like in the BITMAP structure.  These arrays are effectively
equivalent to the flexible array members of ISO C99.

AL_CONST
Use this in place of the regular "const" object modifier keyword, and
your code will work correctly on any of the supported compilers.

AL_RAND()
On platforms that require it, this macro does a simple shift
transformation of the libc rand() function, in order to improve the
perceived randomness of the output series in the lower 16 bits.  Where
not required, it directly translates into a rand() call.


File: allegro.info,  Node: Miscellaneous,  Next: Reducing,  Prev: Differences,  Up: Top

3 Miscellaneous
***************

* Menu:

* Reducing::                Reducing your executable size
* Debugging::               Debugging
* Available::               Available Allegro examples


File: allegro.info,  Node: Reducing,  Next: Debugging,  Prev: Miscellaneous,  Up: Miscellaneous

3.1 Reducing your executable size
=================================

Some people complain that Allegro produces very large executables.  This
is certainly true: with the DJGPP version, a simple "hello world"
program will be about 200k, although the per-executable overhead is much
less for platforms that support dynamic linking.  But don't worry,
Allegro takes up a relatively fixed amount of space, and won't increase
as your program gets larger.  As George Foot so succinctly put it,
anyone who is concerned about the ratio between library and program code
should just get to work and write more program code to catch up :-)

Having said that, there are several things you can do to make your
programs smaller:

   * For all platforms, you can use an executable compressor called UPX,
     which is available at http://upx.sourceforge.net/.  This usually
     manages a compression ratio of about 40%.
   * When using DJGPP: for starters, read the DJGPP FAQ section 8.14,
     and take note of the -s switch.  And don't forget to compile your
     program with optimisation enabled!
   * If a DOS program is only going to run in a limited number of
     graphics modes, you can specify which graphics drivers you would
     like to include with the code:

          BEGIN_GFX_DRIVER_LIST
             driver1
             driver2
             etc...
          END_GFX_DRIVER_LIST

     where the driver names are any of the defines:

          GFX_DRIVER_VBEAF
          GFX_DRIVER_VGA
          GFX_DRIVER_MODEX
          GFX_DRIVER_VESA3
          GFX_DRIVER_VESA2L
          GFX_DRIVER_VESA2B
          GFX_DRIVER_XTENDED
          GFX_DRIVER_VESA1

     This construct must be included in only one of your C source files.
     The ordering of the names is important, because the autodetection
     routine works down from the top of the list until it finds the
     first driver that is able to support the requested mode.  I suggest
     you stick to the default ordering given above, and simply delete
     whatever entries you aren't going to use.
   * If your DOS program doesn't need to use all the possible color
     depths, you can specify which pixel formats you want to support
     with the code:

          BEGIN_COLOR_DEPTH_LIST
             depth1
             depth2
             etc...
          END_COLOR_DEPTH_LIST

     where the color depth names are any of the defines:

          COLOR_DEPTH_8
          COLOR_DEPTH_15
          COLOR_DEPTH_16
          COLOR_DEPTH_24
          COLOR_DEPTH_32

     Removing any of the color depths will save quite a bit of space,
     with the exception of the 15 and 16-bit modes: these share a great
     deal of code, so if you are including one of them, there is no
     reason not to use both.  Be warned that if you try to use a color
     depth which isn't in this list, your program will crash horribly!
   * In the same way as the above, you can specify which DOS sound
     drivers you want to support with the code:

          BEGIN_DIGI_DRIVER_LIST
             driver1
             driver2
             etc...
          END_DIGI_DRIVER_LIST

     using the digital sound driver defines:

          DIGI_DRIVER_SOUNDSCAPE
          DIGI_DRIVER_AUDIODRIVE
          DIGI_DRIVER_WINSOUNDSYS
          DIGI_DRIVER_SB

     and for the MIDI music:

          BEGIN_MIDI_DRIVER_LIST
             driver1
             driver2
             etc...
          END_MIDI_DRIVER_LIST

     using the MIDI driver defines:

          MIDI_DRIVER_AWE32
          MIDI_DRIVER_DIGMID
          MIDI_DRIVER_ADLIB
          MIDI_DRIVER_MPU
          MIDI_DRIVER_SB_OUT

     If you are going to use either of these sound driver constructs,
     you must include both.
   * Likewise for the DOS joystick drivers, you can declare an inclusion
     list:

          BEGIN_JOYSTICK_DRIVER_LIST
             driver1
             driver2
             etc...
          END_JOYSTICK_DRIVER_LIST

     using the joystick driver defines:

          JOYSTICK_DRIVER_WINGWARRIOR
          JOYSTICK_DRIVER_SIDEWINDER
          JOYSTICK_DRIVER_GAMEPAD_PRO
          JOYSTICK_DRIVER_GRIP
          JOYSTICK_DRIVER_STANDARD
          JOYSTICK_DRIVER_SNESPAD
          JOYSTICK_DRIVER_PSXPAD
          JOYSTICK_DRIVER_N64PAD
          JOYSTICK_DRIVER_DB9
          JOYSTICK_DRIVER_TURBOGRAFX
          JOYSTICK_DRIVER_IFSEGA_ISA
          JOYSTICK_DRIVER_IFSEGA_PCI
          JOYSTICK_DRIVER_IFSEGA_PCI_FAST

     The standard driver includes support for the dual joysticks,
     increased numbers of buttons, Flightstick Pro, and Wingman Extreme,
     because these are all quite minor variations on the basic code.
   * If you are _really_ serious about this size, thing, have a look at
     the top of include/allegro/alconfig.h and you will see the lines:

          #define ALLEGRO_COLOR8
          #define ALLEGRO_COLOR16
          #define ALLEGRO_COLOR24
          #define ALLEGRO_COLOR32

     If you comment out any of these definitions and then rebuild the
     library, you will get a version without any support for the absent
     color depths, which will be even smaller than using the
     DECLARE_COLOR_DEPTH_LIST() macro.  Removing the ALLEGRO_COLOR16
     define will get rid of the support for both 15 and 16-bit hicolor
     modes, since these share a lot of the same code.

Note: the aforementioned methods for removing unused hardware drivers
only apply to statically linked versions of the library, eg.  DOS. On
Windows and Unix platforms, you can build Allegro as a DLL or shared
library, which prevents these methods from working, but saves so much
space that you probably won't care about that.  Removing unused color
depths from alconfig.h will work on any platform, though.

If you are distributing a copy of the setup program along with your
game, you may be able to get a dramatic size reduction by merging the
setup code into your main program, so that only one copy of the Allegro
routines will need to be linked.  See setup.txt for details.  In the
DJGPP version, after compressing the executable, this will probably save
you about 200k compared to having two separate programs for the setup
and the game itself.


File: allegro.info,  Node: Debugging,  Next: Available,  Prev: Reducing,  Up: Miscellaneous

3.2 Debugging
=============

There are three versions of the Allegro library: the normal optimised
code, one with extra debugging support, and a profiling version.  See
the platform specific readme files for information about how to install
and link with these alternative libs.  Although you will obviously want
to use the optimised library for the final version of your program, it
can be very useful to link with the debug lib while you are working on
it, because this will make debugging much easier, and includes assert
tests that will help to locate errors in your code at an earlier stage.
Allegro also contains some debugging helper functions:

* Menu:

* ASSERT::
* TRACE::
* register_assert_handler::
* register_trace_handler::
* al_assert::
* al_trace::


File: allegro.info,  Node: ASSERT,  Next: TRACE,  Prev: MIDI_*/MacOSX,  Up: Debugging

3.2.1 ASSERT
------------

void ASSERT(condition);
     Debugging helper macro.  Normally compiles away to nothing, but if
     you defined the preprocessor symbol DEBUGMODE before including
     Allegro headers, it will check the supplied condition and call
     al_assert() if it fails, whose default action is to stop the
     program and report the assert.  You can use this macro even when
     Allegro has not been initialised.  Example:

          #define DEBUGMODE
          #include
          ...
          void my_blitter(BITMAP *source, int flags)
          {
             int some_variables;
             ASSERT(source != NULL);
             ASSERT(flags & GAME_RUNNING);
             ...
          }

See also:
*Note al_assert::.
*Note TRACE::.
*Note register_assert_handler::.
*Note expackf::.


File: allegro.info,  Node: TRACE,  Next: register_assert_handler,  Prev: ASSERT,  Up: Debugging

3.2.2 TRACE
-----------

void TRACE(char *msg, ...);
     Debugging helper macro.  Normally compiles away to nothing, but if
     you defined the preprocessor symbol DEBUGMODE before including
     Allegro headers, it passes the supplied message given in ASCII
     format to al_trace().  Example:

          #define DEBUGMODE
          #include
          ...
          void my_blitter(BITMAP *source, int flags)
          {
             static int count_call = 0;
             TRACE("my_blitter() called %d times.\n", count_call++);
             ...
          }

See also:
*Note al_trace::.
*Note ASSERT::.
*Note register_trace_handler::.


File: allegro.info,  Node: register_assert_handler,  Next: register_trace_handler,  Prev: TRACE,  Up: Debugging

3.2.3 register_assert_handler
-----------------------------

void register_assert_handler(int (*handler)(const char *msg));
     Supplies a custom handler function for dealing with assert
     failures.  Your callback will be passed a formatted error message
     in ASCII, and should return non-zero if it has processed the error,
     or zero to continue with the default actions.  You could use this
     to ignore assert failures, or to display the error messages on a
     graphics mode screen without aborting the program.  You can call
     this function even when Allegro has not been initialised.  Example:

          int show_but_continue(const char *text)
          {
              alert("Uh oh...", "Fasten your seat belts.", text,
                    "&Go on!", NULL, 'g', 0);
              return 1;
          }
          ...
             register_assert(show_but_continue);
             ASSERT(0); /* This won't crash the program now. */

See also:
*Note al_assert::.
*Note ASSERT::.
*Note register_trace_handler::.


File: allegro.info,  Node: register_trace_handler,  Next: al_assert,  Prev: register_assert_handler,  Up: Debugging

3.2.4 register_trace_handler
----------------------------

void register_trace_handler(int (*handler)(const char *msg));
     Supplies a custom handler function for dealing with trace output.
     Your callback will be passed a formatted error message in ASCII,
     and should return non-zero if it has processed the message, or zero
     to continue with the default actions.  You could use this to ignore
     trace output, or to display the messages on a second monochrome
     monitor, etc.  You can call this function even when Allegro has not
     been initialised.  Example:

          int network_broadcaster(const char *text)
          {
             int f;

             for (int f = 0; f
                send_msg_to_client(client[f], text);

             return 0; /* Let normal tracing occur. */
          }
          ...
             register_trace_handler(network_broadcaster);
             TRACE("Networked tracing activated\n");

See also:
*Note al_trace::.
*Note TRACE::.
*Note register_assert_handler::.


File: allegro.info,  Node: al_assert,  Next: al_trace,  Prev: register_trace_handler,  Up: Debugging

3.2.5 al_assert
---------------

void al_assert(const char *file, int line);
     Raises an assert for an error at the specified file and line
     number.  The file parameter is always given in ASCII format.  By
     default, this will call the system driver's assert handler.  If
     there is none, the error will be sent to stderr and the program
     will abort.  However, if the environment variable ALLEGRO_ASSERT is
     set, this function writes a message into the file specified by the
     environment variable and program execution will continue.  If none
     of this behaviours is wanted, you can override them with a custom
     assert handler.

     You will usually want to use the ASSERT() macro instead of calling
     this function directly.

See also:
*Note ASSERT::.
*Note al_trace::.
*Note register_assert_handler::.


File: allegro.info,  Node: al_trace,  Next: exhello,  Prev: al_assert,  Up: Debugging

3.2.6 al_trace
--------------

void al_trace(const char *msg, ...);
     Outputs a debugging trace message, using a printf() format string
     given in ASCII. If you have installed a custom trace handler it
     uses that, or if the environment variable ALLEGRO_TRACE is set it
     writes into the file specified by the environment, otherwise it
     writes the message to "allegro.log" in the current directory.  You
     will usually want to use the TRACE() macro instead of calling this
     function directly.

See also:
*Note TRACE::.
*Note al_assert::.
*Note register_trace_handler::.


File: allegro.info,  Node: Available,  Next: Tools,  Prev: Debugging,  Up: Miscellaneous

3.3 Available Allegro examples
==============================

With Allegro comes quite a bunch of examples, which go from the simple
introductory 'Hello world' to more complicated programs featuring
truecolor blending effects.  This chapter describes these examples which
you can find in the allegro/examples folder.  You don't have to go
through them in the same order as this documentation, but doing so you
will learn the basic functions and avoid missing any important bit of
information.

* Menu:

* exhello::
* exmem::
* expal::
* expat::
* exflame::
* exdbuf::
* exflip::
* exfixed::
* exfont::
* exmouse::
* extimer::
* exkeys::
* exjoy::
* exsample::
* exmidi::
* exgui::
* excustom::
* exunicod::
* exbitmap::
* exscale::
* exconfig::
* exdata::
* exsprite::
* exrotscl::
* exexedat::
* extrans::
* extrans2::
* extruec::
* excolmap::
* exrgbhsv::
* exshade::
* exblend::
* exxfade::
* exalpha::
* exlights::
* ex3d::
* excamera::
* exquat::
* exstars::
* exscn3d::
* exzbuf::
* exscroll::
* ex3buf::
* ex12bit::
* exaccel::
* exspline::
* exsyscur::
* exupdate::
* exswitch::
* exstream::
* expackf::


File: allegro.info,  Node: exhello,  Next: exmem,  Prev: al_trace,  Up: Available

3.3.1 exhello
-------------

Example exhello
     This is a very simple program showing how to get into graphics mode
     and draw text onto the screen.

See also:
*Note END_OF_MAIN::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note acquire_screen::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note clear_to_color::.
*Note desktop_palette::.
*Note font::.
*Note install_keyboard::.
*Note key::.
*Note makecol::.
*Note readkey::.
*Note release_screen::.
*Note screen::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note textout_centre_ex::.


File: allegro.info,  Node: exmem,  Next: expal,  Prev: exhello,  Up: Available

3.3.2 exmem
-----------

Example exmem
     This program demonstrates the use of memory bitmaps.  It creates a
     small temporary bitmap in memory, draws some circles onto it, and
     then blits lots of copies of it onto the screen.

See also:
*Note BITMAP::.
*Note END_OF_MAIN::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note acquire_screen::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note blit::.
*Note circle::.
*Note clear_bitmap::.
*Note create_bitmap::.
*Note desktop_palette::.
*Note destroy_bitmap::.
*Note install_keyboard::.
*Note palette_color::.
*Note readkey::.
*Note release_screen::.
*Note screen::.
*Note set_gfx_mode::.
*Note set_palette::.


File: allegro.info,  Node: expal,  Next: expat,  Prev: exmem,  Up: Available

3.3.3 expal
-----------

Example expal
     This program demonstrates how to manipulate the palette.  It draws
     a set of concentric circles onto the screen and animates them by
     cycling the palette.

See also:
*Note END_OF_MAIN::.
*Note PALETTE::.
*Note RGB::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note acquire_screen::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note black_palette::.
*Note circlefill::.
*Note install_keyboard::.
*Note install_mouse::.
*Note keypressed::.
*Note release_screen::.
*Note screen::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note show_mouse::.


File: allegro.info,  Node: expat,  Next: exflame,  Prev: expal,  Up: Available

3.3.4 expat
-----------

Example expat
     This program demonstrates the use of patterned drawing and
     sub-bitmaps.

See also:
*Note BITMAP::.
*Note END_OF_MAIN::.
*Note acquire_bitmap::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note bitmap_mask_color::.
*Note blit::.
*Note clear_to_color::.
*Note create_bitmap::.
*Note create_sub_bitmap::.
*Note desktop_palette::.
*Note destroy_bitmap::.
*Note drawing_mode::.
*Note font::.
*Note install_keyboard::.
*Note makecol::.
*Note masked_blit::.
*Note palette_color::.
*Note readkey::.
*Note rectfill::.
*Note release_bitmap::.
*Note screen::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note solid_mode::.
*Note text_height::.
*Note text_length::.
*Note textout_ex::.


File: allegro.info,  Node: exflame,  Next: exdbuf,  Prev: expat,  Up: Available

3.3.5 exflame
-------------

Example exflame
     This program demonstrates how to write directly to video memory.
     It implements a simple fire effect, first by calling getpixel() and
     putpixel(), then by accessing video memory directly a byte at a
     time, and finally using block memory copy operations.

See also:
*Note END_OF_MAIN::.
*Note PALETTE::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note acquire_screen::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note bmp_read_line::.
*Note bmp_unwrite_line::.
*Note bmp_write_line::.
*Note clear_keybuf::.
*Note font::.
*Note getpixel::.
*Note install_keyboard::.
*Note keypressed::.
*Note line::.
*Note makecol::.
*Note putpixel::.
*Note release_screen::.
*Note rest::.
*Note screen::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note textout_ex::.


File: allegro.info,  Node: exdbuf,  Next: exflip,  Prev: exflame,  Up: Available

3.3.6 exdbuf
------------

Example exdbuf
     This program demonstrates the use of double buffering.  It moves a
     circle across the screen, first just erasing and redrawing directly
     to the screen, then with a double buffer.

See also:
*Note BITMAP::.
*Note END_OF_MAIN::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note acquire_screen::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note blit::.
*Note circlefill::.
*Note clear_keybuf::.
*Note clear_to_color::.
*Note create_bitmap::.
*Note desktop_palette::.
*Note destroy_bitmap::.
*Note font::.
*Note install_keyboard::.
*Note install_timer::.
*Note keypressed::.
*Note makecol::.
*Note release_screen::.
*Note retrace_count::.
*Note screen::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note textprintf_ex::.


File: allegro.info,  Node: exflip,  Next: exfixed,  Prev: exdbuf,  Up: Available

3.3.7 exflip
------------

Example exflip
     This program moves a circle across the screen, first with a double
     buffer and then using page flips.

See also:
*Note BITMAP::.
*Note END_OF_MAIN::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note blit::.
*Note circlefill::.
*Note clear_keybuf::.
*Note clear_to_color::.
*Note create_bitmap::.
*Note create_video_bitmap::.
*Note desktop_palette::.
*Note destroy_bitmap::.
*Note font::.
*Note install_keyboard::.
*Note install_timer::.
*Note keypressed::.
*Note makecol::.
*Note retrace_count::.
*Note screen::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note show_video_bitmap::.
*Note textprintf_ex::.


File: allegro.info,  Node: exfixed,  Next: exfont,  Prev: exflip,  Up: Available

3.3.8 exfixed
-------------

Example exfixed
     This program demonstrates how to use fixed point numbers, which are
     signed 32-bit integers storing the integer part in the upper 16
     bits and the decimal part in the 16 lower bits.  This example also
     uses the unusual approach of communicating with the user
     exclusively via the allegro_message() function.

See also:
*Note END_OF_MAIN::.
*Note allegro_init::.
*Note allegro_message::.
*Note fixdiv::.
*Note fixed::.
*Note fixmul::.
*Note fixsqrt::.
*Note fixtof::.
*Note ftofix::.
*Note itofix::.


File: allegro.info,  Node: exfont,  Next: exmouse,  Prev: exfixed,  Up: Available

3.3.9 exfont
------------

Example exfont
     This is a very simple program showing how to load and manipulate
     fonts.

See also:
*Note END_OF_MAIN::.
*Note FONT::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note acquire_screen::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note clear_to_color::.
*Note desktop_palette::.
*Note destroy_font::.
*Note extract_font_range::.
*Note font::.
*Note install_keyboard::.
*Note key::.
*Note load_font::.
*Note makecol::.
*Note merge_fonts::.
*Note readkey::.
*Note release_screen::.
*Note screen::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note textout_centre_ex::.


File: allegro.info,  Node: exmouse,  Next: extimer,  Prev: exfont,  Up: Available

3.3.10 exmouse
--------------

Example exmouse
     This program demonstrates how to get mouse input.  The first part
     of the test retrieves the raw mouse input data and displays it on
     the screen without using any mouse cursor.  When you press a key
     the standard arrow-like mouse cursor appears.  You are not
     restricted to this shape, and a second key press modifies the
     cursor to be several concentric colored circles.  They are not
     joined together, so you can still see bits of what's behind when
     you move the cursor over the printed text message.

See also:
*Note BITMAP::.
*Note END_OF_MAIN::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note acquire_screen::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note bitmap_mask_color::.
*Note circle::.
*Note clear_keybuf::.
*Note clear_to_color::.
*Note create_bitmap::.
*Note desktop_palette::.
*Note destroy_bitmap::.
*Note font::.
*Note get_mouse_mickeys::.
*Note install_keyboard::.
*Note install_mouse::.
*Note install_timer::.
*Note key::.
*Note keypressed::.
*Note makecol::.
*Note mouse_b: mouse_x.
*Note mouse_w: mouse_x.
*Note mouse_x::.
*Note mouse_y: mouse_x.
*Note mouse_z: mouse_x.
*Note palette_color::.
*Note poll_mouse::.
*Note readkey::.
*Note release_screen::.
*Note screen::.
*Note set_gfx_mode::.
*Note set_mouse_sprite::.
*Note set_mouse_sprite_focus::.
*Note set_palette::.
*Note show_mouse::.
*Note textout_centre_ex::.
*Note textout_ex::.
*Note textprintf_centre_ex::.
*Note textprintf_ex::.
*Note textprintf_right_ex::.
*Note vsync::.


File: allegro.info,  Node: extimer,  Next: exkeys,  Prev: exmouse,  Up: Available

3.3.11 extimer
--------------

Example extimer
     This program demonstrates how to use the timer routines.  These can
     be a bit of a pain, because you have to be sure you lock all the
     memory that is used inside your interrupt handlers.  The first part
     of the example shows a basic use of timing using the blocking
     function rest().  The second part shows how to use three timers
     with different frequencies in a non blocking way.

See also:
*Note END_OF_FUNCTION::.
*Note END_OF_MAIN::.
*Note LOCK_FUNCTION::.
*Note LOCK_VARIABLE::.
*Note SCREEN_W::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note clear_to_color::.
*Note desktop_palette::.
*Note font::.
*Note install_int::.
*Note install_int_ex::.
*Note install_keyboard::.
*Note install_timer::.
*Note key::.
*Note keypressed::.
*Note makecol::.
*Note readkey::.
*Note rest::.
*Note screen::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note textprintf_centre_ex::.


File: allegro.info,  Node: exkeys,  Next: exjoy,  Prev: extimer,  Up: Available

3.3.12 exkeys
-------------

Example exkeys
     This program demonstrates how to access the keyboard.  The first
     part shows the basic use of readkey().  The second part shows how
     to extract the ASCII value.  Next come the scan codes.  The fourth
     test detects modifier keys like alt or shift.  The fifth test
     requires some focus to be passed.  The final step shows how to use
     the global key array to read simultaneous key presses.  The last
     method to detect key presses are keyboard callbacks.  This is
     demonstrated by installing a keyboard callback, which marks all
     pressed keys by drawing to a grid.

See also:
*Note END_OF_FUNCTION::.
*Note END_OF_MAIN::.
*Note LOCK_FUNCTION::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note acquire_screen::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note blit::.
*Note clear_keybuf::.
*Note clear_to_color::.
*Note desktop_palette::.
*Note font::.
*Note install_keyboard::.
*Note install_timer::.
*Note key::.
*Note key_shifts::.
*Note keyboard_lowlevel_callback::.
*Note keypressed::.
*Note makecol::.
*Note readkey::.
*Note rectfill::.
*Note release_screen::.
*Note rest::.
*Note scancode_to_name::.
*Note screen::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note textout_ex::.
*Note textprintf_centre_ex::.
*Note textprintf_ex::.
*Note ureadkey::.
*Note usprintf::.
*Note ustrzncpy::.


File: allegro.info,  Node: exjoy,  Next: exsample,  Prev: exkeys,  Up: Available

3.3.13 exjoy
------------

Example exjoy
     This program uses the Allegro library to detect and read the value
     of a joystick.  The output of the program is a small target sight
     on the screen which you can move.  At the same time the program
     will tell you what you are doing with the joystick (moving or
     firing).

See also:
*Note BITMAP::.
*Note END_OF_MAIN::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note blit::.
*Note calibrate_joystick::.
*Note calibrate_joystick_name::.
*Note circle::.
*Note clear_bitmap::.
*Note clear_keybuf::.
*Note create_bitmap::.
*Note default_palette::.
*Note destroy_bitmap::.
*Note drawing_mode::.
*Note font::.
*Note install_joystick::.
*Note install_keyboard::.
*Note joy::.
*Note key::.
*Note keypressed::.
*Note num_joysticks::.
*Note palette_color::.
*Note poll_joystick::.
*Note putpixel::.
*Note readkey::.
*Note screen::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note textout_centre_ex::.
*Note textprintf_centre_ex::.
*Note textprintf_ex::.


File: allegro.info,  Node: exsample,  Next: exmidi,  Prev: exjoy,  Up: Available

3.3.14 exsample
---------------

Example exsample
     This program demonstrates how to play samples.  You have to use
     this example from the command line to specify as first parameter a
     WAV or VOC sound file to play.  If the file is loaded successfully,
     the sound will be played in an infinite loop.  While it is being
     played, you can use the left and right arrow keys to modify the
     panning of the sound.  You can also use the up and down arrow keys
     to modify the pitch.

See also:
*Note END_OF_MAIN::.
*Note SAMPLE::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note adjust_sample::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note clear_to_color::.
*Note desktop_palette::.
*Note destroy_sample::.
*Note font::.
*Note install_keyboard::.
*Note install_sound::.
*Note install_timer::.
*Note key::.
*Note load_sample::.
*Note makecol::.
*Note play_sample::.
*Note poll_keyboard::.
*Note rest::.
*Note screen::.
*Note set_display_switch_mode::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note textprintf_centre_ex::.


File: allegro.info,  Node: exmidi,  Next: exgui,  Prev: exsample,  Up: Available

3.3.15 exmidi
-------------

Example exmidi
     This program demonstrates how to play MIDI files.

See also:
*Note END_OF_MAIN::.
*Note MIDI::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note clear_to_color::.
*Note desktop_palette::.
*Note destroy_midi::.
*Note font::.
*Note get_filename::.
*Note get_midi_length::.
*Note install_keyboard::.
*Note install_sound::.
*Note install_timer::.
*Note key::.
*Note keypressed::.
*Note load_midi::.
*Note makecol::.
*Note midi_pause::.
*Note midi_pos::.
*Note midi_resume::.
*Note midi_time::.
*Note play_midi::.
*Note readkey::.
*Note rectfill::.
*Note rest::.
*Note screen::.
*Note set_display_switch_mode::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note text_height::.
*Note text_length::.
*Note textprintf_centre_ex::.


File: allegro.info,  Node: exgui,  Next: excustom,  Prev: exmidi,  Up: Available

3.3.16 exgui
------------

Example exgui
     This program demonstrates how to use the GUI routines.  From the
     simple dialog controls that display a text or a bitmap to more
     complex multiple choice selection lists, Allegro provides a
     framework which can be customised to suit your needs.

See also:
*Note DATAFILE::.
*Note DIALOG::.
*Note END_OF_MAIN::.
*Note MENU::.
*Note active_menu::.
*Note alert::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note d_bitmap_proc::.
*Note d_box_proc::.
*Note d_button_proc::.
*Note d_check_proc::.
*Note d_clear_proc::.
*Note d_ctext_proc: d_text_proc.
*Note d_edit_proc::.
*Note d_icon_proc::.
*Note d_keyboard_proc::.
*Note d_list_proc::.
*Note d_menu_proc::.
*Note d_radio_proc::.
*Note d_rtext_proc: d_text_proc.
*Note d_shadow_box_proc: d_box_proc.
*Note d_slider_proc::.
*Note d_text_list_proc::.
*Note d_text_proc::.
*Note d_textbox_proc::.
*Note d_yield_proc::.
*Note do_dialog::.
*Note gui_bg_color: gui_fg_color.
*Note gui_fg_color::.
*Note gui_mg_color::.
*Note install_keyboard::.
*Note install_mouse::.
*Note install_timer::.
*Note key::.
*Note load_datafile::.
*Note makecol::.
*Note position_dialog::.
*Note replace_filename::.
*Note screen::.
*Note set_dialog_color::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note unload_datafile::.
*Note ustrtok::.
*Note ustrzcat::.
*Note ustrzcpy::.
*Note uszprintf::.


File: allegro.info,  Node: excustom,  Next: exunicod,  Prev: exgui,  Up: Available

3.3.17 excustom
---------------

Example excustom
     A follow up of the exgui.c example showing how to customise the
     default Allegro framework.  In this case a dialog procedure
     animates a graphical clock without disrupting other GUI dialogs.  A
     more simple option shows how to dynamically change the font used by
     all GUI elements.

See also:
*Note BITMAP::.
*Note DATAFILE::.
*Note DIALOG::.
*Note END_OF_MAIN::.
*Note FONT::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note blit::.
*Note circle::.
*Note circlefill::.
*Note clear_to_color::.
*Note create_bitmap::.
*Note d_button_proc::.
*Note d_check_proc::.
*Note d_clear_proc::.
*Note d_edit_proc::.
*Note desktop_palette::.
*Note destroy_bitmap::.
*Note do_dialog::.
*Note fixcos::.
*Note fixed::.
*Note fixmul::.
*Note fixsin::.
*Note fixtoi::.
*Note font::.
*Note install_keyboard::.
*Note install_mouse::.
*Note install_timer::.
*Note itofix::.
*Note key::.
*Note line::.
*Note load_datafile::.
*Note makecol::.
*Note object_message::.
*Note replace_filename::.
*Note screen::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note unload_datafile::.


File: allegro.info,  Node: exunicod,  Next: exbitmap,  Prev: excustom,  Up: Available

3.3.18 exunicod
---------------

Example exunicod
     This program demonstrates the use of the 16-bit Unicode text
     encoding format with Allegro.  The example displays a message
     translated to different languages scrolling on the screen using an
     external font containing the required characters to display those
     messages.

     Note how the Allegro unicode string functions resemble the
     functions you can find in the standard C library, only these handle
     Unicode on all platforms.

See also:
*Note BITMAP::.
*Note DATAFILE::.
*Note END_OF_MAIN::.
*Note FONT::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note blit::.
*Note clear_to_color::.
*Note create_bitmap::.
*Note destroy_bitmap::.
*Note font::.
*Note install_int_ex::.
*Note install_keyboard::.
*Note install_timer::.
*Note keypressed::.
*Note load_datafile::.
*Note replace_filename::.
*Note rest::.
*Note screen::.
*Note set_gfx_mode::.
*Note set_uformat::.
*Note set_window_title::.
*Note text_height::.
*Note text_length::.
*Note textout_ex::.
*Note uconvert_ascii::.
*Note unload_datafile::.
*Note ustrcat::.
*Note ustrcpy::.
*Note ustrsize::.
*Note ustrsizez::.


File: allegro.info,  Node: exbitmap,  Next: exscale,  Prev: exunicod,  Up: Available

3.3.19 exbitmap
---------------

Example exbitmap
     This program demonstrates how to load and display a bitmap file.
     You have to use this example from the command line to specify as
     first parameter a graphic file in one of Allegro's supported
     formats.  If the file is loaded successfully, it will be displayed
     until you press a key.

See also:
*Note BITMAP::.
*Note END_OF_MAIN::.
*Note PALETTE::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note blit::.
*Note destroy_bitmap::.
*Note install_keyboard::.
*Note load_bitmap::.
*Note readkey::.
*Note screen::.
*Note set_gfx_mode::.
*Note set_palette::.


File: allegro.info,  Node: exscale,  Next: exconfig,  Prev: exbitmap,  Up: Available

3.3.20 exscale
--------------

Example exscale
     This example demonstrates how to use PCX files, palettes and
     stretch blits.  It loads a PCX file, sets its palette and does some
     random stretch_blits.  Don't worry - it's VERY slowed down using
     vsync().

See also:
*Note BITMAP::.
*Note END_OF_MAIN::.
*Note PALETTE::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note blit::.
*Note destroy_bitmap::.
*Note install_keyboard::.
*Note keypressed::.
*Note load_pcx::.
*Note replace_filename::.
*Note screen::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note stretch_blit::.
*Note vsync::.


File: allegro.info,  Node: exconfig,  Next: exdata,  Prev: exscale,  Up: Available

3.3.21 exconfig
---------------

Example exconfig
     This is a very simple program showing how to use the Allegro
     configuration (ini file) routines.  A first look at the example
     shows nothing more than a static graphic and the wait for a key
     press.  However, the way this graphic is displayed is configured
     through a custom exconfig.ini file which is loaded manually.  From
     this file the example obtains parameters like fullscreen/windowed
     mode, a specific graphic resolution to set up, which graphic to
     show, how to blit it on the screen, etc.

See also:
*Note BITMAP::.
*Note END_OF_MAIN::.
*Note RGB::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note allegro_init::.
*Note allegro_message::.
*Note blit::.
*Note clear_bitmap::.
*Note destroy_bitmap::.
*Note font::.
*Note get_config_argv::.
*Note get_config_int::.
*Note get_config_string::.
*Note install_keyboard::.
*Note line::.
*Note load_bitmap::.
*Note makecol::.
*Note pop_config_state::.
*Note push_config_state::.
*Note readkey::.
*Note screen::.
*Note set_color_depth::.
*Note set_config_file::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note stretch_blit::.
*Note textout_centre_ex::.
*Note textprintf_centre_ex::.
*Note ustrdup::.
*Note ustricmp::.


File: allegro.info,  Node: exdata,  Next: exsprite,  Prev: exconfig,  Up: Available

3.3.22 exdata
-------------

Example exdata
     This program demonstrates how to access the contents of an Allegro
     datafile (created by the grabber utility).  The example loads the
     file 'example.dat', then blits a bitmap and shows a font, both from
     this datafile.

See also:
*Note DATAFILE::.
*Note END_OF_MAIN::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note blit::.
*Note font::.
*Note install_keyboard::.
*Note load_datafile::.
*Note makecol::.
*Note readkey::.
*Note replace_filename::.
*Note screen::.
*Note set_color_conversion::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note textout_ex::.
*Note unload_datafile::.


File: allegro.info,  Node: exsprite,  Next: exrotscl,  Prev: exdata,  Up: Available

3.3.23 exsprite
---------------

Example exsprite
     This example demonstrates how to use datafiles, various sprite
     drawing routines and flicker-free animation.

     Why is the animate() routine coded in that way?  As you probably
     know, VIDEO RAM is much slower than "normal" RAM, so it's advisable
     to reduce VRAM blits to a minimum.  Drawing sprite on the screen
     (meaning in VRAM) and then clearing a background for it is not very
     fast.  This example uses a different method which is much faster,
     but require a bit more memory.

     First the buffer is cleared (it's a normal BITMAP), then the sprite
     is drawn on it, and when the drawing is finished this buffer is
     copied directly to the screen.  So the end result is that there is
     a single VRAM blit instead of blitting/clearing the background and
     drawing a sprite on it.  It's a good method even when you have to
     restore the background.  And of course, it completely removes any
     flickering effect.

     When one uses a big (ie.  800x600 background) and draws something
     on it, it's wise to use a copy of background somewhere in memory
     and restore background using this "virtual background".  When
     blitting from VRAM in SVGA modes, it's probably, that drawing
     routines have to switch banks on video card.  I think, I don't have
     to remind how slow is it.

     Note that on modern systems, the above isn't true anymore, and you
     usually get the best performance by caching all your animations in
     video ram and doing only VRAM->VRAM blits, so there is no more
     RAM->VRAM transfer at all anymore.  And usually, such transfers can
     run in parallel on the graphics card's processor as well, costing
     virtually no main cpu time at all.  See the exaccel example for an
     example of this.

See also:
*Note BITMAP::.
*Note DATAFILE::.
*Note END_OF_FUNCTION::.
*Note END_OF_MAIN::.
*Note LOCK_FUNCTION::.
*Note LOCK_VARIABLE::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note blit::.
*Note circle::.
*Note clear_bitmap::.
*Note clear_keybuf::.
*Note create_bitmap::.
*Note destroy_bitmap::.
*Note draw_sprite::.
*Note draw_sprite_h_flip: draw_sprite_v_flip.
*Note draw_sprite_v_flip::.
*Note draw_sprite_vh_flip: draw_sprite_v_flip.
*Note fixed::.
*Note font::.
*Note hline::.
*Note install_int_ex::.
*Note install_keyboard::.
*Note install_sound::.
*Note install_timer::.
*Note itofix::.
*Note key::.
*Note keypressed::.
*Note load_datafile::.
*Note makecol::.
*Note palette_color::.
*Note pivot_sprite::.
*Note pivot_sprite_v_flip::.
*Note play_sample::.
*Note rectfill::.
*Note replace_filename::.
*Note rest::.
*Note screen::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note text_height::.
*Note textout_centre_ex::.
*Note unload_datafile::.
*Note vsync::.


File: allegro.info,  Node: exrotscl,  Next: exexedat,  Prev: exsprite,  Up: Available

3.3.24 exrotscl
---------------

Example exrotscl
     This example demonstrates rotate_scaled_sprite functions.

See also:
*Note BITMAP::.
*Note END_OF_MAIN::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note allegro_init::.
*Note allegro_message::.
*Note blit::.
*Note clear_to_color::.
*Note create_bitmap::.
*Note destroy_bitmap::.
*Note draw_trans_sprite::.
*Note fixed::.
*Note font::.
*Note ftofix::.
*Note install_keyboard::.
*Note key::.
*Note keypressed::.
*Note load_bitmap::.
*Note makeacol::.
*Note makecol::.
*Note readkey::.
*Note rest::.
*Note rotate_scaled_sprite::.
*Note rotate_scaled_sprite_lit::.
*Note rotate_scaled_sprite_trans::.
*Note screen::.
*Note set_alpha_blender::.
*Note set_color_conversion::.
*Note set_color_depth::.
*Note set_gfx_mode::.
*Note set_trans_blender::.
*Note textout_centre_ex::.


File: allegro.info,  Node: exexedat,  Next: extrans,  Prev: exrotscl,  Up: Available

3.3.25 exexedat
---------------

Example exexedat
     This program demonstrates how to access the contents of an Allegro
     datafile (created by the grabber utility) linked to the executable
     by the exedat tool.  It is basically the exdata example with minor
     modifications.

     You may ask: how do you compile, append and exec your program?

     Answer: like this...

     1) Compile your program like normal.  Use the magic filenames with
     '#' to load your data where needed.

     2) Once you compressed your program, run "exedat foo.exe data.dat"

     3) Finally run your program.

     Note that appending data to the end of binaries may not be portable
     across all platforms supported by Allegro.

See also:
*Note DATAFILE::.
*Note END_OF_MAIN::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note blit::.
*Note font::.
*Note install_keyboard::.
*Note line::.
*Note load_datafile::.
*Note makecol::.
*Note readkey::.
*Note screen::.
*Note set_color_conversion::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note textout_ex::.
*Note unload_datafile::.


File: allegro.info,  Node: extrans,  Next: extrans2,  Prev: exexedat,  Up: Available

3.3.26 extrans
--------------

Example extrans
     This program demonstrates how to use the lighting and translucency
     functions.  The first part of the example will show a dark screen
     illuminated by a spotlight you can move with your mouse.  After a
     key press the example shows the full bitmap and the spotlight
     changes to be a reduced version of the background with 50% of
     translucency.

     The translucency effect is easy to do in all color depths.
     However, the lighting effect has to be performed in a different way
     depending on whether the screen is in 8bit mode or another color
     depth.  This is because additive drawing mode uses a different set
     of routines for truecolor modes.

See also:
*Note BITMAP::.
*Note COLOR_MAP::.
*Note END_OF_MAIN::.
*Note PALETTE::.
*Note RGB::.
*Note RGB_MAP::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note bitmap_color_depth::.
*Note blit::.
*Note circlefill::.
*Note clear_bitmap::.
*Note clear_keybuf::.
*Note color_map::.
*Note create_bitmap::.
*Note create_bitmap_ex::.
*Note create_light_table::.
*Note create_rgb_table::.
*Note create_trans_table::.
*Note destroy_bitmap::.
*Note draw_trans_sprite::.
*Note drawing_mode::.
*Note install_keyboard::.
*Note install_mouse::.
*Note install_timer::.
*Note keypressed::.
*Note load_bitmap::.
*Note mouse_x::.
*Note mouse_y: mouse_x.
*Note poll_mouse::.
*Note rectfill::.
*Note replace_filename::.
*Note rest::.
*Note rgb_map::.
*Note screen::.
*Note set_alpha_blender::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note set_trans_blender::.
*Note set_write_alpha_blender::.
*Note stretch_blit::.


File: allegro.info,  Node: extrans2,  Next: extruec,  Prev: extrans,  Up: Available

3.3.27 extrans2
---------------

Example extrans2
     This program demonstrates how to draw trans and lit sprites and
     flip them at the same time, using draw_sprite_ex() function.  It
     displays several images moving around using different drawing modes
     while you can press space key to change the flipping orientation.

See also:
*Note BITMAP::.
*Note END_OF_MAIN::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note blit::.
*Note clear_bitmap::.
*Note create_bitmap::.
*Note destroy_bitmap::.
*Note draw_sprite_ex::.
*Note font::.
*Note install_keyboard::.
*Note install_timer::.
*Note key::.
*Note load_bitmap::.
*Note makecol::.
*Note replace_filename::.
*Note rest::.
*Note screen::.
*Note set_color_depth::.
*Note set_gfx_mode::.
*Note set_trans_blender::.
*Note stretch_blit::.
*Note textout_ex::.


File: allegro.info,  Node: extruec,  Next: excolmap,  Prev: extrans2,  Up: Available

3.3.28 extruec
--------------

Example extruec
     This program shows how to specify colors in the various different
     truecolor pixel formats.  The example shows the same screen (a few
     text lines and three coloured gradients) in all the color depth
     modes supported by your video card.  The more color depth you have,
     the less banding you will see in the gradients.

See also:
*Note END_OF_MAIN::.
*Note PALETTE::.
*Note RGB::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note acquire_screen::.
*Note allegro_init::.
*Note clear_to_color::.
*Note font::.
*Note generate_332_palette::.
*Note install_keyboard::.
*Note key::.
*Note makecol::.
*Note readkey::.
*Note release_screen::.
*Note screen::.
*Note set_color_depth::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note textout_centre_ex::.
*Note textout_ex::.
*Note textprintf_ex::.
*Note vline::.


File: allegro.info,  Node: excolmap,  Next: exrgbhsv,  Prev: extruec,  Up: Available

3.3.29 excolmap
---------------

Example excolmap
     This program demonstrates how to create custom graphic effects with
     the create_color_table function.  Allegro drawing routines are
     affected by any color table you might have set up.  In the first
     part of this example, a greyscale color table is set.  The result
     is that a simple rectfill call, instead of drawing a rectangle with
     color zero, uses the already drawn pixels to determine the pixel to
     be drawn (read the comment of return_grey_color() for a precise
     description of the algorithm).  In the second part of the test, the
     color table is changed to be an inverse table, meaning that any
     pixel drawn will be shown as its color values had been inverted.

See also:
*Note BITMAP::.
*Note COLOR_MAP::.
*Note END_OF_MAIN::.
*Note PALETTE::.
*Note RGB::.
*Note RGB_MAP::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note blit::.
*Note circlefill::.
*Note clear_keybuf::.
*Note color_map::.
*Note create_bitmap::.
*Note create_color_table::.
*Note create_rgb_table::.
*Note destroy_bitmap::.
*Note drawing_mode::.
*Note font::.
*Note generate_332_palette::.
*Note install_keyboard::.
*Note keypressed::.
*Note makecol::.
*Note rectfill::.
*Note rest::.
*Note rgb_map::.
*Note screen::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note textout_centre_ex::.
*Note vsync::.


File: allegro.info,  Node: exrgbhsv,  Next: exshade,  Prev: excolmap,  Up: Available

3.3.30 exrgbhsv
---------------

Example exrgbhsv
     This program shows how to convert colors between the different
     color-space representations.  The central area of the screen will
     display the current color.  On the top left corner of the screen,
     three sliders allow you to modify the red, green and blue value of
     the color.  On the bottom right corner of the screen, three sliders
     allow you to modify the hue, saturation and value of the color.
     The color bars beneath the sliders show what the resulting color
     will look like when the slider is dragged to that position.

     Additionally this example also shows how to "inherit" the behaviour
     of a GUI object and extend it, here used to create the sliders.

See also:
*Note BITMAP::.
*Note DIALOG::.
*Note END_OF_MAIN::.
*Note PALETTE::.
*Note RGB::.
*Note RGB_MAP::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note clear_to_color::.
*Note create_bitmap_ex::.
*Note create_rgb_table::.
*Note d_bitmap_proc::.
*Note d_box_proc::.
*Note d_slider_proc::.
*Note d_text_proc::.
*Note destroy_bitmap::.
*Note do_dialog::.
*Note font::.
*Note generate_332_palette::.
*Note get_color_depth::.
*Note hsv_to_rgb::.
*Note install_keyboard::.
*Note install_mouse::.
*Note install_timer::.
*Note key::.
*Note makecol::.
*Note makecol32: makecol8.
*Note makecol8::.
*Note object_message::.
*Note rgb_map::.
*Note rgb_to_hsv: hsv_to_rgb.
*Note screen::.
*Note set_color::.
*Note set_color_depth::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note textout_ex::.
*Note vline::.
*Note vsync::.


File: allegro.info,  Node: exshade,  Next: exblend,  Prev: exrgbhsv,  Up: Available

3.3.31 exshade
--------------

Example exshade
     This program demonstrates how to draw Gouraud shaded (lit) sprites.
     In an apparently black screen, a planet like sprite is drawn close
     to the middle of the screen.  In a similar way to how the first
     test of extrans works, you move the cursor on the screen with the
     mouse.  Attached to this mouse you can imagine a virtual spotlight
     illuminating the scene around.  Depending on where the mouse is,
     the Gouraud shaded sprite will show the direction of the light.

See also:
*Note BITMAP::.
*Note COLOR_MAP::.
*Note END_OF_MAIN::.
*Note PALETTE::.
*Note RGB::.
*Note RGB_MAP::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note blit::.
*Note clear_bitmap::.
*Note color_map::.
*Note create_bitmap::.
*Note create_light_table::.
*Note create_rgb_table::.
*Note destroy_bitmap::.
*Note draw_gouraud_sprite::.
*Note font::.
*Note install_keyboard::.
*Note install_mouse::.
*Note keypressed::.
*Note line::.
*Note load_bitmap::.
*Note mouse_x::.
*Note mouse_y: mouse_x.
*Note palette_color::.
*Note poll_mouse::.
*Note replace_filename::.
*Note rgb_map::.
*Note screen::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note set_trans_blender::.
*Note show_mouse::.
*Note textout_ex::.


File: allegro.info,  Node: exblend,  Next: exxfade,  Prev: exshade,  Up: Available

3.3.32 exblend
--------------

Example exblend
     This program demonstrates how to use the translucency functions in
     truecolor video modes.  Two image files are loaded from disk and
     displayed moving slowly around the screen.  One of the images will
     be tinted to different colors.  The other image will be faded out
     with a varying alpha strength, and drawn on top of the other image.

See also:
*Note BITMAP::.
*Note END_OF_MAIN::.
*Note PALETTE::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note blit::.
*Note circle::.
*Note clear_bitmap::.
*Note clear_keybuf::.
*Note create_bitmap::.
*Note destroy_bitmap::.
*Note draw_lit_sprite::.
*Note draw_trans_sprite::.
*Note fixcos::.
*Note fixsin::.
*Note fixtoi::.
*Note font::.
*Note install_keyboard::.
*Note install_timer::.
*Note itofix::.
*Note keypressed::.
*Note load_bitmap::.
*Note makecol::.
*Note replace_filename::.
*Note retrace_count::.
*Note screen::.
*Note set_color_conversion::.
*Note set_color_depth::.
*Note set_gfx_mode::.
*Note set_trans_blender::.
*Note textprintf_ex::.
*Note vsync::.


File: allegro.info,  Node: exxfade,  Next: exalpha,  Prev: exblend,  Up: Available

3.3.33 exxfade
--------------

Example exxfade
     This program demonstrates how to load and display bitmap files in
     truecolor video modes, and how to crossfade between them.  You have
     to use this example from the command line to specify as parameters
     a number of graphic files.  Use at least two files to see the
     graphical effect.  The example will crossfade from one image to
     another with each key press until you press the ESC key.

See also:
*Note BITMAP::.
*Note END_OF_MAIN::.
*Note PALETTE::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note allegro_error::.
*Note allegro_exit::.
*Note allegro_init::.
*Note allegro_message::.
*Note blit::.
*Note create_bitmap::.
*Note destroy_bitmap::.
*Note draw_trans_sprite::.
*Note install_keyboard::.
*Note keypressed::.
*Note line::.
*Note load_bitmap::.
*Note readkey::.
*Note rest::.
*Note screen::.
*Note set_color_conversion::.
*Note set_color_depth::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note set_trans_blender::.
*Note vsync::.


File: allegro.info,  Node: exalpha,  Next: exlights,  Prev: exxfade,  Up: Available

3.3.34 exalpha
--------------

Example exalpha
     This program demonstrates how to use the 32 bit RGBA translucency
     functions to store an alpha channel along with a bitmap graphic.
     Two images are loaded from disk.  One will be used for the
     background and the other as a sprite.  The example generates an
     alpha channel for the sprite image, composing the 32 bit RGBA
     bitmap during runtime, and draws it at the position of the mouse
     cursor.

See also:
*Note BITMAP::.
*Note END_OF_MAIN::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note blit::.
*Note clear_keybuf::.
*Note create_bitmap::.
*Note destroy_bitmap::.
*Note draw_trans_sprite::.
*Note drawing_mode::.
*Note font::.
*Note getb: getr.
*Note getg: getr.
*Note getpixel::.
*Note getr::.
*Note install_keyboard::.
*Note install_mouse::.
*Note install_timer::.
*Note keypressed::.
*Note load_bitmap::.
*Note makecol::.
*Note mouse_x::.
*Note mouse_y: mouse_x.
*Note putpixel::.
*Note rectfill::.
*Note replace_filename::.
*Note screen::.
*Note set_alpha_blender::.
*Note set_color_conversion::.
*Note set_color_depth::.
*Note set_gfx_mode::.
*Note set_multiply_blender::.
*Note set_write_alpha_blender::.
*Note solid_mode::.
*Note stretch_blit::.
*Note textprintf_ex::.


File: allegro.info,  Node: exlights,  Next: ex3d,  Prev: exalpha,  Up: Available

3.3.35 exlights
---------------

Example exlights
     This program shows one way to implement colored lighting effects in
     a hicolor video mode.  Warning: it is not for the faint of heart!
     This is by no means the simplest or easiest to understand method, I
     just thought it was a cool concept that would be worth
     demonstrating.

     The basic approach is to select a 15 or 16 bit screen mode, but
     then draw onto 24 bit memory bitmaps.  Since we only need the
     bottom 5 bits of each 8 bit color in order to store 15 bit data
     within a 24 bit location, we can fit a light level into the top 3
     bits.  The tricky bit is that these aren't actually 24 bit images
     at all: they are implemented as 8 bit memory bitmaps, and we just
     store the red level in one pixel, green in the next, and blue in
     the next, making the total image be three times wider than we
     really wanted.  This allows us to use all the normal 256 color
     graphics routines for drawing onto our memory surfaces, most
     importantly the lookup table translucency, which can be used to
     combine the low 5 bits of color and the top 3 bits of light in a
     single drawing operation.  Some trickery is needed to load 24 bit
     data into this fake 8 bit format, and of course it needs a custom
     routine to convert the resulting image while copying it across to
     the hardware screen.

     This program chugs slightly on my p133, but not significantly worse
     than any double buffering in what amounts to a 1920x640, 256 color
     resolution.  The light blending doesn't seem to slow it down too
     badly, so I think this technique would be quite usable on faster
     machines and in lower resolution hicolor modes.  The biggest
     problem is that although you keep the full 15 bit color resolution,
     you only get 3 bits of light, ie.  8 light levels.  You can do some
     nice colored light patches, but smooth gradients aren't going to
     work too well :-)

See also:
*Note BITMAP::.
*Note COLOR_MAP::.
*Note END_OF_MAIN::.
*Note PALETTE::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note bitmap_color_depth::.
*Note blit::.
*Note bmp_unwrite_line::.
*Note bmp_write_line::.
*Note circlefill::.
*Note clear_bitmap::.
*Note clear_keybuf::.
*Note color_map::.
*Note create_bitmap_ex::.
*Note destroy_bitmap::.
*Note draw_trans_sprite::.
*Note fixatan2::.
*Note fixsqrt::.
*Note fixtoi::.
*Note getb_depth: getr_depth.
*Note getg_depth: getr_depth.
*Note getpixel::.
*Note getr_depth::.
*Note hsv_to_rgb::.
*Note install_keyboard::.
*Note install_mouse::.
*Note install_timer::.
*Note itofix::.
*Note key::.
*Note keypressed::.
*Note line::.
*Note load_bitmap::.
*Note makecol::.
*Note mouse_x::.
*Note mouse_y: mouse_x.
*Note poll_mouse::.
*Note replace_filename::.
*Note retrace_count::.
*Note screen::.
*Note select_palette::.
*Note set_color_conversion::.
*Note set_color_depth::.
*Note set_gfx_mode::.


File: allegro.info,  Node: ex3d,  Next: excamera,  Prev: exlights,  Up: Available

3.3.36 ex3d
-----------

Example ex3d
     This program demonstrates how to use the 3d matrix functions.  It
     isn't a very elegant or efficient piece of code, but it does show
     the stuff in action.  It is left to the reader as an exercise to
     design a proper model structure and rendering pipeline: after all,
     the best way to do that sort of stuff varies hugely from one game
     to another.

     The example first shows a screen resolution selection dialog.
     Then, a number of bouncing 3d cubes are animated.  Pressing a key
     modifies the rendering of the cubes, which can be wireframe, the
     more complex transparent perspective correct texture mapped
     version, and many other.

See also:
*Note BITMAP::.
*Note COLOR_MAP::.
*Note END_OF_MAIN::.
*Note MATRIX::.
*Note PALETTE::.
*Note POLYTYPE_ATEX::.
*Note POLYTYPE_ATEX_LIT::.
*Note POLYTYPE_ATEX_MASK::.
*Note POLYTYPE_ATEX_MASK_LIT::.
*Note POLYTYPE_ATEX_MASK_TRANS::.
*Note POLYTYPE_ATEX_TRANS::.
*Note POLYTYPE_FLAT::.
*Note POLYTYPE_GCOL::.
*Note POLYTYPE_GRGB::.
*Note POLYTYPE_PTEX::.
*Note POLYTYPE_PTEX_LIT: POLYTYPE_ATEX_LIT.
*Note POLYTYPE_PTEX_MASK: POLYTYPE_ATEX_MASK.
*Note POLYTYPE_PTEX_MASK_LIT: POLYTYPE_ATEX_MASK_LIT.
*Note POLYTYPE_PTEX_MASK_TRANS: POLYTYPE_ATEX_MASK_TRANS.
*Note POLYTYPE_PTEX_TRANS: POLYTYPE_ATEX_TRANS.
*Note RGB::.
*Note RGB_MAP::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note V3D::.
*Note allegro_error::.
*Note allegro_exit::.
*Note allegro_init::.
*Note allegro_message::.
*Note apply_matrix::.
*Note bitmap_color_depth::.
*Note bitmap_mask_color::.
*Note blit::.
*Note clear_bitmap::.
*Note clear_to_color::.
*Note color_map::.
*Note create_bitmap::.
*Note create_light_table::.
*Note create_rgb_table::.
*Note create_trans_table::.
*Note desktop_palette::.
*Note destroy_bitmap::.
*Note fixed::.
*Note fixtoi::.
*Note font::.
*Note get_transformation_matrix::.
*Note gfx_mode_select_ex::.
*Note install_keyboard::.
*Note install_mouse::.
*Note install_timer::.
*Note itofix::.
*Note key::.
*Note keypressed::.
*Note line::.
*Note palette_color::.
*Note persp_project::.
*Note polygon_z_normal::.
*Note quad3d::.
*Note readkey::.
*Note rect::.
*Note retrace_count::.
*Note rgb_map::.
*Note screen::.
*Note set_color_depth::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note set_projection_viewport::.
*Note set_trans_blender::.
*Note textout_ex::.
*Note textprintf_ex::.
*Note vsync::.


File: allegro.info,  Node: excamera,  Next: exquat,  Prev: ex3d,  Up: Available

3.3.37 excamera
---------------

Example excamera
     This program demonstrates how to use the get_camera_matrix()
     function to view a 3d world from any position and angle.  The
     example draws a checkered floor through a viewport region on the
     screen.  You can use the keyboard to move around the camera or
     modify the size of the viewport.  The keys that can be used with
     this example are displayed between brackets at the top of the
     screen.

See also:
*Note BITMAP::.
*Note END_OF_MAIN::.
*Note MATRIX_f::.
*Note POLYTYPE_FLAT::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note V3D_f::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note apply_matrix_f: apply_matrix.
*Note blit::.
*Note clear_to_color::.
*Note clip3d_f::.
*Note create_bitmap::.
*Note desktop_palette::.
*Note destroy_bitmap::.
*Note font::.
*Note get_camera_matrix_f::.
*Note get_vector_rotation_matrix_f: get_vector_rotation_matrix.
*Note install_int_ex::.
*Note install_keyboard::.
*Note install_timer::.
*Note key::.
*Note key_shifts::.
*Note makecol::.
*Note persp_project_f: persp_project.
*Note poll_keyboard::.
*Note polygon::.
*Note polygon3d_f: polygon3d.
*Note rect::.
*Note screen::.
*Note set_clip_rect::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note set_projection_viewport::.
*Note textprintf_ex::.
*Note vsync::.


File: allegro.info,  Node: exquat,  Next: exstars,  Prev: excamera,  Up: Available

3.3.38 exquat
-------------

Example exquat
     Euler angles are convenient for storing and creating 3D
     orientations.  However, this program demonstrates that they are not
     good when interpolating between two different orientations.  The
     problem is solved by using Allegro's quaternion operations.

     In this program, two cubes are rotated between random orientations.
     Notice that although they have the same beginning and ending
     orientations, they do not follow the same path between
     orientations.

     One cube is being rotated by directly incrementing or decrementing
     the Euler angles from the starting point to the ending point.  This
     is an intuitive notion, but it is incorrect because it does not
     cause the object to turn around a single unchanging axis of
     rotation.  The axis of rotation wobbles resulting in the object
     spinning in strange ways.  The object will eventually end up in the
     orientation that the user intended, but it gets there in a way that
     is unattractive.  Imagine if this method was used to update the
     position of a camera in a game!  Sometimes it would swing wildly
     and disorient the player.

     The other cube is animated using quaternions.  This results in a
     much more pleasing animation because the cube turns around a single
     axis of rotation.

See also:
*Note BITMAP::.
*Note END_OF_MAIN::.
*Note MATRIX_f::.
*Note QUAT::.
*Note acquire_bitmap::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note apply_matrix_f: apply_matrix.
*Note blit::.
*Note circle::.
*Note clear_keybuf::.
*Note clear_to_color::.
*Note create_bitmap::.
*Note desktop_palette::.
*Note destroy_bitmap::.
*Note font::.
*Note get_camera_matrix_f::.
*Note get_rotation_matrix::.
*Note get_rotation_matrix_f: get_rotation_matrix.
*Note get_rotation_quat::.
*Note install_keyboard::.
*Note keypressed::.
*Note line::.
*Note matrix_mul_f: matrix_mul.
*Note palette_color::.
*Note persp_project_f: persp_project.
*Note quat_interpolate::.
*Note quat_to_matrix::.
*Note readkey::.
*Note release_bitmap::.
*Note rest::.
*Note screen::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note set_projection_viewport::.
*Note textout_ex::.


File: allegro.info,  Node: exstars,  Next: exscn3d,  Prev: exquat,  Up: Available

3.3.39 exstars
--------------

Example exstars
     This program draws a 3D star field (depth-cued) and a polygon
     starship (controllable with the keyboard cursor keys), using the
     Allegro math functions.

See also:
*Note BITMAP::.
*Note END_OF_MAIN::.
*Note MATRIX::.
*Note PALETTE::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note apply_matrix::.
*Note blit::.
*Note clear_bitmap::.
*Note create_bitmap::.
*Note cross_product::.
*Note destroy_bitmap::.
*Note dot_product::.
*Note fixed::.
*Note fixmul::.
*Note fixtof::.
*Note fixtoi::.
*Note font::.
*Note get_rotation_matrix::.
*Note get_transformation_matrix::.
*Note get_translation_matrix::.
*Note install_keyboard::.
*Note install_timer::.
*Note itofix::.
*Note key::.
*Note normalize_vector::.
*Note palette_color::.
*Note persp_project::.
*Note poll_keyboard::.
*Note putpixel::.
*Note rectfill::.
*Note screen::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note set_projection_viewport::.
*Note textout_centre_ex::.
*Note textprintf_centre_ex::.
*Note triangle::.
*Note vsync::.


File: allegro.info,  Node: exscn3d,  Next: exzbuf,  Prev: exstars,  Up: Available

3.3.40 exscn3d
--------------

Example exscn3d
     This program demonstrates how to use scanline sorting algorithm in
     Allegro (create_scene, clear_scene, ...  functions).  It also
     provides an example of how to use the 3D clipping function.  The
     example consists of a flyby through a lot of rotating 3d cubes.

See also:
*Note BITMAP::.
*Note END_OF_FUNCTION::.
*Note END_OF_MAIN::.
*Note LOCK_FUNCTION::.
*Note LOCK_VARIABLE::.
*Note MATRIX_f::.
*Note PALETTE::.
*Note POLYTYPE_GCOL::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note V3D_f::.
*Note allegro_error::.
*Note allegro_exit::.
*Note allegro_init::.
*Note allegro_message::.
*Note apply_matrix_f: apply_matrix.
*Note bitmap_color_depth::.
*Note blit::.
*Note clear_bitmap::.
*Note clear_scene::.
*Note clip3d_f::.
*Note create_bitmap::.
*Note create_scene::.
*Note desktop_palette::.
*Note destroy_bitmap::.
*Note destroy_scene::.
*Note font::.
*Note get_rotation_matrix_f: get_rotation_matrix.
*Note get_translation_matrix_f: get_translation_matrix.
*Note gfx_mode_select_ex::.
*Note install_int::.
*Note install_keyboard::.
*Note install_mouse::.
*Note install_timer::.
*Note key::.
*Note matrix_mul_f: matrix_mul.
*Note palette_color::.
*Note persp_project_f: persp_project.
*Note polygon_z_normal_f: polygon_z_normal.
*Note render_scene::.
*Note scene_polygon3d_f: scene_polygon3d.
*Note screen::.
*Note set_color_depth::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note set_projection_viewport::.
*Note textprintf_ex::.


File: allegro.info,  Node: exzbuf,  Next: exscroll,  Prev: exscn3d,  Up: Available

3.3.41 exzbuf
-------------

Example exzbuf
     This program demonstrates how to use Z-buffered polygons and
     floating point 3D math routines.  It also provides a simple way to
     compute fps (frames per second) using a timer.  After selecting a
     screen resolution through the standard GUI dialog, the example
     shows two 3D cubes rotating and intersecting each other.  Rather
     than having full polygons incorrectly overlap other polygons due to
     per-polygon sorting, each pixel is drawn at the correct depth.

See also:
*Note BITMAP::.
*Note END_OF_FUNCTION::.
*Note END_OF_MAIN::.
*Note LOCK_FUNCTION::.
*Note LOCK_VARIABLE::.
*Note MATRIX_f::.
*Note PALETTE::.
*Note POLYTYPE_GCOL::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note V3D_f::.
*Note ZBUFFER::.
*Note allegro_error::.
*Note allegro_exit::.
*Note allegro_init::.
*Note allegro_message::.
*Note apply_matrix_f: apply_matrix.
*Note bitmap_color_depth::.
*Note blit::.
*Note clear_bitmap::.
*Note clear_zbuffer::.
*Note create_bitmap::.
*Note create_zbuffer::.
*Note desktop_palette::.
*Note destroy_bitmap::.
*Note destroy_zbuffer::.
*Note font::.
*Note get_transformation_matrix_f::.
*Note gfx_mode_select_ex::.
*Note install_int::.
*Note install_keyboard::.
*Note install_mouse::.
*Note install_timer::.
*Note keypressed::.
*Note palette_color::.
*Note persp_project_f: persp_project.
*Note polygon_z_normal_f: polygon_z_normal.
*Note quad3d_f: quad3d.
*Note readkey::.
*Note screen::.
*Note set_color_depth::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note set_palette_range::.
*Note set_projection_viewport::.
*Note set_zbuffer::.
*Note textprintf_ex::.
*Note vsync::.


File: allegro.info,  Node: exscroll,  Next: ex3buf,  Prev: exzbuf,  Up: Available

3.3.42 exscroll
---------------

Example exscroll
     This program demonstrates how to use hardware scrolling.  The
     scrolling should work on anything that supports virtual screens
     larger than the physical screen.

See also:
*Note BITMAP::.
*Note END_OF_MAIN::.
*Note RGB::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note acquire_bitmap::.
*Note allegro_init::.
*Note allegro_message::.
*Note clear_keybuf::.
*Note create_sub_bitmap::.
*Note desktop_palette::.
*Note destroy_bitmap::.
*Note install_keyboard::.
*Note keypressed::.
*Note rectfill::.
*Note release_bitmap::.
*Note rest::.
*Note screen::.
*Note scroll_screen::.
*Note set_color::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note vline::.


File: allegro.info,  Node: ex3buf,  Next: ex12bit,  Prev: exscroll,  Up: Available

3.3.43 ex3buf
-------------

Example ex3buf
     This program demonstrates the use of triple buffering.  Several
     triangles are displayed rotating and bouncing on the screen until
     you press a key.  Note that on some platforms you can't get real
     hardware triple buffering.  The Allegro code remains the same, but
     most likely the graphic driver will emulate it.  Unfortunately, in
     these cases you can't expect the animation to be completely smooth
     and flicker free.

See also:
*Note BITMAP::.
*Note END_OF_MAIN::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note acquire_bitmap::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note clear_bitmap::.
*Note clear_keybuf::.
*Note create_video_bitmap::.
*Note desktop_palette::.
*Note destroy_bitmap::.
*Note enable_triple_buffer::.
*Note fixcos::.
*Note fixed::.
*Note fixmul::.
*Note fixsin::.
*Note fixtoi::.
*Note font::.
*Note gfx_capabilities::.
*Note install_keyboard::.
*Note install_mouse::.
*Note install_timer::.
*Note itofix::.
*Note keypressed::.
*Note poll_scroll::.
*Note release_bitmap::.
*Note request_video_bitmap::.
*Note screen::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note textout_ex::.
*Note triangle::.
*Note ustrzcpy::.


File: allegro.info,  Node: ex12bit,  Next: exaccel,  Prev: ex3buf,  Up: Available

3.3.44 ex12bit
--------------

Example ex12bit
     This program sets up a 12-bit mode on any 8-bit card, by setting up
     a 256-colour palette that will fool the eye into grouping two 8-bit
     pixels into one 12-bit pixel.  In order to do this, you make your
     256-colour palette with all the combinations of blue and green,
     assuming green ranges from 0-15 and blue from 0-14.  This takes up
     16x15=240 colours.  This leaves 16 colours to use as red (red
     ranges from 0-15).  Then you put your green/blue in one pixel, and
     your red in the pixel next to it.  The eye gets fooled into
     thinking it's all one pixel.

     The example starts setting a normal 256 color mode, and construct a
     special palette for it.  But then comes the trick: you need to
     write to a set of two adjacent pixels to form a single 12 bit dot.
     Two eight bit pixels is the same as one 16 bit pixel, so after
     setting the video mode you need to hack the screen bitmap about,
     halving the width and changing it to use the 16 bit drawing code.
     Then, once you have packed a color into the correct format (using
     the makecol12() function below), any of the normal Allegro drawing
     functions can be used with this 12 bit display!

     Things to note:

        * The horizontal width is halved, so you get resolutions like
          320x480, 400x600, and 512x768.

        * Because each dot is spread over two actual pixels, the display
          will be darker than in a normal video mode.

        * Any bitmap data will obviously need converting to the correct
          12 bit format: regular 15 or 16 bit images won't display
          correctly...

        * Although this works like a truecolor mode, it is actually
          using a 256 color palette, so palette fades are still
          possible!

        * This code only works in linear screen modes (don't try
          Mode-X).

See also:
*Note BITMAP::.
*Note END_OF_MAIN::.
*Note MATRIX::.
*Note PALETTE::.
*Note RGB::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note apply_matrix::.
*Note blit::.
*Note circle::.
*Note clear_bitmap::.
*Note clear_keybuf::.
*Note clear_to_color::.
*Note create_bitmap::.
*Note create_bitmap_ex::.
*Note destroy_bitmap::.
*Note ellipsefill::.
*Note fade_out::.
*Note fixcos::.
*Note fixed::.
*Note fixsin::.
*Note fixtoi::.
*Note font::.
*Note get_rotation_matrix::.
*Note getpixel::.
*Note install_keyboard::.
*Note itofix::.
*Note keypressed::.
*Note line::.
*Note makecol::.
*Note masked_blit::.
*Note putpixel::.
*Note rest::.
*Note screen::.
*Note set_clip_rect::.
*Note set_color::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note text_height::.
*Note text_length::.
*Note textout_ex::.
*Note textprintf_ex::.


File: allegro.info,  Node: exaccel,  Next: exspline,  Prev: ex12bit,  Up: Available

3.3.45 exaccel
--------------

Example exaccel
     This program demonstrates how to use an offscreen part of the video
     memory to store source graphics for a hardware accelerated graphics
     driver.  The example loads the 'mysha.pcx' file and then blits it
     several times on the screen.  Depending on whether you have enough
     video memory and Allegro supports the hardware acceleration
     features of your card, your success running this example may be
     none at all, sluggish performance due to software emulation, or
     flicker free smooth hardware accelerated animation.

See also:
*Note BITMAP::.
*Note END_OF_MAIN::.
*Note PALETTE::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note acquire_bitmap::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note blit::.
*Note clear_bitmap::.
*Note create_video_bitmap::.
*Note destroy_bitmap::.
*Note font::.
*Note gfx_capabilities::.
*Note install_keyboard::.
*Note install_timer::.
*Note keypressed::.
*Note load_bitmap::.
*Note readkey::.
*Note release_bitmap::.
*Note replace_filename::.
*Note screen::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note show_video_bitmap::.
*Note textout_ex::.
*Note textprintf_ex::.


File: allegro.info,  Node: exspline,  Next: exsyscur,  Prev: exaccel,  Up: Available

3.3.46 exspline
---------------

Example exspline
     This program demonstrates the use of spline curves to create smooth
     paths connecting a number of node points.  This can be useful for
     constructing realistic motion and animations.

     The technique is to connect the series of guide points p1..p(n)
     with spline curves from p1-p2, p2-p3, etc.  Each spline must pass
     though both of its guide points, so they must be used as the first
     and fourth of the spline control points.  The fun bit is coming up
     with sensible values for the second and third spline control
     points, such that the spline segments will have equal gradients
     where they meet.  I came up with the following solution:

     For each guide point p(n), calculate the desired tangent to the
     curve at that point.  I took this to be the vector p(n-1) ->
     p(n+1), which can easily be calculated with the inverse tangent
     function, and gives decent looking results.  One implication of
     this is that two dummy guide points are needed at each end of the
     curve, which are used in the tangent calculations but not connected
     to the set of splines.

     Having got these tangents, it becomes fairly easy to calculate the
     spline control points.  For a spline between guide points p(a) and
     p(b), the second control point should lie along the positive
     tangent from p(a), and the third control point should lie along the
     negative tangent from p(b).  How far they are placed along these
     tangents controls the shape of the curve: I found that applying a
     'curviness' scaling factor to the distance between p(a) and p(b)
     works well.

     One thing to note about splines is that the generated points are
     not all equidistant.  Instead they tend to bunch up nearer to the
     ends of the spline, which means you will need to apply some fudges
     to get an object to move at a constant speed.  On the other hand,
     in situations where the curve has a noticeable change of direction
     at each guide point, the effect can be quite nice because it makes
     the object slow down for the curve.

See also:
*Note END_OF_MAIN::.
*Note SCREEN_W::.
*Note acquire_screen::.
*Note alert::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note calc_spline::.
*Note circlefill::.
*Note clear_keybuf::.
*Note clear_to_color::.
*Note desktop_palette::.
*Note fixatan2::.
*Note fixcos::.
*Note fixed::.
*Note fixmul::.
*Note fixsin::.
*Note fixsqrt::.
*Note fixtof::.
*Note fixtoi::.
*Note font::.
*Note ftofix::.
*Note install_keyboard::.
*Note install_mouse::.
*Note install_timer::.
*Note itofix::.
*Note key::.
*Note keypressed::.
*Note line::.
*Note makecol::.
*Note mouse_b: mouse_x.
*Note mouse_x::.
*Note mouse_y: mouse_x.
*Note palette_color::.
*Note poll_mouse::.
*Note readkey::.
*Note release_screen::.
*Note screen::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note show_mouse::.
*Note spline::.
*Note textout_centre_ex::.
*Note textprintf_centre_ex::.
*Note textprintf_ex::.
*Note vsync::.
*Note xor_mode::.


File: allegro.info,  Node: exsyscur,  Next: exupdate,  Prev: exspline,  Up: Available

3.3.47 exsyscur
---------------

Example exsyscur
     This program demonstrates the use of hardware accelerated mouse
     cursors.

See also:
*Note END_OF_MAIN::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note clear_to_color::.
*Note enable_hardware_cursor::.
*Note font::.
*Note gfx_capabilities::.
*Note install_keyboard::.
*Note install_mouse::.
*Note install_timer::.
*Note makecol::.
*Note readkey::.
*Note screen::.
*Note select_mouse_cursor::.
*Note set_gfx_mode::.
*Note show_mouse::.
*Note text_height::.
*Note textprintf_centre_ex::.


File: allegro.info,  Node: exupdate,  Next: exswitch,  Prev: exsyscur,  Up: Available

3.3.48 exupdate
---------------

Example exupdate
     This program demonstrates how to support double buffering, page
     flipping, and triple buffering as options within a single program,
     and how to make things run at a constant rate no matter what the
     speed of your computer.  You have to use this example from the
     command line to specify as first parameter a number which
     represents the type of video update you want: 1 for double
     buffering with memory bitmaps, 2 for page flipping, 3 for triple
     buffering and 4 for double buffering with system bitmaps.  After
     this, a dialog allows you to select a screen resolution and finally
     you will see a kaleidoscopic animation, along with a frames per
     second counter on the top left of the screen.

See also:
*Note BITMAP::.
*Note END_OF_FUNCTION::.
*Note END_OF_MAIN::.
*Note LOCK_FUNCTION::.
*Note LOCK_VARIABLE::.
*Note PALETTE::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note acquire_bitmap::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note bitmap_color_depth::.
*Note blit::.
*Note clear_bitmap::.
*Note create_bitmap::.
*Note create_system_bitmap::.
*Note create_video_bitmap::.
*Note desktop_palette::.
*Note destroy_bitmap::.
*Note enable_triple_buffer::.
*Note fixcos::.
*Note fixed::.
*Note fixmul::.
*Note fixsin::.
*Note fixtoi::.
*Note font::.
*Note ftofix::.
*Note generate_332_palette::.
*Note gfx_capabilities::.
*Note gfx_mode_select_ex::.
*Note install_int_ex::.
*Note install_keyboard::.
*Note install_mouse::.
*Note install_timer::.
*Note keypressed::.
*Note line::.
*Note makecol::.
*Note poll_scroll::.
*Note release_bitmap::.
*Note request_video_bitmap::.
*Note screen::.
*Note set_color_depth::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note show_video_bitmap::.
*Note textout_ex::.
*Note textprintf_ex::.
*Note triangle::.
*Note vsync::.
*Note xor_mode::.


File: allegro.info,  Node: exswitch,  Next: exstream,  Prev: exupdate,  Up: Available

3.3.49 exswitch
---------------

Example exswitch
     This program shows how to control the console switching mode, and
     let your program run in the background.  These functions don't
     apply to every platform and driver, for example you can't control
     the switching mode from a DOS program.

     Yes, I know the fractal drawing is very slow: that's the point!
     This is so you can easily check whether it goes on working in the
     background after you switch away from the app.

     Depending on the type of selected switching mode, you will see
     whether the contents of the screen are preserved or not.

See also:
*Note BITMAP::.
*Note END_OF_FUNCTION::.
*Note END_OF_MAIN::.
*Note LOCK_FUNCTION::.
*Note LOCK_VARIABLE::.
*Note PALETTE::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note acquire_bitmap::.
*Note acquire_screen::.
*Note allegro_error::.
*Note allegro_exit::.
*Note allegro_init::.
*Note allegro_message::.
*Note bitmap_color_depth::.
*Note blit::.
*Note clear_to_color::.
*Note create_sub_bitmap::.
*Note desktop_palette::.
*Note destroy_bitmap::.
*Note font::.
*Note get_display_switch_mode::.
*Note gfx_mode_select_ex::.
*Note install_int::.
*Note install_keyboard::.
*Note install_mouse::.
*Note install_timer::.
*Note keypressed::.
*Note makecol::.
*Note palette_color::.
*Note putpixel::.
*Note readkey::.
*Note rectfill::.
*Note release_bitmap::.
*Note release_screen::.
*Note screen::.
*Note set_color_depth::.
*Note set_display_switch_callback::.
*Note set_display_switch_mode::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note textout_centre_ex::.
*Note textprintf_centre_ex::.


File: allegro.info,  Node: exstream,  Next: expackf,  Prev: exswitch,  Up: Available

3.3.50 exstream
---------------

Example exstream
     This program shows how to use the audio stream functions to
     transfer large blocks of sample data to the sound card.  In this
     case, the sample data is generated during runtime, and the
     resulting sound reminds of a car engine when you are accelerating.

See also:
*Note AUDIOSTREAM::.
*Note END_OF_MAIN::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note clear_to_color::.
*Note desktop_palette::.
*Note font::.
*Note free_audio_stream_buffer::.
*Note get_audio_stream_buffer::.
*Note install_keyboard::.
*Note install_sound::.
*Note install_timer::.
*Note keypressed::.
*Note makecol::.
*Note play_audio_stream::.
*Note readkey::.
*Note screen::.
*Note set_display_switch_mode::.
*Note set_gfx_mode::.
*Note set_palette::.
*Note stop_audio_stream::.
*Note textprintf_centre_ex::.
*Note voice_start::.
*Note voice_stop::.


File: allegro.info,  Node: expackf,  Prev: exstream,  Up: Available

3.3.51 expackf
--------------

Example expackf
     This program demonstrates the use of the packfile functions, with
     some simple tests.

     The first test uses the standard packfile functions to transfer a
     bitmap file into a block of memory, then reads the bitmap out of
     the block of memory, using a custom packfile vtable.

     The second test reads in a bitmap with another custom packfile
     vtable, which uses libc's file stream functions.

     The third test demonstrates seeking with a custom vtable.

     The fourth test reads two bitmaps, and dumps them back into a
     single file, using a custom vtable again.

See also:
*Note ASSERT::.
*Note BITMAP::.
*Note END_OF_MAIN::.
*Note PACKFILE::.
*Note PACKFILE_VTABLE::.
*Note SCREEN_H: SCREEN_W.
*Note SCREEN_W::.
*Note alert::.
*Note allegro_error::.
*Note allegro_init::.
*Note allegro_message::.
*Note blit::.
*Note clear_bitmap::.
*Note destroy_bitmap::.
*Note file_size_ex::.
*Note font::.
*Note install_keyboard::.
*Note key::.
*Note load_bmp_pf::.
*Note load_pcx::.
*Note load_pcx_pf::.
*Note load_tga_pf::.
*Note pack_fclose::.
*Note pack_fopen::.
*Note pack_fopen_vtable::.
*Note pack_fread::.
*Note pack_fseek::.
*Note readkey::.
*Note save_bmp_pf::.
*Note save_tga_pf::.
*Note screen::.
*Note set_color_depth::.
*Note set_gfx_mode::.
*Note text_height::.
*Note textprintf_centre_ex::.
*Note textprintf_ex::.


File: allegro.info,  Node: Tools,  Next: Additional,  Prev: Available,  Up: Top

4 Tools
*******

* Menu:

* Additional::              Additional programs included with Allegro


File: allegro.info,  Node: Additional,  Next: Community,  Prev: Tools,  Up: Tools

4.1 Additional programs included with Allegro
=============================================

Allegro comes with several useful utility programs.  They are currently
documented separately.  Refer to the HTML documentation (including CHM
and devhelp) of Allegro which includes all the documents, or the single
plain text versions of these documents (makedoc.txt, grabber.txt,
dat.txt, dat2s.txt, dat2c.txt).


File: allegro.info,  Node: Community,  Next: Conclusion,  Prev: Additional,  Up: Top

5 Community
***********

Allegro was originally created by Shawn Hargreaves.  Published sometime
between 1994 and 1995, it was just a simple lib for himself.  At that
time, many people were switching from Borland C to DJGPP and looking for
a decent graphics library.  Allegro was the first reasonably complete
one to show up, so it attracted enough interest to keep growing, and a
little contribution here, and some more encouragement there made it all
light up like fire.

Some time after the latest 3.x stable release, though, Shawn was flooded
with Allegro tasks and Real Life (TM) work, and chose the latter to
focus his energies on.  While this somehow stalled Allegro's
development, it also attracted a lot of people who wanted Allegro to
live longer.  Also, by that time other people had started to work on
Windows and Unix ports of Allegro, which suggested that Allegro had the
potential to survive its only decaying main platform (DOS).

The current situation is that Shawn still keeps watching Allegro's
progress from time to time, but is not involved with development any
more.  The community that grew over the years when Shawn was in charge
of everything has stepped forward to continue improving Allegro.
Transformed into a meritocratic community, users keep sending bug
reports to the mailing lists, developers around the world keep sending
patches to fix them, and a few carefully chosen have write access to the
SVN repository, from which releases are built every now and then.

But, who decides when a build is stable enough?  Who decides when
somebody is granted write access to the SVN? Who chooses the lesser of
two evils patching some obscure bug?  And more importantly, who decides
what's Allegro's mascot?  For all these reasons, the community decided
to replace Shawn's position with the Allegro Dictator.

In republican Rome, political power was with the Senate and the Consuls.
However, if it was necessary that decisions were made very quickly then
the senate could appoint a Dictator.  The Dictator was appointed for a
specified duration or charged with a specific task, after which he was
expected to surrender his authority back to the Senate.  Nowadays, the
Allegro Dictator is a benevolent figure and rarely has to use his
overwhelming fist of iron to put order into chaos.

The truth is that the Allegro Dictator is usually the person in charge
of doing releases and all that unsexy work inside the community, like
pestering users to test some obscure bugfix or rejecting incomplete
patches.

Past Allegro dictators have been: Shawn Hargreaves, George Foot, Peter
Wang and Eric Botcazou.  At the moment of writing this, Evert Glebbeek
is the active Allegro Dictator.  Should you want to change Allegro in
some illogical way, he's the guy you have to send your bribes too :-)


File: allegro.info,  Node: Conclusion,  Next: Index,  Prev: Community,  Up: Top

6 Conclusion
************

All good things must come to an end.  Writing documentation is not a
good thing, though, and that means it goes on for ever.  There is always
something we've forgotten to explain, or some essential detail we've
left out, but for now you will have to make do with this.  Feel free to
ask if you can't figure something out.

Enjoy.  We hope you find some of this stuff useful.

By Shawn Hargreaves and the Allegro development team.

http://alleg.sourceforge.net/


File: allegro.info,  Node: Index,  Prev: Conclusion,  Up: Top

7 Index
*******

* Menu:

* 256-color transparency::
* _getpixel::
* _putpixel::
* _set_color::
* _ustrdup::
* acquire_bitmap::
* acquire_screen::
* active_dialog::
* active_menu::
* add_clip_rect::
* adjust_sample::
* al_assert::
* al_ffblk::
* al_ffblk_get_size::
* al_findclose::
* al_findfirst::
* al_findnext::
* AL_ID::
* al_trace::
* alert::
* alert3::
* allegro_404_char::
* ALLEGRO_DATE::
* ALLEGRO_DATE_STR::
* allegro_error::
* allegro_exit::
* allegro_icon::
* allegro_id::
* allegro_init::
* allegro_message::
* ALLEGRO_SUB_VERSION::
* ALLEGRO_VERSION::
* ALLEGRO_VERSION_STR::
* ALLEGRO_WIP_VERSION::
* allocate_voice::
* append_filename::
* apply_matrix::
* apply_quat::
* arc::
* ASSERT::
* AUDIOSTREAM::
* bestfit_color::
* BITMAP::
* bitmap_color_depth::
* bitmap_mask_color::
* black_palette::
* blit::
* blit_from_hdc::
* blit_to_hdc::
* bmp_read_line::
* bmp_unwrite_line::
* bmp_write_line::
* broadcast_dialog_message::
* calc_spline::
* calibrate_joystick::
* calibrate_joystick_name::
* canonicalize_filename::
* centre_dialog::
* check_cpu::
* circle::
* circlefill::
* clear_bitmap::
* clear_keybuf::
* clear_scene::
* clear_to_color::
* clear_zbuffer::
* clip3d::
* clip3d_f::
* close_fli::
* COLOR_MAP::
* color_map::
* COMPILED_SPRITE::
* config_is_hooked::
* convert_bitmap_to_hbitmap::
* convert_hbitmap_to_bitmap::
* convert_hpalette_to_palette::
* convert_palette_to_hpalette::
* cpu_capabilities::
* cpu_family::
* cpu_model::
* cpu_vendor::
* create_bitmap::
* create_bitmap_ex::
* create_blender_table::
* create_color_table::
* create_datafile_index::
* create_light_table::
* create_lzss_pack_data::
* create_lzss_unpack_data::
* create_rgb_table::
* create_sample::
* create_scene::
* create_sub_bitmap::
* create_sub_zbuffer::
* create_system_bitmap::
* create_trans_table::
* create_video_bitmap::
* create_zbuffer::
* cross_product::
* Custom datafile objects::
* d_bitmap_proc::
* d_box_proc::
* d_button_proc::
* d_check_proc::
* d_clear_proc::
* d_edit_proc::
* d_icon_proc::
* d_keyboard_proc::
* d_list_proc::
* d_menu_proc::
* d_radio_proc::
* d_slider_proc::
* d_text_list_proc::
* d_text_proc::
* d_textbox_proc::
* d_yield_proc::
* DAT_ID::
* DATAFILE::
* deallocate_voice::
* default_palette::
* delete_file::
* desktop_color_depth::
* desktop_palette::
* destroy_bitmap::
* destroy_compiled_sprite::
* destroy_datafile_index::
* destroy_font::
* destroy_gfx_mode_list::
* destroy_midi::
* destroy_rle_sprite::
* destroy_sample::
* destroy_scene::
* destroy_zbuffer::
* detect_digi_driver::
* detect_midi_driver::
* DIALOG::
* dialog_message::
* DIALOG_PLAYER::
* DIGI_*/BeOS::
* DIGI_*/DOS::
* DIGI_*/MacOSX::
* DIGI_*/QNX::
* DIGI_*/Unix::
* DIGI_*/Windows::
* digi_recorder::
* disable_hardware_cursor::
* do_arc::
* do_circle::
* do_dialog::
* do_ellipse::
* do_line::
* do_menu::
* do_uconvert::
* DOS integration routines::
* dot_product::
* draw_character_ex::
* draw_compiled_sprite::
* draw_gouraud_sprite::
* draw_lit_rle_sprite::
* draw_lit_sprite::
* draw_rle_sprite::
* draw_sprite::
* draw_sprite_ex::
* draw_sprite_v_flip::
* draw_to_hdc::
* draw_trans_rle_sprite::
* draw_trans_sprite::
* drawing_mode::
* ellipse::
* ellipsefill::
* empty_string::
* enable_hardware_cursor::
* enable_triple_buffer::
* END_OF_FUNCTION::
* END_OF_MAIN::
* ex12bit::
* ex3buf::
* ex3d::
* exaccel::
* exalpha::
* exbitmap::
* exblend::
* excamera::
* excolmap::
* exconfig::
* excustom::
* exdata::
* exdbuf::
* exexedat::
* exfixed::
* exflame::
* exflip::
* exfont::
* exgui::
* exhello::
* exists::
* exjoy::
* exkeys::
* exlights::
* exmem::
* exmidi::
* exmouse::
* expackf::
* expal::
* expat::
* exquat::
* exrgbhsv::
* exrotscl::
* exsample::
* exscale::
* exscn3d::
* exscroll::
* exshade::
* exspline::
* exsprite::
* exstars::
* exstream::
* exswitch::
* exsyscur::
* extimer::
* extract_font_range::
* extrans::
* extrans2::
* extruec::
* exunicod::
* exupdate::
* exxfade::
* exzbuf::
* fade_from::
* fade_from_range::
* fade_in::
* fade_in_range::
* fade_interpolate::
* fade_out::
* fade_out_range::
* fastline::
* file_exists::
* file_select_ex::
* file_size_ex::
* file_time::
* find_allegro_resource::
* find_datafile_object::
* find_dialog_focus::
* Fix class::
* fix_filename_case::
* fix_filename_slashes::
* fixacos::
* fixadd::
* fixasin::
* fixatan::
* fixatan2::
* fixceil::
* fixcos::
* fixdiv::
* fixed::
* Fixed point trig::
* fixfloor::
* fixhypot::
* fixmul::
* fixsin::
* fixsqrt::
* fixsub::
* fixtan::
* fixtof::
* fixtoi::
* fixtorad_r::
* fixup_datafile::
* fli_bitmap::
* fli_bmp_dirty_from::
* fli_frame::
* fli_pal_dirty_from::
* fli_palette::
* fli_timer::
* floodfill::
* flush_config_file::
* FONT::
* font::
* font_has_alpha::
* for_each_file_ex::
* free_audio_stream_buffer::
* free_config_entries::
* free_lzss_pack_data::
* free_lzss_unpack_data::
* freeze_mouse_flag::
* ftofix::
* GDI routines::
* generate_332_palette::
* generate_optimized_palette::
* get_align_matrix::
* get_align_matrix_f::
* get_audio_stream_buffer::
* get_camera_matrix::
* get_camera_matrix_f::
* get_clip_rect::
* get_clip_state::
* get_color::
* get_color_conversion::
* get_color_depth::
* get_compiled_sprite::
* get_config_argv::
* get_config_float::
* get_config_hex::
* get_config_id::
* get_config_int::
* get_config_string::
* get_config_text::
* get_datafile_property::
* get_desktop_resolution::
* get_display_switch_mode::
* get_executable_name::
* get_extension::
* get_filename::
* get_filename_encoding::
* get_font_range_begin::
* get_font_range_end::
* get_font_ranges::
* get_gfx_mode::
* get_gfx_mode_list::
* get_gfx_mode_type::
* get_hardware_volume::
* get_midi_length::
* get_mixer_bits::
* get_mixer_buffer_length::
* get_mixer_channels::
* get_mixer_frequency::
* get_mixer_quality::
* get_mixer_voices::
* get_mouse_mickeys::
* get_palette::
* get_palette_range::
* get_refresh_rate::
* get_rle_sprite::
* get_rotation_matrix::
* get_rotation_quat::
* get_scaling_matrix::
* get_sound_input_cap_bits::
* get_sound_input_cap_parm::
* get_sound_input_cap_rate::
* get_sound_input_cap_stereo::
* get_transformation_matrix::
* get_transformation_matrix_f::
* get_translation_matrix::
* get_uformat::
* get_vector_rotation_matrix::
* get_vector_rotation_quat::
* get_volume::
* get_x_rotate_matrix::
* get_x_rotate_quat::
* get_y_rotate_matrix::
* get_z_rotate_matrix::
* geta32::
* getpixel::
* getr::
* getr8::
* getr_depth::
* GFX_*/BeOS::
* GFX_*/DOS::
* GFX_*/Linux::
* GFX_*/MacOSX::
* GFX_*/QNX::
* GFX_*/Windows::
* GFX_*/X::
* gfx_capabilities::
* GFX_MODE::
* GFX_MODE_LIST::
* gfx_mode_select::
* gfx_mode_select_ex::
* gfx_mode_select_filter::
* grab_font_from_bitmap::
* GUI font::
* GUI menus::
* GUI variables::
* gui_fg_color::
* gui_font_baseline::
* gui_get_screen::
* gui_menu_draw_menu::
* gui_mg_color::
* gui_mouse_focus::
* gui_mouse_x::
* gui_set_screen::
* gui_shadow_box_proc::
* gui_strlen::
* gui_textout_ex::
* hline::
* hook_config_section::
* hsv_to_rgb::
* i_love_bill::
* identity_matrix::
* identity_quat::
* init_dialog::
* init_menu::
* initialise_joystick::
* install_allegro::
* install_int::
* install_int_ex::
* install_joystick::
* install_keyboard::
* install_keyboard_hooks::
* install_mouse::
* install_param_int::
* install_param_int_ex::
* install_sound::
* install_sound_input::
* install_timer::
* is_color_font::
* is_compatible_font::
* is_inside_bitmap::
* is_linear_bitmap::
* is_memory_bitmap::
* is_mono_font::
* is_planar_bitmap::
* is_relative_filename::
* is_same_bitmap::
* is_screen_bitmap::
* is_sub_bitmap::
* is_system_bitmap::
* is_trans_font::
* is_video_bitmap::
* is_windowed_mode::
* itofix::
* joy::
* JOY_TYPE_*/DOS::
* JOY_TYPE_*/Linux::
* JOY_TYPE_*/Windows::
* JOYSTICK_AXIS_INFO::
* JOYSTICK_BUTTON_INFO::
* JOYSTICK_INFO::
* JOYSTICK_STICK_INFO::
* key::
* key_led_flag::
* key_shifts::
* keyboard_callback::
* keyboard_lowlevel_callback::
* keyboard_needs_poll::
* keyboard_ucallback::
* keypressed::
* line::
* list_config_entries::
* list_config_sections::
* load_bios_font::
* load_bitmap::
* load_bitmap_font::
* load_bmp::
* load_bmp_pf::
* load_dat_font::
* load_datafile::
* load_datafile_callback::
* load_datafile_object::
* load_datafile_object_indexed::
* load_font::
* load_grx_font::
* load_grx_or_bios_font::
* load_ibk::
* load_joystick_data::
* load_lbm::
* load_midi::
* load_midi_patches::
* load_pcx::
* load_pcx_pf::
* load_sample::
* load_tga::
* load_tga_pf::
* load_txt_font::
* load_voc::
* load_voc_pf::
* load_wav::
* load_wav_pf::
* lock_bitmap::
* LOCK_FUNCTION::
* lock_midi::
* lock_sample::
* LOCK_VARIABLE::
* LZSS_PACK_DATA::
* lzss_read::
* LZSS_UNPACK_DATA::
* lzss_write::
* make_absolute_filename::
* make_relative_filename::
* make_trans_font::
* MAKE_VERSION::
* makeacol::
* makeacol32::
* makecol::
* makecol15_dither::
* makecol8::
* makecol_depth::
* MASK_COLOR_8::
* masked_blit::
* masked_stretch_blit::
* MATRIX::
* MATRIX_f::
* matrix_mul::
* matrix_to_quat::
* MENU::
* MENU_PLAYER::
* merge_fonts::
* MIDI::
* MIDI_*/BeOS::
* MIDI_*/DOS::
* MIDI_*/MacOSX::
* MIDI_*/QNX::
* MIDI_*/Unix::
* MIDI_*/Windows::
* midi_loop_start::
* midi_msg_callback::
* midi_out::
* midi_pause::
* midi_pos::
* midi_recorder::
* midi_resume::
* midi_seek::
* midi_time::
* More on banked direct memory access::
* mouse_callback::
* mouse_needs_poll::
* mouse_on_screen::
* mouse_sprite::
* mouse_x::
* need_uconvert::
* next_fli_frame::
* normalize_vector::
* num_joysticks::
* object_message::
* offer_focus::
* open_fli::
* os_multitasking::
* os_type::
* os_version::
* override_config_data::
* override_config_file::
* pack_fclose::
* pack_fclose_chunk::
* pack_feof::
* pack_ferror::
* pack_fgets::
* pack_fopen::
* pack_fopen_chunk::
* pack_fopen_vtable::
* pack_fputs::
* pack_fread::
* pack_fseek::
* pack_fwrite::
* pack_getc::
* pack_igetl::
* pack_igetw::
* pack_iputl::
* pack_iputw::
* pack_mgetl::
* pack_mgetw::
* pack_mputl::
* pack_mputw::
* pack_putc::
* pack_ungetc::
* PACKFILE::
* packfile_password::
* PACKFILE_VTABLE::
* PAL_SIZE::
* PALETTE::
* palette_color::
* persp_project::
* pivot_scaled_sprite::
* pivot_scaled_sprite_lit::
* pivot_scaled_sprite_trans::
* pivot_scaled_sprite_v_flip::
* pivot_scaled_sprite_v_flip_lit::
* pivot_scaled_sprite_v_flip_trans::
* pivot_sprite::
* pivot_sprite_lit::
* pivot_sprite_trans::
* pivot_sprite_v_flip::
* pivot_sprite_v_flip_lit::
* pivot_sprite_v_flip_trans::
* play_audio_stream::
* play_fli::
* play_looped_midi::
* play_memory_fli::
* play_midi::
* play_sample::
* poll_joystick::
* poll_keyboard::
* poll_mouse::
* poll_scroll::
* polygon::
* polygon3d::
* polygon_z_normal::
* POLYTYPE_ATEX::
* POLYTYPE_ATEX_LIT::
* POLYTYPE_ATEX_MASK::
* POLYTYPE_ATEX_MASK_LIT::
* POLYTYPE_ATEX_MASK_TRANS::
* POLYTYPE_ATEX_TRANS::
* POLYTYPE_FLAT::
* POLYTYPE_GCOL::
* POLYTYPE_GRGB::
* POLYTYPE_PTEX::
* pop_config_state::
* popup_dialog::
* position_dialog::
* position_mouse::
* position_mouse_w::
* position_mouse_z::
* push_config_state::
* put_backslash::
* putpixel::
* QNX integration routines::
* qnx_get_window::
* qscale_matrix::
* qtranslate_matrix::
* quad3d::
* QUAT::
* quat_interpolate::
* quat_mul::
* quat_slerp::
* quat_to_matrix::
* radtofix_r::
* read_sound_input::
* readkey::
* reallocate_voice::
* rect::
* rectfill::
* register_assert_handler::
* register_bitmap_file_type::
* register_datafile_object::
* register_font_file_type::
* register_sample_file_type::
* register_trace_handler::
* register_uformat::
* release_bitmap::
* release_screen::
* release_voice::
* reload_config_texts::
* remove_display_switch_callback::
* remove_int::
* remove_joystick::
* remove_keyboard::
* remove_mouse::
* remove_param_int::
* remove_sound::
* remove_sound_input::
* remove_timer::
* render_scene::
* replace_extension::
* replace_filename::
* request_refresh_rate::
* request_scroll::
* request_video_bitmap::
* reserve_voices::
* reset_fli_variables::
* rest::
* rest_callback::
* retrace_count::
* RGB::
* RGB_MAP::
* rgb_map::
* RLE_SPRITE::
* rotate_scaled_sprite::
* rotate_scaled_sprite_lit::
* rotate_scaled_sprite_trans::
* rotate_scaled_sprite_v_flip::
* rotate_scaled_sprite_v_flip_lit::
* rotate_scaled_sprite_v_flip_trans::
* rotate_sprite::
* rotate_sprite_lit::
* rotate_sprite_trans::
* rotate_sprite_v_flip::
* rotate_sprite_v_flip_lit::
* rotate_sprite_v_flip_trans::
* SAMPLE::
* save_bitmap::
* save_bmp::
* save_bmp_pf::
* save_joystick_data::
* save_pcx::
* save_pcx_pf::
* save_sample::
* save_tga::
* save_tga_pf::
* scancode_to_ascii::
* scancode_to_name::
* scare_mouse::
* scare_mouse_area::
* Scene rendering::
* scene_gap::
* scene_polygon3d::
* screen::
* SCREEN_W::
* scroll_screen::
* select_mouse_cursor::
* select_palette::
* set_add_blender::
* set_allegro_resource_path::
* set_alpha_blender::
* set_blender_mode::
* set_blender_mode_ex::
* set_burn_blender::
* set_clip_rect::
* set_clip_state::
* set_close_button_callback::
* set_color::
* set_color_blender::
* set_color_conversion::
* set_color_depth::
* set_config_data::
* set_config_file::
* set_config_float::
* set_config_hex::
* set_config_id::
* set_config_int::
* set_config_string::
* set_dialog_color::
* set_difference_blender::
* set_display_switch_callback::
* set_display_switch_mode::
* set_dissolve_blender::
* set_dodge_blender::
* set_filename_encoding::
* set_gdi_color_format::
* set_gfx_mode::
* set_hardware_volume::
* set_hue_blender::
* set_invert_blender::
* set_keyboard_rate::
* set_leds::
* set_luminance_blender::
* set_mixer_quality::
* set_mouse_cursor_bitmap::
* set_mouse_range::
* set_mouse_speed::
* set_mouse_sprite::
* set_mouse_sprite_focus::
* set_multiply_blender::
* set_palette::
* set_palette_range::
* set_palette_to_hdc::
* set_projection_viewport::
* set_saturation_blender::
* set_screen_blender::
* set_sound_input_source::
* set_trans_blender::
* set_ucodepage::
* set_uformat::
* set_volume::
* set_volume_per_voice::
* set_window_title::
* set_write_alpha_blender::
* set_zbuffer::
* show_mouse::
* show_os_cursor::
* show_video_bitmap::
* shutdown_dialog::
* shutdown_menu::
* simulate_keypress::
* simulate_ukeypress::
* solid_mode::
* spline::
* Standard config variables::
* start_sound_input::
* stop_audio_stream::
* stop_midi::
* stop_sample::
* stop_sound_input::
* stretch_blit::
* stretch_blit_from_hdc::
* stretch_blit_to_hdc::
* stretch_sprite::
* text_height::
* text_length::
* textout_centre_ex::
* textout_ex::
* textout_justify_ex::
* textout_right_ex::
* textprintf_centre_ex::
* textprintf_ex::
* textprintf_justify_ex::
* textprintf_right_ex::
* three_finger_flag::
* TRACE::
* transpose_font::
* triangle::
* triangle3d::
* Truecolor transparency::
* uatof::
* uconvert::
* uconvert_ascii::
* uconvert_size::
* uconvert_toascii::
* ucwidth::
* ugetat::
* ugetc::
* ugetx::
* uinsert::
* uisdigit::
* uisok::
* uisspace::
* Unix integration routines::
* unload_datafile::
* unload_datafile_object::
* unscare_mouse::
* unselect_palette::
* uoffset::
* update_dialog::
* update_menu::
* ureadkey::
* uremove::
* usetat::
* usetc::
* Using datafiles::
* usprintf::
* ustrcat::
* ustrchr::
* ustrcmp::
* ustrcpy::
* ustrdup::
* ustrerror::
* ustricmp::
* ustrlen::
* ustrlwr::
* ustrncat::
* ustrncmp::
* ustrncpy::
* ustrnicmp::
* ustrpbrk::
* ustrrchr::
* ustrsize::
* ustrsizez::
* ustrstr::
* ustrtod::
* ustrtok::
* ustrtok_r::
* ustrtol::
* ustrupr::
* ustrzcat::
* ustrzcpy::
* ustrzncat::
* ustrzncpy::
* uszprintf::
* utolower::
* utoupper::
* uvsprintf::
* uvszprintf::
* uwidth::
* uwidth_max::
* V3D::
* V3D_f::
* vector_length::
* VIRTUAL_W::
* vline::
* Voice control::
* voice_check::
* voice_get_frequency::
* voice_get_pan::
* voice_get_position::
* voice_get_volume::
* voice_ramp_volume::
* voice_set_echo::
* voice_set_frequency::
* voice_set_pan::
* voice_set_playmode::
* voice_set_position::
* voice_set_priority::
* voice_set_tremolo::
* voice_set_vibrato::
* voice_set_volume::
* voice_start::
* voice_stop::
* voice_stop_frequency_sweep::
* voice_stop_pan_sweep::
* voice_stop_volumeramp::
* voice_sweep_frequency::
* voice_sweep_pan::
* vsync::
* win_get_dc::
* win_get_window::
* win_release_dc::
* win_set_msg_pre_proc::
* win_set_window::
* win_set_wnd_create_proc::
* Windows integration routines::
* xor_mode::
* xwin_set_window_name::
* ZBUFFER::
* Zbuffered rendering::



Tag Table:
Node: Top288
Node: API1561
Node: Using3369
Node: install_allegro4140
Node: allegro_init5944
Node: allegro_exit6354
Node: END_OF_MAIN7448
Node: allegro_id8368
Node: allegro_error8646
Node: ALLEGRO_VERSION9608
Node: ALLEGRO_SUB_VERSION9913
Node: ALLEGRO_WIP_VERSION10237
Node: ALLEGRO_VERSION_STR10565
Node: ALLEGRO_DATE_STR10962
Node: ALLEGRO_DATE11251
Node: AL_ID11764
Node: MAKE_VERSION12215
Node: os_type13504
Node: os_version14805
Node: os_multitasking15390
Node: allegro_message15738
Node: set_window_title17134
Node: set_close_button_callback17687
Node: desktop_color_depth19533
Node: get_desktop_resolution20657
Node: check_cpu22012
Node: cpu_vendor22445
Node: cpu_family23013
Node: cpu_model24167
Node: cpu_capabilities25368
Node: Structures27247
Node: fixed28492
Node: BITMAP29056
Node: RLE_SPRITE30746
Node: COMPILED_SPRITE31483
Node: JOYSTICK_INFO32247
Node: JOYSTICK_BUTTON_INFO32982
Node: JOYSTICK_STICK_INFO33533
Node: JOYSTICK_AXIS_INFO34345
Node: GFX_MODE_LIST34911
Node: GFX_MODE35295
Node: PAL_SIZE35588
Node: PALETTE35829
Node: RGB36135
Node: V3D36747
Node: V3D_f37275
Node: COLOR_MAP37842
Node: RGB_MAP38342
Node: al_ffblk38817
Node: DATAFILE39285
Node: MATRIX39924
Node: MATRIX_f40436
Node: QUAT40970
Node: DIALOG41306
Node: MENU42223
Node: DIALOG_PLAYER42898
Node: MENU_PLAYER43342
Node: FONT43766
Node: ZBUFFER44245
Node: SAMPLE44731
Node: MIDI46572
Node: AUDIOSTREAM46921
Node: PACKFILE47695
Node: PACKFILE_VTABLE48354
Node: LZSS_PACK_DATA49392
Node: LZSS_UNPACK_DATA49827
Node: Unicode50268
Node: set_uformat54002
Node: get_uformat55529
Node: register_uformat56340
Node: set_ucodepage57262
Node: need_uconvert59356
Node: uconvert_size60445
Node: do_uconvert61277
Node: uconvert62245
Node: uconvert_ascii63913
Node: uconvert_toascii64313
Node: empty_string64706
Node: ugetc65139
Node: ugetx65580
Node: usetc66340
Node: uwidth66815
Node: ucwidth67251
Node: uisok67685
Node: uoffset68292
Node: ugetat69016
Node: usetat69688
Node: uinsert70480
Node: uremove71066
Node: ustrsize71724
Node: ustrsizez72048
Node: uwidth_max72373
Node: utolower72873
Node: utoupper73225
Node: uisspace73575
Node: uisdigit74151
Node: ustrdup74633
Node: _ustrdup75383
Node: ustrcpy75752
Node: ustrzcpy76254
Node: ustrcat77152
Node: ustrzcat77624
Node: ustrlen78475
Node: ustrcmp78817
Node: ustrncpy79298
Node: ustrzncpy79939
Node: ustrncat81076
Node: ustrzncat81977
Node: ustrncmp82643
Node: ustricmp83309
Node: ustrnicmp83969
Node: ustrlwr84666
Node: ustrupr85106
Node: ustrchr85544
Node: ustrrchr86124
Node: ustrstr86621
Node: ustrpbrk87098
Node: ustrtok87598
Node: ustrtok_r88769
Node: uatof89697
Node: ustrtol90147
Node: ustrtod91160
Node: ustrerror91854
Node: usprintf92526
Node: uszprintf93144
Node: uvsprintf93913
Node: uvszprintf94627
Node: Configuration95865
Node: set_config_file98645
Node: set_config_data99618
Node: override_config_file100338
Node: override_config_data102891
Node: push_config_state103771
Node: pop_config_state104563
Node: flush_config_file104935
Node: reload_config_texts105365
Node: hook_config_section106466
Node: config_is_hooked108058
Node: get_config_string108521
Node: get_config_int109554
Node: get_config_hex110096
Node: get_config_float110642
Node: get_config_id111180
Node: get_config_argv111709
Node: get_config_text112547
Node: set_config_string114128
Node: set_config_int115500
Node: set_config_hex115999
Node: set_config_float116520
Node: set_config_id117031
Node: list_config_entries117539
Node: list_config_sections119582
Node: free_config_entries120418
Node: Standard config variables121238
Node: Mouse140077
Node: install_mouse142683
Node: remove_mouse144043
Node: poll_mouse144385
Node: mouse_needs_poll145486
Node: enable_hardware_cursor145819
Node: disable_hardware_cursor146731
Node: select_mouse_cursor147457
Node: set_mouse_cursor_bitmap149713
Node: mouse_x151013
Node: mouse_sprite153007
Node: show_mouse153509
Node: scare_mouse155039
Node: scare_mouse_area155679
Node: unscare_mouse156194
Node: show_os_cursor156547
Node: freeze_mouse_flag158271
Node: position_mouse158766
Node: position_mouse_z159217
Node: position_mouse_w159556
Node: set_mouse_range159872
Node: set_mouse_speed160399
Node: set_mouse_sprite160811
Node: set_mouse_sprite_focus161584
Node: get_mouse_mickeys162131
Node: mouse_callback163002
Node: mouse_on_screen163830
Node: Timer164616
Node: install_timer165908
Node: remove_timer166582
Node: install_int167018
Node: install_int_ex167898
Node: LOCK_VARIABLE171564
Node: LOCK_FUNCTION172098
Node: END_OF_FUNCTION172649
Node: remove_int173201
Node: install_param_int173591
Node: install_param_int_ex174125
Node: remove_param_int174679
Node: retrace_count175309
Node: rest175950
Node: rest_callback176975
Node: Keyboard177470
Node: install_keyboard179148
Node: remove_keyboard180932
Node: install_keyboard_hooks181855
Node: poll_keyboard182705
Node: keyboard_needs_poll184042
Node: key184379
Node: key_shifts186663
Node: keypressed187909
Node: readkey188668
Node: ureadkey190328
Node: scancode_to_ascii191719
Node: scancode_to_name192623
Node: simulate_keypress193277
Node: simulate_ukeypress193889
Node: keyboard_callback194565
Node: keyboard_ucallback195853
Node: keyboard_lowlevel_callback197287
Node: set_leds199073
Node: set_keyboard_rate200035
Node: clear_keybuf200430
Node: three_finger_flag200936
Node: key_led_flag201627
Node: Joystick202163
Node: install_joystick202971
Node: remove_joystick204579
Node: poll_joystick204948
Node: num_joysticks205826
Node: joy206188
Node: calibrate_joystick_name211827
Node: calibrate_joystick212404
Node: save_joystick_data213747
Node: load_joystick_data214515
Node: initialise_joystick215274
Node: Graphics215560
Node: set_color_depth223979
Node: get_color_depth224830
Node: request_refresh_rate225596
Node: get_refresh_rate226791
Node: get_gfx_mode_list227183
Node: destroy_gfx_mode_list228353
Node: set_gfx_mode228863
Node: set_display_switch_mode231914
Node: set_display_switch_callback235042
Node: remove_display_switch_callback236169
Node: get_display_switch_mode236801
Node: is_windowed_mode237201
Node: get_gfx_mode_type238000
Node: get_gfx_mode239739
Node: gfx_capabilities240230
Node: enable_triple_buffer248740
Node: scroll_screen249462
Node: request_scroll250879
Node: poll_scroll251830
Node: show_video_bitmap252371
Node: request_video_bitmap253904
Node: vsync255504
Node: Bitmap256359
Node: screen260194
Node: SCREEN_W262011
Node: VIRTUAL_W262618
Node: create_bitmap263208
Node: create_bitmap_ex264684
Node: create_sub_bitmap265815
Node: create_video_bitmap266977
Node: create_system_bitmap268441
Node: destroy_bitmap269250
Node: lock_bitmap269961
Node: bitmap_color_depth270327
Node: bitmap_mask_color271081
Node: is_same_bitmap272111
Node: is_planar_bitmap272564
Node: is_linear_bitmap272920
Node: is_memory_bitmap273667
Node: is_screen_bitmap274217
Node: is_video_bitmap274566
Node: is_system_bitmap274960
Node: is_sub_bitmap275318
Node: acquire_bitmap275597
Node: release_bitmap279116
Node: acquire_screen279734
Node: release_screen280086
Node: set_clip_rect280437
Node: get_clip_rect282132
Node: add_clip_rect282534
Node: set_clip_state283045
Node: get_clip_state283718
Node: is_inside_bitmap284124
Node: Loading284827
Node: load_bitmap285475
Node: load_bmp287396
Node: load_bmp_pf287907
Node: load_lbm288742
Node: load_pcx289199
Node: load_pcx_pf289701
Node: load_tga290536
Node: load_tga_pf291053
Node: save_bitmap291891
Node: save_bmp293209
Node: save_bmp_pf293565
Node: save_pcx293898
Node: save_pcx_pf294254
Node: save_tga294570
Node: save_tga_pf294972
Node: register_bitmap_file_type295322
Node: set_color_conversion296331
Node: get_color_conversion301564
Node: Palette301853
Node: set_color303782
Node: _set_color304419
Node: set_palette305142
Node: set_palette_range305938
Node: get_color306704
Node: get_palette307062
Node: get_palette_range307523
Node: fade_interpolate307926
Node: fade_from_range308701
Node: fade_in_range309444
Node: fade_out_range310155
Node: fade_from310828
Node: fade_in311448
Node: fade_out312032
Node: select_palette312604
Node: unselect_palette313435
Node: generate_332_palette313757
Node: generate_optimized_palette314411
Node: default_palette315528
Node: black_palette316264
Node: desktop_palette316612
Node: Truecolor318097
Node: makecol8319109
Node: makeacol32320228
Node: makecol320959
Node: makecol_depth321747
Node: makeacol322445
Node: makecol15_dither323411
Node: getr8324502
Node: geta32325357
Node: getr325622
Node: getr_depth326417
Node: palette_color327339
Node: MASK_COLOR_8328197
Node: Drawing328835
Node: clear_bitmap329592
Node: clear_to_color329901
Node: putpixel330353
Node: _putpixel330931
Node: getpixel331712
Node: _getpixel332800
Node: vline333446
Node: hline334060
Node: do_line334639
Node: line335471
Node: fastline335892
Node: triangle336371
Node: polygon336769
Node: rect337522
Node: rectfill337897
Node: do_circle338447
Node: circle339355
Node: circlefill339864
Node: do_ellipse340383
Node: ellipse341324
Node: ellipsefill341713
Node: do_arc342120
Node: arc343377
Node: calc_spline344218
Node: spline345415
Node: floodfill345886
Node: Blitting346217
Node: blit351808
Node: stretch_blit354953
Node: masked_blit356177
Node: masked_stretch_blit357700
Node: draw_sprite_ex358754
Node: draw_sprite360008
Node: stretch_sprite362031
Node: draw_sprite_v_flip362930
Node: draw_trans_sprite364155
Node: draw_lit_sprite366231
Node: draw_gouraud_sprite368021
Node: draw_character_ex369533
Node: rotate_sprite370568
Node: rotate_sprite_v_flip371742
Node: rotate_scaled_sprite372435
Node: rotate_scaled_sprite_v_flip373007
Node: pivot_sprite373544
Node: pivot_sprite_v_flip374084
Node: pivot_scaled_sprite374643
Node: pivot_scaled_sprite_v_flip375258
Node: rotate_sprite_trans375931
Node: rotate_sprite_v_flip_trans377192
Node: rotate_scaled_sprite_trans377951
Node: rotate_scaled_sprite_v_flip_trans378589
Node: pivot_sprite_trans379186
Node: pivot_sprite_v_flip_trans379791
Node: pivot_scaled_sprite_trans380410
Node: pivot_scaled_sprite_v_flip_trans381091
Node: rotate_sprite_lit381828
Node: rotate_sprite_v_flip_lit383069
Node: rotate_scaled_sprite_lit383806
Node: rotate_scaled_sprite_v_flip_lit384422
Node: pivot_sprite_lit384999
Node: pivot_sprite_v_flip_lit385584
Node: pivot_scaled_sprite_lit386183
Node: pivot_scaled_sprite_v_flip_lit386842
Node: RLE387554
Node: get_rle_sprite389577
Node: destroy_rle_sprite390701
Node: draw_rle_sprite391202
Node: draw_trans_rle_sprite391833
Node: draw_lit_rle_sprite393232
Node: Compiled394419
Node: get_compiled_sprite395543
Node: destroy_compiled_sprite397061
Node: draw_compiled_sprite397625
Node: Fonts398586
Node: register_font_file_type399861
Node: load_font400975
Node: destroy_font402817
Node: make_trans_font403373
Node: is_trans_font404309
Node: is_color_font404756
Node: is_mono_font405163
Node: font_has_alpha405568
Node: is_compatible_font405959
Node: get_font_ranges406533
Node: get_font_range_begin407561
Node: get_font_range_end408489
Node: extract_font_range409692
Node: transpose_font410936
Node: merge_fonts411868
Node: load_dat_font413567
Node: load_bios_font415876
Node: load_grx_font416457
Node: load_grx_or_bios_font417030
Node: load_bitmap_font417644
Node: grab_font_from_bitmap419887
Node: load_txt_font420613
Node: Text421922
Node: font422760
Node: allegro_404_char423335
Node: text_length423884
Node: text_height424385
Node: textout_ex424885
Node: textout_centre_ex426070
Node: textout_right_ex426856
Node: textout_justify_ex427458
Node: textprintf_ex428654
Node: textprintf_centre_ex429654
Node: textprintf_right_ex430512
Node: textprintf_justify_ex431280
Node: Polygon432507
Node: POLYTYPE_FLAT433979
Node: POLYTYPE_GCOL434500
Node: POLYTYPE_GRGB435197
Node: POLYTYPE_ATEX435916
Node: POLYTYPE_PTEX436682
Node: POLYTYPE_ATEX_MASK437535
Node: POLYTYPE_ATEX_LIT438020
Node: POLYTYPE_ATEX_MASK_LIT438780
Node: POLYTYPE_ATEX_TRANS439329
Node: POLYTYPE_ATEX_MASK_TRANS440009
Node: polygon3d440437
Node: triangle3d444783
Node: quad3d445733
Node: clip3d_f446460
Node: clip3d447834
Node: Zbuffered rendering448455
Node: create_zbuffer450405
Node: create_sub_zbuffer451168
Node: set_zbuffer452697
Node: clear_zbuffer453112
Node: destroy_zbuffer453745
Node: Scene rendering454162
Node: create_scene457244
Node: clear_scene458034
Node: destroy_scene458449
Node: scene_polygon3d458871
Node: render_scene460680
Node: scene_gap461511
Node: Transparency462869
Node: drawing_mode463653
Node: xor_mode467732
Node: solid_mode468203
Node: 256-color transparency468568
Node: color_map469721
Node: create_trans_table470651
Node: create_light_table472264
Node: create_color_table473810
Node: create_blender_table475571
Node: Truecolor transparency476565
Node: set_trans_blender478408
Node: set_alpha_blender479391
Node: set_write_alpha_blender480435
Node: set_add_blender481378
Node: set_burn_blender481754
Node: set_color_blender482262
Node: set_difference_blender482791
Node: set_dissolve_blender483311
Node: set_dodge_blender483940
Node: set_hue_blender484450
Node: set_invert_blender484877
Node: set_luminance_blender485342
Node: set_multiply_blender485851
Node: set_saturation_blender486485
Node: set_screen_blender486958
Node: set_blender_mode487544
Node: set_blender_mode_ex488167
Node: Converting489043
Node: bestfit_color490935
Node: rgb_map491657
Node: create_rgb_table492499
Node: hsv_to_rgb493246
Node: Direct494153
Node: bmp_write_line496726
Node: bmp_read_line497113
Node: bmp_unwrite_line497485
Node: More on banked direct memory access497991
Node: FLIC501680
Node: play_fli503651
Node: play_memory_fli505003
Node: open_fli506645
Node: close_fli507510
Node: next_fli_frame507819
Node: fli_bitmap508702
Node: fli_palette509081
Node: fli_bmp_dirty_from509387
Node: fli_pal_dirty_from510355
Node: reset_fli_variables511273
Node: fli_frame511711
Node: fli_timer512449
Node: Sound513299
Node: detect_digi_driver514755
Node: detect_midi_driver515388
Node: reserve_voices516382
Node: set_volume_per_voice517555
Node: install_sound521079
Node: remove_sound522710
Node: set_volume523080
Node: set_hardware_volume523726
Node: get_volume524447
Node: get_hardware_volume524956
Node: Mixer525542
Node: set_mixer_quality525828
Node: get_mixer_quality526375
Node: get_mixer_frequency526779
Node: get_mixer_bits527064
Node: get_mixer_channels527338
Node: get_mixer_voices527682
Node: get_mixer_buffer_length527971
Node: Digital528295
Node: load_sample529238
Node: load_wav530104
Node: load_wav_pf530654
Node: load_voc531384
Node: load_voc_pf531942
Node: save_sample532675
Node: create_sample533387
Node: destroy_sample534309
Node: lock_sample534800
Node: register_sample_file_type535224
Node: play_sample535941
Node: adjust_sample537051
Node: stop_sample537844
Node: Voice control538342
Node: allocate_voice539386
Node: deallocate_voice540215
Node: reallocate_voice540572
Node: release_voice541092
Node: voice_start541685
Node: voice_stop542044
Node: voice_set_priority542435
Node: voice_check542863
Node: voice_get_position543432
Node: voice_set_position543797
Node: voice_set_playmode544162
Node: voice_get_volume545917
Node: voice_set_volume546364
Node: voice_ramp_volume546709
Node: voice_stop_volumeramp547189
Node: voice_get_frequency547489
Node: voice_set_frequency547820
Node: voice_sweep_frequency548187
Node: voice_stop_frequency_sweep548635
Node: voice_get_pan548961
Node: voice_set_pan549278
Node: voice_sweep_pan549616
Node: voice_stop_pan_sweep550040
Node: voice_set_echo550325
Node: voice_set_tremolo550649
Node: voice_set_vibrato550983
Node: Music551312
Node: load_midi553152
Node: destroy_midi553788
Node: lock_midi554257
Node: play_midi554608
Node: play_looped_midi555591
Node: stop_midi556334
Node: midi_pause556646
Node: midi_resume556928
Node: midi_seek557171
Node: get_midi_length557938
Node: midi_out559059
Node: load_midi_patches559508
Node: midi_pos560098
Node: midi_time560588
Node: midi_loop_start561015
Node: midi_msg_callback561745
Node: load_ibk562669
Node: Audio563426
Node: play_audio_stream564685
Node: stop_audio_stream566712
Node: get_audio_stream_buffer567065
Node: free_audio_stream_buffer568468
Node: Recording569229
Node: install_sound_input570529
Node: remove_sound_input571608
Node: get_sound_input_cap_bits572081
Node: get_sound_input_cap_stereo573151
Node: get_sound_input_cap_rate573691
Node: get_sound_input_cap_parm574647
Node: set_sound_input_source575631
Node: start_sound_input576232
Node: stop_sound_input576939
Node: read_sound_input577254
Node: digi_recorder578480
Node: midi_recorder579193
Node: File579740
Node: get_executable_name583470
Node: fix_filename_case584302
Node: fix_filename_slashes584958
Node: canonicalize_filename585745
Node: make_absolute_filename586997
Node: make_relative_filename587886
Node: is_relative_filename589073
Node: replace_filename589628
Node: replace_extension590492
Node: append_filename591361
Node: get_filename592171
Node: get_extension593402
Node: put_backslash594122
Node: set_filename_encoding594631
Node: get_filename_encoding594972
Node: file_exists595280
Node: exists596007
Node: file_size_ex596484
Node: file_time596891
Node: delete_file597334
Node: for_each_file_ex597642
Node: al_findfirst599737
Node: al_findnext601242
Node: al_findclose601946
Node: al_ffblk_get_size602377
Node: find_allegro_resource602767
Node: set_allegro_resource_path604428
Node: packfile_password605850
Node: pack_fopen608153
Node: pack_fopen_vtable611771
Node: pack_fclose612861
Node: pack_fseek613619
Node: pack_feof614617
Node: pack_ferror615359
Node: pack_getc616084
Node: pack_ungetc616422
Node: pack_putc616960
Node: pack_igetw617302
Node: pack_iputw617656
Node: pack_igetl618017
Node: pack_iputl618373
Node: pack_mgetw618736
Node: pack_mputw619086
Node: pack_mgetl619442
Node: pack_mputl619793
Node: pack_fread620151
Node: pack_fwrite620860
Node: pack_fgets621354
Node: pack_fputs622623
Node: pack_fopen_chunk623285
Node: pack_fclose_chunk626276
Node: create_lzss_pack_data626814
Node: free_lzss_pack_data627277
Node: lzss_write627640
Node: create_lzss_unpack_data628192
Node: free_lzss_unpack_data628671
Node: lzss_read629049
Node: Datafile629533
Node: load_datafile633698
Node: load_datafile_callback635041
Node: unload_datafile636714
Node: load_datafile_object637171
Node: unload_datafile_object638489
Node: find_datafile_object638900
Node: create_datafile_index639873
Node: load_datafile_object_indexed641172
Node: destroy_datafile_index641867
Node: get_datafile_property642267
Node: register_datafile_object643144
Node: fixup_datafile643679
Node: DAT_ID645507
Node: Using datafiles646067
Node: Custom datafile objects654373
Node: Fixed658331
Node: itofix660750
Node: fixtoi661816
Node: fixfloor662513
Node: fixceil663038
Node: ftofix663550
Node: fixtof664410
Node: fixmul664946
Node: fixdiv666127
Node: fixadd667345
Node: fixsub668351
Node: Fixed point trig669380
Node: fixtorad_r670425
Node: radtofix_r671049
Node: fixsin671543
Node: fixcos672325
Node: fixtan673137
Node: fixasin673916
Node: fixacos675002
Node: fixatan675842
Node: fixatan2676465
Node: fixsqrt677534
Node: fixhypot677918
Node: Fix class678308
Node: 3D679426
Node: identity_matrix685308
Node: get_translation_matrix685683
Node: get_scaling_matrix686361
Node: get_x_rotate_matrix687008
Node: get_y_rotate_matrix687665
Node: get_z_rotate_matrix688323
Node: get_rotation_matrix688981
Node: get_align_matrix690145
Node: get_align_matrix_f690762
Node: get_vector_rotation_matrix691125
Node: get_transformation_matrix691802
Node: get_transformation_matrix_f692592
Node: get_camera_matrix693026
Node: get_camera_matrix_f694954
Node: qtranslate_matrix695377
Node: qscale_matrix695965
Node: matrix_mul696486
Node: vector_length697376
Node: normalize_vector697767
Node: dot_product698280
Node: cross_product698701
Node: polygon_z_normal699341
Node: apply_matrix700560
Node: set_projection_viewport701107
Node: persp_project702321
Node: Quaternion703663
Node: identity_quat705031
Node: get_x_rotate_quat705355
Node: get_rotation_quat705894
Node: get_vector_rotation_quat706332
Node: quat_to_matrix706769
Node: matrix_to_quat707094
Node: quat_mul707550
Node: apply_quat708138
Node: quat_interpolate708682
Node: quat_slerp709366
Node: GUI710123
Node: d_clear_proc720778
Node: d_box_proc721113
Node: d_bitmap_proc721463
Node: d_text_proc721797
Node: d_button_proc722644
Node: d_check_proc723270
Node: d_radio_proc723971
Node: d_icon_proc724506
Node: d_keyboard_proc725320
Node: d_edit_proc726108
Node: d_list_proc726920
Node: d_text_list_proc728242
Node: d_textbox_proc728694
Node: d_slider_proc729478
Node: d_menu_proc730324
Node: d_yield_proc731511
Node: GUI variables732139
Node: gui_mouse_focus732373
Node: gui_fg_color732671
Node: gui_mg_color733077
Node: gui_font_baseline733434
Node: gui_mouse_x733760
Node: GUI font734329
Node: gui_textout_ex734746
Node: gui_strlen735244
Node: gui_set_screen735570
Node: gui_get_screen736366
Node: position_dialog736829
Node: centre_dialog737223
Node: set_dialog_color737567
Node: find_dialog_focus737971
Node: offer_focus738607
Node: object_message739186
Node: dialog_message739986
Node: broadcast_dialog_message740500
Node: do_dialog740943
Node: popup_dialog741864
Node: init_dialog742395
Node: update_dialog743496
Node: shutdown_dialog744096
Node: active_dialog744520
Node: GUI menus744946
Node: do_menu746521
Node: init_menu747226
Node: update_menu748065
Node: shutdown_menu748579
Node: active_menu749044
Node: gui_menu_draw_menu749441
Node: alert750301
Node: alert3751275
Node: file_select_ex751583
Node: gfx_mode_select753937
Node: gfx_mode_select_ex754999
Node: gfx_mode_select_filter756188
Node: gui_shadow_box_proc758858
Node: Platform759750
Node: DOS760196
Node: JOY_TYPE_*/DOS761609
Node: GFX_*/DOS768700
Node: DIGI_*/DOS777240
Node: MIDI_*/DOS778243
Node: DOS integration routines779274
Node: i_love_bill779441
Node: Windows780525
Node: JOY_TYPE_*/Windows784485
Node: GFX_*/Windows785521
Node: DIGI_*/Windows789930
Node: MIDI_*/Windows790759
Node: Windows integration routines791420
Node: win_get_window791823
Node: win_set_window792240
Node: win_set_wnd_create_proc793735
Node: win_get_dc794712
Node: win_release_dc794992
Node: win_set_msg_pre_proc795317
Node: GDI routines796184
Node: set_gdi_color_format797683
Node: set_palette_to_hdc798151
Node: convert_palette_to_hpalette798480
Node: convert_hpalette_to_palette798955
Node: convert_bitmap_to_hbitmap799351
Node: convert_hbitmap_to_bitmap799950
Node: draw_to_hdc800313
Node: blit_to_hdc800744
Node: stretch_blit_to_hdc801190
Node: blit_from_hdc801692
Node: stretch_blit_from_hdc802188
Node: Unix802937
Node: JOY_TYPE_*/Linux807239
Node: GFX_*/Linux808204
Node: GFX_*/X810419
Node: DIGI_*/Unix812905
Node: MIDI_*/Unix813620
Node: Unix integration routines814240
Node: xwin_set_window_name814421
Node: allegro_icon815150
Node: BeOS815666
Node: GFX_*/BeOS816017
Node: DIGI_*/BeOS817851
Node: MIDI_*/BeOS818342
Node: QNX818892
Node: GFX_*/QNX819286
Node: DIGI_*/QNX821111
Node: MIDI_*/QNX821592
Node: QNX integration routines822153
Node: qnx_get_window822534
Node: MacOS822947
Node: GFX_*/MacOSX825275
Node: DIGI_*/MacOSX826557
Node: MIDI_*/MacOSX827164
Node: Differences827832
Node: Miscellaneous835897
Node: Reducing836182
Node: Debugging842467
Node: ASSERT843328
Node: TRACE844226
Node: register_assert_handler844966
Node: register_trace_handler846113
Node: al_assert847256
Node: al_trace848201
Node: Available848884
Node: exhello850090
Node: exmem850746
Node: expal851524
Node: expat852227
Node: exflame853060
Node: exdbuf853986
Node: exflip854872
Node: exfixed855685
Node: exfont856335
Node: exmouse857065
Node: extimer858723
Node: exkeys859781
Node: exjoy861265
Node: exsample862430
Node: exmidi863591
Node: exgui864518
Node: excustom866007
Node: exunicod867248
Node: exbitmap868564
Node: exscale869349
Node: exconfig870111
Node: exdata871453
Node: exsprite872212
Node: exrotscl875189
Node: exexedat876108
Node: extrans877302
Node: extrans2879097
Node: extruec880029
Node: excolmap880989
Node: exrgbhsv882520
Node: exshade884208
Node: exblend885623
Node: exxfade886859
Node: exalpha887964
Node: exlights889380
Node: ex3d892490
Node: excamera894998
Node: exquat896440
Node: exstars898768
Node: exscn3d899975
Node: exzbuf901565
Node: exscroll903314
Node: ex3buf904116
Node: ex12bit905451
Node: exaccel908314
Node: exspline909616
Node: exsyscur912800
Node: exupdate913509
Node: exswitch915507
Node: exstream917227
Node: expackf918277
Node: Tools919749
Node: Additional919929
Node: Community920421
Node: Conclusion923319
Node: Index923891

End Tag Table
